<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>江影不沉浮</title>
  
  <subtitle>You can, just if you want!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.zjee.ml/"/>
  <updated>2020-01-05T07:58:32.000Z</updated>
  <id>http://blog.zjee.ml/</id>
  
  <author>
    <name>jackcharles</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JDK动态代理</title>
    <link href="http://blog.zjee.ml/2020/01/05/jdk-proxy/"/>
    <id>http://blog.zjee.ml/2020/01/05/jdk-proxy/</id>
    <published>2020-01-05T07:58:32.000Z</published>
    <updated>2020-01-05T07:58:32.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>代理</strong>是一种结构型设计模式， 让你能提供真实服务对象的替代品给客户端使用。 代理接收客户端的请求并进行一些处理 （访问控制和缓存等）， 然后再将请求传递给服务对象。</p><p>代理对象拥有和服务对象相同的接口， 这使得当其被传递给客户端时可与真实对象互换。 </p><p style="text-align:right">——Copy From <a href="https://refactoring.guru/design-patterns/proxy/java/example" target="_blank">refactoring.guru</a></p>                                                                                                                       </blockquote><h1 id="一、静态代理"><a href="#一、静态代理" class="headerlink" title="一、静态代理"></a>一、静态代理</h1><p>静态代理代码很简单，但其设计思想很重要。示例如下：</p><details><summary style="color:blue">点击查看代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//UserService.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"><span class="function">User <span class="title">getUser</span><span class="params">(<span class="keyword">int</span> userId)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//UserServiceImpl.java UserService的实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(<span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> User(userId, xxx, xxx);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//UserServiceProxy.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceProxy</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> UserService delegate;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">UserServiceProxy</span><span class="params">(UserService target)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.delegate = target; <span class="comment">//被代理对象</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(<span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//前置增强</span></span><br><span class="line">    System.out.println(<span class="string">"before get user"</span>);</span><br><span class="line">  User user = <span class="keyword">this</span>.delegate.getUser(userId);</span><br><span class="line">    <span class="comment">//后置增强</span></span><br><span class="line">    System.out.println(<span class="string">"after get user"</span>);</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Test.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  UserService target = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">    UserService proxy = <span class="keyword">new</span> UserServiceProxy(target);</span><br><span class="line">    User user = proxy.getUser(<span class="number">1001</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></details><h1 id="二、JDK动态代理"><a href="#二、JDK动态代理" class="headerlink" title="二、JDK动态代理"></a>二、JDK动态代理</h1><p>JDK动态代理可以看成一个“万能中介”，它最终实现方法粒度的增强，它的<code>InvocationHandler</code>是“万能的”，根据我们传入的target以及调用不同的方法实现不同的增强效果。需要注意的是JDK动态代理只能代理接口，这与它背后的实现逻辑有关系。</p><h2 id="2-1、为什么需要动态代理"><a href="#2-1、为什么需要动态代理" class="headerlink" title="2.1、为什么需要动态代理"></a>2.1、为什么需要动态代理</h2><p>静态代理虽然能够实现大多数功能，但每个目标对象都需要生成一个代理类，当被代理类太多时，开发和维护代理类将是一件很可怕的事情，同时静态代理还不具备处理动态生成的class的能力。基于上诉痛点，各种动态代理技术应运而生，JDK动态代理便是其中之一。</p><h2 id="2-2、JDK动态代理示例"><a href="#2-2、JDK动态代理示例" class="headerlink" title="2.2、JDK动态代理示例"></a>2.2、JDK动态代理示例</h2><details><summary style="color:blue">点击查看代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口&amp;实现类参考上面静态代理的例子</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//DynamicProxy.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//真正的实现类,或者说被代理对象（不是必须的）</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DynamicProxy</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//前置增强</span></span><br><span class="line">        System.out.println(<span class="string">"before invoke"</span>);</span><br><span class="line">        Object res = method.invoke(target, args);</span><br><span class="line">        <span class="comment">//后置增强</span></span><br><span class="line">        System.out.println(<span class="string">"after invoke"</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Test.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//代理类对象，注意它不是我们的目标代理对象，可以理解为它只是个中介</span></span><br><span class="line">        InvocationHandler handler = <span class="keyword">new</span> DynamicProxy(<span class="keyword">new</span> UserServiceImpl());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//动态生成最终目标代理对象</span></span><br><span class="line">        UserService proxy = (UserService) Proxy.newProxyInstance(</span><br><span class="line">                UserServiceImpl.class.getClassLoader(),</span><br><span class="line">                UserServiceImpl.class.getInterfaces(),</span><br><span class="line">                handler</span><br><span class="line">        );</span><br><span class="line">        proxy.getUser(<span class="number">123</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br></details><p>我们可以看到，JDK动态代理核心就在于实现<code>InvocationHandler</code>，重写<code>invoke</code>方法。</p><h2 id="2-3、InvocationHandler接口"><a href="#2-3、InvocationHandler接口" class="headerlink" title="2.3、InvocationHandler接口"></a>2.3、InvocationHandler接口</h2><ol><li><p><code>InvocationHandler</code>可以理解为一个”执行器“，每个被代理的对象中的所有方法都要经过它，由它决定下一步怎么处理，所以实现<code>InvocationHandler</code>是整个JDK动态代理的核心，不同的功能可以使用不同的<code>InvocationHandler</code>来实现。</p></li><li><p><code>InvocationHandler</code>中的核心方法<code>invoke</code>：</p><p>2.1、<strong>Object proxy：</strong> 该参数是<strong><em>最终的</em>目标代理对象</strong>，一般代理用不到它，在具有链式操作的代理对象中可以直接返回该对象，使得最终代理对象也可以使用链式操作。</p><p>2.2 、<strong>Method method：</strong>该参数是我们要调用的<strong>目标方法</strong>，一般会使用<code>method.invoke(target, args)</code>继续调用被代理对象的具体实现。</p><p>2.3、<strong>Object[] args</strong>: 该参数是目标方法参数。</p><p>2.4、<strong>返回值</strong>：由于该方法是“万能的”，因此我们可以根据传入的参数、调用的方法、目标对象不同而返回不同的结果。</p></li><li><p>注意事项</p><p>3.1、在调用目标方法时，传入的实例对象<strong>不可以</strong>是第一个参数proxy，该参数是最终生成的代理对象，如果继续在它上面调用方法的话就又会回到该方法，从而形成死循环。</p><p>3.2、JDK动态代理只能代理java接口（interface）。</p></li></ol><h2 id="2-4、JDK动态代理在MyBatis中的运用"><a href="#2-4、JDK动态代理在MyBatis中的运用" class="headerlink" title="2.4、JDK动态代理在MyBatis中的运用"></a>2.4、JDK动态代理在MyBatis中的运用</h2><p>我们都知道Mybatis只要一个接口和一个XML Mapper（或注解），就能完成增删改查操作，其实Mybatis也是利用JDK动态代理生成的Mapper实例进行调用，下面直接看源码：</p><img src="/2020/01/05/jdk-proxy/mybatis-1.png" title="mybatis源码-1"><p>这就是生成Mapper实例的代码，其中的<code>mapperInterface</code>就是我们写的Mapper接口，但有一个<code>mapperProxy</code>比较重要，它就是我们说的“万能中介”，看看它是怎么实现的：</p><img src="/2020/01/05/jdk-proxy/mybatis-2.png" title="mybatis源码-2"><p>这个<code>MapperProxy</code>也实现了<code>nvocationHandler</code>接口，但与上面介绍的些许不同，之前的动态代理需要一个接口的实现类，但这里并没有实现类。其实<strong>JDK动态代理并不要求实现类</strong>，在invoke方法内部我们完全可以根据三个参数去“创造”结果，然后返回即可。</p><p>可以看到，Mybatis根据传入的方法“创造”了另一个“方法”<code>MapperMethod</code>，然后去执行这个新“方法”，最终返回结果。这个创造方法的过程就是根据我们之前的Mapper.xml或注解获得SQL语句，然后根据传入的参数构造statement，最后就直接执行了，具体参考Mybatis源码。</p><h2 id="2-5、JDK动态代理底层原理"><a href="#2-5、JDK动态代理底层原理" class="headerlink" title="2.5、JDK动态代理底层原理"></a>2.5、JDK动态代理底层原理</h2><ol><li><p>先看生成的代理类</p><p>1.1、保存代理类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法1</span></span><br><span class="line"><span class="keyword">byte</span>[] bytes = ProxyGenerator.generateProxyClass(<span class="string">"stuMapperProxy"</span>, stuMapper.getClass().getInterfaces());<span class="comment">//获取代理类bytes数组</span></span><br><span class="line">com.google.common.io.Files.write(bytes, <span class="keyword">new</span> File(<span class="string">"proxy$0.class"</span>));<span class="comment">//保存bytes数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//方法2：代码中加入下面一条属性，默认保存的class文件在项目根目录下com/sun/proxy下面</span></span><br><span class="line">System.getProperties().put(<span class="string">"sun.misc.ProxyGenerator.saveGeneratedFiles"</span>, <span class="string">"true"</span>);</span><br></pre></td></tr></table></figure><p>1.2、反编译代理类（以下代码精简掉无关逻辑及异常处理部分）<br><details><summary style="color:blue">点击查看代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">stuMapperProxy</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">StuMapper</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0; <span class="comment">//hashCode</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1; <span class="comment">//equals</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2; <span class="comment">//toString</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3; <span class="comment">//业务方法selectAll</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m4; <span class="comment">//业务方法addStudent</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 代理类继承自Proxy，Proxy中有一个InvocationHandler成员，它就是我们需要实现的那一部分。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">stuMapperProxy</span><span class="params">(InvocationHandler var1)</span> <span class="keyword">throws</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(var1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//equals方法，通过InvocationHandler调用我们的目标对像的equals范方法</span></span><br><span class="line">    <span class="comment">//下面的其他方法同理。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object var1)</span> <span class="keyword">throws</span> </span>&#123;</span><br><span class="line">        <span class="comment">//super.h就是InvocationHandler实例，其中的invoke方法被我们增强过</span></span><br><span class="line">        <span class="comment">//this: 当前代理对象</span></span><br><span class="line">        <span class="comment">//m1: 当前方法</span></span><br><span class="line">        <span class="comment">//m2: 方法参数</span></span><br><span class="line">        <span class="keyword">return</span> (Boolean) <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m1, <span class="keyword">new</span> Object[]&#123;var1&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> <span class="keyword">throws</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (String) <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m2, (Object[]) <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//代理的业务方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> List <span class="title">selectAll</span><span class="params">()</span> <span class="keyword">throws</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (List) <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m3, (Object[]) <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//代理的业务方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addStudent</span><span class="params">(<span class="keyword">int</span> var1, String var2, <span class="keyword">int</span> var3, String var4)</span> <span class="keyword">throws</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m4, <span class="keyword">new</span> Object[]&#123;var1, var2, var3, var4&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> <span class="keyword">throws</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Integer) <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m0, (Object[]) <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//前3个方法&#123;m0,m1,m2&#125;固定为hashCode, equals, toString</span></span><br><span class="line">    <span class="comment">//从后面开始就是我们定义的业务方法</span></span><br><span class="line">    <span class="comment">//这些方法都是通过反射的方式获取到的</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        m0 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"hashCode"</span>);</span><br><span class="line">        m1 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"equals"</span>, Class.forName(<span class="string">"java.lang.Object"</span>));</span><br><span class="line">        m2 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"toString"</span>);</span><br><span class="line">        m3 = Class.forName(<span class="string">"com.sptest.mapper.StuMapper"</span>).getMethod(<span class="string">"selectAll"</span>);</span><br><span class="line">        m4 = Class.forName(<span class="string">"com.sptest.mapper.StuMapper"</span>).getMethod(<span class="string">"addStudent"</span>, Integer.TYPE, Class.forName(<span class="string">"java.lang.String"</span>), Integer.TYPE, Class.forName(<span class="string">"java.lang.String"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></p><p>这里注意：生成的代理类已经继承了<code>Proxy</code>类,无法再继承其他类，所以只能实现业务接口，这也就是为什么JDK只能代理接口的原因。</p><p>1.3、代理类调用流程</p><img src="/2020/01/05/jdk-proxy/proxy-call.png" title="代理类调用流程"></li><li><p>代理对象生成过程（省略安全检查及异常处理代码）</p><p>2.1、从<code>newProxyInstance</code>入手<br><details><summary style="color:blue">点击查看代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Class&lt;?&gt;[] intfs = interfaces.clone();</span><br><span class="line">  <span class="comment">//获取代理类[重要]</span></span><br><span class="line">  Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</span><br><span class="line">  <span class="comment">//获取代理类构造方法</span></span><br><span class="line">  <span class="keyword">final</span> Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</span><br><span class="line">  <span class="comment">//通过构造方法创建代理对象并返回</span></span><br><span class="line">  <span class="keyword">return</span> cons.newInstance(<span class="keyword">new</span> Object[]&#123;h&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></p><p>2.2、生成代理类<br><details><summary style="color:blue">点击查看代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Class&lt;?&gt; getProxyClass0(ClassLoader loader, Class&lt;?&gt;... interfaces) &#123;</span><br><span class="line">  <span class="keyword">if</span> (interfaces.length &gt; <span class="number">65535</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"interface limit exceeded"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If the proxy class defined by the given loader implementing 如果代理类已经被给定的类加载器加载了</span></span><br><span class="line">  <span class="comment">// the given interfaces exists, this will simply return the cached copy; 并且给定的接口也存在，则直接从缓存中拷贝一份返回即可</span></span><br><span class="line">  <span class="comment">// otherwise, it will create the proxy class via the ProxyClassFactory 否则，就通过ProxyClassFactory创造一个代理类</span></span><br><span class="line">  <span class="keyword">return</span> proxyClassCache.get(loader, interfaces);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个proxyClassCache是通过如下方式初始化的，proxyClassCache仅仅是一个k-v缓存,获取值时如果不存在就从给定的factory创造一个</span></span><br><span class="line"><span class="comment">//给定的factory有KeyFactory，用于获取生成key, ProxyClassFactory用于生成value，也就是代理类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> WeakCache&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt; proxyClassCache = <span class="keyword">new</span> WeakCache&lt;&gt;(<span class="keyword">new</span> KeyFactory(), <span class="keyword">new</span> ProxyClassFactory());</span><br></pre></td></tr></table></figure></details></p><p>2.3、来到<code>ProxyClassFactory</code><br><details><summary style="color:blue">点击查看代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">private static final class ProxyClassFactory implements BiFunction&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt; &#123;</span><br><span class="line">    <span class="comment">// 生成的代理类名前缀</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String proxyClassNamePrefix = <span class="string">"$Proxy"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 代理类名后缀生成器，其实就是一个递增数字，用AtomicLong实现</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicLong nextUniqueNumber = <span class="keyword">new</span> AtomicLong();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123;</span><br><span class="line">        <span class="comment">//需要代理的接口</span></span><br><span class="line">        Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = <span class="keyword">new</span> IdentityHashMap&lt;&gt;(interfaces.length);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//代理类包名</span></span><br><span class="line">        String proxyPkg = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> accessFlags = Modifier.PUBLIC | Modifier.FINAL;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//省略其他包名生成，策略...</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (proxyPkg == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//使用默认包名 com.sun.proxy package</span></span><br><span class="line">            proxyPkg = ReflectUtil.PROXY_PACKAGE + <span class="string">"."</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//生成类名后缀(数字)，最终就像$Proxy0这样</span></span><br><span class="line">        <span class="keyword">long</span> num = nextUniqueNumber.getAndIncrement();</span><br><span class="line">        String proxyName = proxyPkg + proxyClassNamePrefix + num;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//生成代理类字节码【核心】</span></span><br><span class="line">        <span class="keyword">byte</span>[] proxyClassFile = ProxyGenerator.generateProxyClass(</span><br><span class="line">                proxyName, interfaces, accessFlags);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//装载代理类，返回class对象</span></span><br><span class="line">        <span class="keyword">return</span> defineClass0(loader, proxyName, proxyClassFile, <span class="number">0</span>, proxyClassFile.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></p><p>2.4、继续探索<code>ProxyGenerator.generateProxyClass</code><br><details><summary style="color:blue">点击查看代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先看看ProxyGenerator都有些什么</span></span><br><span class="line"><span class="comment">//定义了一堆常量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CLASSFILE_MAJOR_VERSION = <span class="number">49</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CLASSFILE_MINOR_VERSION = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONSTANT_UTF8 = <span class="number">1</span>;</span><br><span class="line">...</span><br><span class="line"><span class="comment">//定义了一堆指令</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> opc_iload = <span class="number">21</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> opc_lload = <span class="number">22</span>;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String superclassName = <span class="string">"java/lang/reflect/Proxy"</span>; <span class="comment">//生成的代理类的父类名称</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String handlerFieldName = <span class="string">"h"</span>; <span class="comment">//生成的代理类的父类(Proxy)中InvocationHandler成员的名字(代理类需要使用)</span></span><br><span class="line"><span class="comment">//是否需要保存生成的文件，系统变量设置了 sun.misc.ProxyGenerator.saveGeneratedFiles 为 true 就保存代理类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> saveGeneratedFiles = (Boolean)AccessController.doPrivileged(<span class="keyword">new</span> GetBooleanAction(<span class="string">"sun.misc.ProxyGenerator.saveGeneratedFiles"</span>));</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Method hashCodeMethod; <span class="comment">//生成的代理类的hashCode方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Method equalsMethod; <span class="comment">//生成的代理类的equals方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Method toStringMethod; <span class="comment">//生成的代理类的toString方法</span></span><br><span class="line"><span class="keyword">private</span> String className; <span class="comment">//生成的代理类全类名 如：com.sun.proxy.$Proxy0</span></span><br><span class="line"><span class="keyword">private</span> Class&lt;?&gt;[] interfaces; <span class="comment">//生成的代理类需要实现的接口，就是我们代理的接口</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> accessFlags;<span class="comment">//生成的代理类的访问标志(Modifiers)，一般是17（1+16），1:public, 16:final</span></span><br><span class="line"><span class="keyword">private</span> ProxyGenerator.ConstantPool cp = <span class="keyword">new</span> ProxyGenerator.ConstantPool();<span class="comment">//代理类常量池，一些符号引用等</span></span><br><span class="line"><span class="keyword">private</span> List&lt;ProxyGenerator.FieldInfo&gt; fields = <span class="keyword">new</span> ArrayList();<span class="comment">//生成的代理类的成员变量</span></span><br><span class="line"><span class="keyword">private</span> List&lt;ProxyGenerator.MethodInfo&gt; methods = <span class="keyword">new</span> ArrayList();<span class="comment">//生成的代理类的方法列表（这是新生成的方法）</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, List&lt;ProxyGenerator.ProxyMethod&gt;&gt; proxyMethods = <span class="keyword">new</span> HashMap();<span class="comment">//被代理的方法，方法签名与方法之间的映射（这是目标方法，最终用成员变量表示）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> proxyMethodCount = <span class="number">0</span>;<span class="comment">//代理方法数量（一般是3+业务方法数）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//核心方法：generateProxyClass，注意这个方法是public static 的，我们在其他地方也可以直接使用 </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] generateProxyClass(<span class="keyword">final</span> String className, Class&lt;?&gt;[] interfaces, <span class="keyword">int</span> accessFlags) &#123;</span><br><span class="line">  ProxyGenerator generator = <span class="keyword">new</span> ProxyGenerator(className, interfaces, accessFlags); </span><br><span class="line">  <span class="comment">//生成代理类class文件【核心】</span></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">byte</span>[] classFile = generator.generateClassFile();</span><br><span class="line">  <span class="keyword">if</span> (saveGeneratedFiles) &#123;</span><br><span class="line">   <span class="comment">//保存文件</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> classFile;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//核心方法：generateClassFile</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">byte</span>[] generateClassFile() &#123;</span><br><span class="line">  <span class="comment">//生成proxy代理类的hashcode，equals，toString方法</span></span><br><span class="line">  addProxyMethod(hashCodeMethod, Object.class);</span><br><span class="line">  addProxyMethod(equalsMethod, Object.class);</span><br><span class="line">  addProxyMethod(toStringMethod, Object.class);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//添加各个接口的方法</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; interfaces.length; i++) &#123;</span><br><span class="line">    Method[] methods = interfaces[i].getMethods();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; methods.length; j++) &#123;</span><br><span class="line">      addProxyMethod(methods[j], interfaces[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//检查返回类型</span></span><br><span class="line">  <span class="keyword">for</span> (List&lt;ProxyMethod&gt; sigmethods : proxyMethods.values()) &#123;</span><br><span class="line">    checkReturnTypes(sigmethods);</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//添加生成的构造方法</span></span><br><span class="line">  methods.add(generateConstructor());</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">for</span> (List&lt;ProxyMethod&gt; sigmethods : proxyMethods.values()) &#123;</span><br><span class="line">    <span class="keyword">for</span> (ProxyMethod pm : sigmethods) &#123;</span><br><span class="line">      <span class="comment">//将目标方法放到成员变量中</span></span><br><span class="line">      fields.add(<span class="keyword">new</span> FieldInfo(pm.methodFieldName, <span class="string">"Ljava/lang/reflect/Method;"</span>, ACC_PRIVATE | ACC_STATIC));</span><br><span class="line">      <span class="comment">//新增一个与之对应的方法（签名一致），然后在该方法中调用目标方法</span></span><br><span class="line">      methods.add(pm.generateMethod());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//添加静态初始化块，就是生成代理类中的静态块</span></span><br><span class="line">  methods.add(generateStaticInitializer());</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//构造常量池（cp=constant pool）</span></span><br><span class="line">  cp.getClass(dotToSlash(className));<span class="comment">//dotToSlash点转换为斜线</span></span><br><span class="line">  cp.getClass(superclassName);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; interfaces.length; i++) &#123;</span><br><span class="line">    cp.getClass(dotToSlash(interfaces[i].getName()));</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//常量池设置为只读模式</span></span><br><span class="line">  cp.setReadOnly();</span><br><span class="line">    </span><br><span class="line">  ByteArrayOutputStream bout = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">  DataOutputStream dout = <span class="keyword">new</span> DataOutputStream(bout);</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//以下是class文件的结构，想深入了解的话可以看深入Java虚拟机</span></span><br><span class="line">  <span class="comment">// u4 magic number;</span></span><br><span class="line">  dout.writeInt(<span class="number">0xCAFEBABE</span>);</span><br><span class="line">  <span class="comment">// u2 minor_version;</span></span><br><span class="line">  dout.writeShort(CLASSFILE_MINOR_VERSION);</span><br><span class="line">  <span class="comment">// u2 major_version;</span></span><br><span class="line">  dout.writeShort(CLASSFILE_MAJOR_VERSION);</span><br><span class="line"><span class="comment">// write constant pool</span></span><br><span class="line">  cp.write(dout); </span><br><span class="line">  <span class="comment">// u2 access_flags;</span></span><br><span class="line">  dout.writeShort(ACC_PUBLIC | ACC_FINAL | ACC_SUPER);</span><br><span class="line">  <span class="comment">// u2 this_class;</span></span><br><span class="line">  dout.writeShort(cp.getClass(dotToSlash(className)));</span><br><span class="line">  <span class="comment">// u2 super_class;</span></span><br><span class="line">  dout.writeShort(cp.getClass(superclassName));</span><br><span class="line">  <span class="comment">// u2 interfaces_count;</span></span><br><span class="line">  dout.writeShort(interfaces.length);</span><br><span class="line">  <span class="comment">// u2 interfaces[interfaces_count];</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; interfaces.length; i++) &#123;</span><br><span class="line">    dout.writeShort(cp.getClass(dotToSlash(interfaces[i].getName())));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// u2 fields_count;</span></span><br><span class="line">  dout.writeShort(fields.size());</span><br><span class="line">  <span class="comment">// field_info fields[fields_count];</span></span><br><span class="line">  <span class="keyword">for</span> (FieldInfo f : fields) &#123;</span><br><span class="line">    f.write(dout);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// u2 methods_count;</span></span><br><span class="line">  dout.writeShort(methods.size());</span><br><span class="line">  <span class="comment">// method_info methods[methods_count];</span></span><br><span class="line">  <span class="keyword">for</span> (MethodInfo m : methods) &#123;</span><br><span class="line">    m.write(dout);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// u2 attributes_count;</span></span><br><span class="line">  dout.writeShort(<span class="number">0</span>); <span class="comment">// (no ClassFile attributes for proxy classes)</span></span><br><span class="line">  <span class="keyword">return</span> bout.toByteArray();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></p></li></ol><p></p><p>   <code>`</code></p>]]></content>
    
    <summary type="html">
    
      Proxy is a structural design pattern that provides an object that acts as a substitute for a real service object used by a client. A proxy receives client requests, does some work (access control, caching, etc.) and then passes the request to a service object.
    
    </summary>
    
      <category term="Java" scheme="http://blog.zjee.ml/categories/Java/"/>
    
    
      <category term="Java" scheme="http://blog.zjee.ml/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java日志体系</title>
    <link href="http://blog.zjee.ml/2020/01/05/java-log-system/"/>
    <id>http://blog.zjee.ml/2020/01/05/java-log-system/</id>
    <published>2020-01-05T03:38:44.000Z</published>
    <updated>2020-01-05T03:38:44.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、相关概念、"><a href="#一、相关概念、" class="headerlink" title="一、相关概念、"></a>一、相关概念、</h1><h3 id="1-1、-日志门面"><a href="#1-1、-日志门面" class="headerlink" title="1.1、 日志门面"></a>1.1、 日志门面</h3><p><strong>日志门面</strong>是一个对外的、统一的日志”接口“，它不是具体的日志实现，它需要和log4j、logback这样的实现框架配合使用。现在最流行的日志门面是slf4j，按照官方的说法，slf4j是一个用于日志系统的简单Facade，允许最终用户在部署其应用时使用其所希望的日志系统。</p><p><strong>问：</strong>为什么要使用日志门面？直接调用log4j等实现框架的API不行吗？</p><p><strong>答：</strong>直接调用实现框架的API当然可以，但如果未来某一天有比log4j性能更好的实现框架，那升级替换可就是个大工程了。另外，如果现有工程依赖了两个模块，两个模块分别用不同的日志实现方案，那现有工程就需要维护两套日志配置。但有了<strong>日志门面</strong>后一切都变了，我们仅需要引入一种实现，也只需要维护这一种实现的配置文件，其他的实现全部<strong>桥接</strong>到门面即可，往后如果需要升级日志实现，也只需要升级一个jar包、一个配置文件即可。</p><h3 id="1-2、桥接器"><a href="#1-2、桥接器" class="headerlink" title="1.2、桥接器"></a>1.2、桥接器</h3><p>我们在开发中当然可以只使用一种日志实现方案，但引用的第三方依赖可就不一定了，为了统一日志配置，我们需要将第三方依赖的日志实现”引流”到我们自己的日志框架上，这个”引流“的功能就叫做桥接器。</p><h3 id="1-3、日志实现"><a href="#1-3、日志实现" class="headerlink" title="1.3、日志实现"></a>1.3、日志实现</h3><p>日志实现就是真正打日志干活的部分，Java中日志实现太多了，常见的有log4j、log4j2、jcl、logback等。</p><h1 id="二、各种Jar包及功能一览"><a href="#二、各种Jar包及功能一览" class="headerlink" title="二、各种Jar包及功能一览"></a>二、各种Jar包及功能一览</h1><table><thead><tr><th style="text-align:left"><strong>jar包</strong></th><th style="text-align:center"><strong>类型</strong></th><th style="text-align:center"><strong>转换方向</strong></th><th style="text-align:left"><strong>描述</strong></th><th><strong>注意事项</strong></th></tr></thead><tbody><tr><td style="text-align:left">jcl-over-slf4j</td><td style="text-align:center">桥接包</td><td style="text-align:center">jcl -&gt; slf4j</td><td style="text-align:left">将Jakarta Commons Logging日志框架桥接到slf4j</td><td></td></tr><tr><td style="text-align:left">jul-to-slf4j</td><td style="text-align:center">桥接包</td><td style="text-align:center">juc -&gt; slf4j</td><td style="text-align:left">将java.util.logging的日志桥接到slf4j</td><td></td></tr><tr><td style="text-align:left">osgi-over-slf4j</td><td style="text-align:center">桥接包</td><td style="text-align:center">osgi -&gt; slf4j</td><td style="text-align:left">将osgi环境下的日志桥接到slf4j</td><td></td></tr><tr><td style="text-align:left">slf4j-android</td><td style="text-align:center">桥接包</td><td style="text-align:center">android -&gt; slf4j</td><td style="text-align:left">将android环境下的日志桥接到slf4j</td><td></td></tr><tr><td style="text-align:left">log4j-over-slf4j</td><td style="text-align:center">桥接包</td><td style="text-align:center">log4j -&gt; slf4j</td><td style="text-align:left">将log4j的日志桥接到slf4j</td><td>不能和slf4j-log4j12同时用</td></tr><tr><td style="text-align:left">log4j-to-slf4j</td><td style="text-align:center">桥接包</td><td style="text-align:center">log4j2 -&gt; slf4j</td><td style="text-align:left">将log4j2的日志桥接到slf4j</td><td>不能和log4j-slf4j-impl同时用</td></tr><tr><td style="text-align:left">slf4j-api</td><td style="text-align:center">slf4j门面</td><td style="text-align:center"></td><td style="text-align:left">slf4j的api接口jar包</td><td></td></tr><tr><td style="text-align:left">slf4j-ext</td><td style="text-align:center">slf4j门面</td><td style="text-align:center"></td><td style="text-align:left">slf4j扩展功能jar包</td><td></td></tr><tr><td style="text-align:left">log4j-api</td><td style="text-align:center">实现包</td><td style="text-align:center"></td><td style="text-align:left">log4j2的api接口jar包</td><td></td></tr><tr><td style="text-align:left">log4j-core</td><td style="text-align:center">实现包</td><td style="text-align:center"></td><td style="text-align:left">log4j2的日志输出核心jar包</td><td></td></tr><tr><td style="text-align:left">log4j</td><td style="text-align:center">实现包</td><td style="text-align:center"></td><td style="text-align:left">log4j实现包（1.2）</td><td></td></tr><tr><td style="text-align:left">slf4j-migrator</td><td style="text-align:center">实现包</td><td style="text-align:center"></td><td style="text-align:left">一个GUI工具，支持将代码中其他日志API转换为slf4j的写法</td><td></td></tr><tr><td style="text-align:left">slf4j-jcl</td><td style="text-align:center">slf4j+jcl打包</td><td style="text-align:center">slf4j -&gt; jcl</td><td style="text-align:left">slf4j采用Jakarta Commons Logging日志框架实现</td><td></td></tr><tr><td style="text-align:left">slf4j-jdk14</td><td style="text-align:center">slf4j+jul打包</td><td style="text-align:center">slf4j -&gt; jul</td><td style="text-align:left">slf4j采用java.util.logging实现</td><td>不能和jul-to-slf4j同时用</td></tr><tr><td style="text-align:left">slf4j-log4j12</td><td style="text-align:center">slf4j+log4j12打包</td><td style="text-align:center">slf4j -&gt; log4j</td><td style="text-align:left">slf4j采用log4j实现（12表示1.2版本）</td><td>不能和log4j-over-slf4j同时用</td></tr><tr><td style="text-align:left">log4j-slf4j-impl</td><td style="text-align:center">slf4j+log4j2打包</td><td style="text-align:center">slf4j -&gt; log4j2</td><td style="text-align:left">slf4j采用log4j2实现</td><td>不能和log4j-to-slf4j同时用</td></tr><tr><td style="text-align:left">slf4j-nop</td><td style="text-align:center">slf4j+无输出打包</td><td style="text-align:center">slf4j -&gt; null</td><td style="text-align:left">slf4j的空接口输出绑定，丢弃所有日志输出</td><td></td></tr><tr><td style="text-align:left">slf4j-simple</td><td style="text-align:center">sl4j+简单实现打包</td><td style="text-align:center">slf4j -&gt; slf4j-simple</td><td style="text-align:left">slf4j的自带的简单日志输出实现</td><td></td></tr><tr><td style="text-align:left">logback-classic</td><td style="text-align:center">slf4j+logback打包</td><td style="text-align:center">slf4j -&gt; logback</td><td style="text-align:left">slf4j采用logback实现</td><td></td></tr><tr><td style="text-align:left">logback-core</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:left">logback核心依赖</td><td></td></tr><tr><td style="text-align:left">logback-access</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:left">与servlet容器集成，提供通过http访问日志功能</td><td></td></tr><tr><td style="text-align:left">log4j-1.2-api</td><td style="text-align:center">log4j桥接到log4j2</td><td style="text-align:center">log4j -&gt; log4j2</td><td style="text-align:left">将log4j的日志转接到log4j2日志框架</td></tr></tbody></table><h1 id="三、常见使用搭配"><a href="#三、常见使用搭配" class="headerlink" title="三、常见使用搭配"></a>三、常见使用搭配</h1><ol><li><strong>slf4j + log4j（已过时）</strong>：引入<code>slf4j-log4j12</code>即可，另外可根据需求加入桥接包，不可与<code>log4j-over-slf4j</code>同时使用，会引发<code>StackOverflowError</code>异常。</li><li><strong>slf4j + log4j2（流行）</strong>：引入<code>log4j-slf4j-impl</code>即可，另外可根据需求加入桥接包，不可与<code>log4j-to-slf4j</code>同时使用，会引发<code>StackOverflowError</code>异常。</li><li><strong>slf4j + logback（最优）</strong>：引入 <code>logback-classic</code>即可，另外可根据需求加入桥接包。logback与slf4j是同一人开发，兼容性很好，springboot默认就采用logback方案。</li></ol><p>其他的使用方式有log4j、log4j2、jul等单独使用的，这里强烈不推荐，请按<a href="https://yq.aliyun.com/articles/69327?utm_content=m_10088" target="_blank" rel="noopener">阿里巴巴Java代码规范</a>中【日志规约】编码。</p><h1 id="四、常见问题"><a href="#四、常见问题" class="headerlink" title="四、常见问题"></a>四、常见问题</h1><ol><li><p><strong>找到多个slf4j实现(Class path contains multiple SLF4J bindings.)</strong></p><img src="/2020/01/05/java-log-system/mult-bindings.png" title="mult-bindings"><p>这种情况是上面的<code>slf4j+xxx打包</code>这样的jar包引入了两类导致的，我们根据需要保留一类，排除其他的就可以了。</p></li><li><p><strong>jar包不能共存，或者直接报<code>StackOverflowError</code>异常</strong></p><img src="/2020/01/05/java-log-system/stackOverflow.png" title="stackOverflowError"><p>这种情况大多数原因是实现包与实现包对应的桥接包同时引入了，打印日志的时候就会发生死循环方法调用，一直到栈溢出，实现比较好的包如<code>log4j-slf4j-impl</code>，会在启动时告诉你两者不能共存。总的来说，<strong>实现和桥接只能选一个</strong>。</p></li><li><p><strong>其他异常情况大多数是由版本不兼容导致的，请参考<a href="http://www.slf4j.org/codes.html" target="_blank" rel="noopener">slf4j错误含义及解决方法</a>。</strong></p></li><li><p><strong>log4j(也称log4j12)与log4j2的区别：<a href="https://www.cnblogs.com/WangBoBlog/p/7841217.html" target="_blank" rel="noopener">Log4j与Log4j2的区别</a>。</strong></p></li></ol><h1 id="五、常见日志配置"><a href="#五、常见日志配置" class="headerlink" title="五、常见日志配置"></a>五、常见日志配置</h1><h3 id="5-1-log4j配置"><a href="#5-1-log4j配置" class="headerlink" title="5.1 log4j配置"></a>5.1 log4j配置</h3><ol><li><p>基于XML的配置</p><details><summary style="color:blue">点击展开代码</summary><br>    <a href="https://blog.csdn.net/manmanxiaohui/article/details/79922546" target="_blank">参考文档</a><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>  </span><br><span class="line"><span class="meta">&lt;!DOCTYPE log4j:configuration SYSTEM "log4j.dtd"&gt;</span>  </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">log4j:configuration</span>  <span class="attr">debug</span>=<span class="string">"true"</span> <span class="attr">xmlns:log4j</span>=<span class="string">'http://jakarta.apache.org/log4j/'</span> &gt;</span>  </span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- ========================== 自定义输出格式说明======================== --&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- %p 输出优先级，即DEBUG，INFO，WARN，ERROR，FATAL --&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- %r 输出自应用启动到输出该log信息耗费的毫秒数  --&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- %c 输出所属的类目，通常就是所在类的全名 --&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- %t 输出产生该日志事件的线程名 --&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- %n 输出一个回车换行符，Windows平台为“/r/n”，Unix平台为“/n” --&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- %d 输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，比如：%d&#123;yyy MMM dd HH:mm:ss,SSS&#125;，输出类似：2002年10月18日 22：10：28，921  --&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- %l 输出日志事件的发生位置，包括类目名、发生的线程，以及在代码中的行数。举例：Testlo4.main(TestLog4.java:10)  --&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- ============================================================== --&gt;</span></span><br><span class="line">     </span><br><span class="line">      <span class="comment">&lt;!-- ========================== 输出方式说明========================= --&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- Log4j提供的appender有以下几种:  --&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- org.apache.log4j.ConsoleAppender(控制台),  --&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- org.apache.log4j.FileAppender(文件),  --&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- org.apache.log4j.DailyRollingFileAppender(每天产生一个日志文件), --&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- org.apache.log4j.RollingFileAppender(文件大小到达指定尺寸的时候产生一个新的文件),  --&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- org.apache.log4j.WriterAppender(将日志信息以流格式发送到任意指定的地方)   --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- ================================================================== --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"CONSOLE"</span> <span class="attr">class</span>=<span class="string">"org.apache.log4j.ConsoleAppender"</span>&gt;</span></span><br><span class="line">         <span class="comment">&lt;!-- &lt;param name="Target" value="System.out"/&gt; --&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">layout</span> <span class="attr">class</span>=<span class="string">"org.apache.log4j.PatternLayout"</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"ConversionPattern"</span> <span class="attr">value</span>=<span class="string">"%d&#123;yyyy-MM-dd HH:mm:ss a&#125; [Thread: %t][ Class:%c  Method: %l ]%n%p:%m%n"</span>/&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--  &lt;filter class="org.apache.log4j.varia.LevelRangeFilter"&gt;</span></span><br><span class="line"><span class="comment">            &lt;param name="LevelMin" value="DEBUG"/&gt;</span></span><br><span class="line"><span class="comment">            &lt;param name="LevelMax" value="DEBUG"/&gt;</span></span><br><span class="line"><span class="comment">        &lt;/filter&gt; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- output the debug   --&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--  &lt;appender name="log4jDebug" class="org.apache.log4j.DailyRollingFileAppender"&gt;</span></span><br><span class="line"><span class="comment">        &lt;param name="File" value="log_"/&gt;    </span></span><br><span class="line"><span class="comment">        &lt;param name="MaxFileSize" value="KB"/&gt; </span></span><br><span class="line"><span class="comment">        &lt;param name="MaxBackupIndex" value="2"/&gt; --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"log4jDebug"</span>  <span class="attr">class</span>=<span class="string">"org.apache.log4j.rolling.RollingFileAppender"</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"Append"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span>  <span class="attr">class</span>=<span class="string">"org.apache.log4j.rolling.TimeBasedRollingPolicy"</span>&gt;</span>  </span><br><span class="line">               <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"FileNamePattern"</span> <span class="attr">value</span>=<span class="string">"./log/log_%d&#123;yyyy-MM-dd&#125;.log"</span> /&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">layout</span> <span class="attr">class</span>=<span class="string">"org.apache.log4j.PatternLayout"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"ConversionPattern"</span> <span class="attr">value</span>=<span class="string">"%d&#123;yyyy-MM-dd HH:mm:ss a&#125; [Thread: %t][ Class:%c Method: %l ]%n%p:%m%n"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"org.apache.log4j.varia.LevelRangeFilter"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"LevelMin"</span> <span class="attr">value</span>=<span class="string">"DEBUG"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"LevelMax"</span> <span class="attr">value</span>=<span class="string">"DEBUG"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--  &lt;appender name="log4jInfo" class="org.apache.log4j.DailyRollingFileAppender"&gt;</span></span><br><span class="line"><span class="comment">        &lt;param name="File" value="log_"/&gt;       </span></span><br><span class="line"><span class="comment">        &lt;param name="DatePattern" value="'.log'yyyy-MM-dd"/&gt;</span></span><br><span class="line"><span class="comment">        &lt;param name="Append" value="true"/&gt;</span></span><br><span class="line"><span class="comment">       &lt;param name="MaxFileSize" value="5KB"/&gt;</span></span><br><span class="line"><span class="comment">        &lt;param name="MaxBackupIndex" value="2"/&gt; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"log4jInfo"</span>  <span class="attr">class</span>=<span class="string">"org.apache.log4j.rolling.RollingFileAppender"</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"Append"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span>  <span class="attr">class</span>=<span class="string">"org.apache.log4j.rolling.TimeBasedRollingPolicy"</span>&gt;</span>  </span><br><span class="line">               <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"FileNamePattern"</span> <span class="attr">value</span>=<span class="string">"./log/log_%d&#123;yyyy-MM-dd&#125;.log"</span> /&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">layout</span> <span class="attr">class</span>=<span class="string">"org.apache.log4j.PatternLayout"</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"ConversionPattern"</span> <span class="attr">value</span>=<span class="string">"%d&#123;yyyy-MM-dd HH:mm:ss a&#125; [Thread: %t][ Class:%c  Method: %l ]%n%p:%m%n"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"org.apache.log4j.varia.LevelRangeFilter"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"LevelMin"</span> <span class="attr">value</span>=<span class="string">"INFO"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"LevelMax"</span> <span class="attr">value</span>=<span class="string">"INFO"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--  &lt;appender name="log4jWarn" class="org.apache.log4j.DailyRollingFileAppender"&gt;</span></span><br><span class="line"><span class="comment">        &lt;param name="File" value="/log_"/&gt;      </span></span><br><span class="line"><span class="comment">        &lt;param name="DatePattern" value="'.log'yyyy-MM-dd"/&gt;</span></span><br><span class="line"><span class="comment">        &lt;param name="Append" value="true"/&gt;</span></span><br><span class="line"><span class="comment">        &lt;param name="MaxFileSize" value="5KB"/&gt;</span></span><br><span class="line"><span class="comment">        &lt;param name="MaxBackupIndex" value="2"/&gt; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"log4jWarn"</span> <span class="attr">class</span>=<span class="string">"org.apache.log4j.rolling.RollingFileAppender"</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"Append"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span>  <span class="attr">class</span>=<span class="string">"org.apache.log4j.rolling.TimeBasedRollingPolicy"</span>&gt;</span>  </span><br><span class="line">               <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"FileNamePattern"</span> <span class="attr">value</span>=<span class="string">"./log/log_%d&#123;yyyy-MM-dd&#125;.log"</span> /&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">layout</span> <span class="attr">class</span>=<span class="string">"org.apache.log4j.PatternLayout"</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"ConversionPattern"</span> <span class="attr">value</span>=<span class="string">"%d&#123;yyyy-MM-dd HH:mm:ss a&#125; [Thread: %t][ Class:%c Method: %l ]%n%p:%m%n"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"org.apache.log4j.varia.LevelRangeFilter"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"LevelMin"</span> <span class="attr">value</span>=<span class="string">"WARN"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"LevelMax"</span> <span class="attr">value</span>=<span class="string">"WARN"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--  &lt;appender name="log4jError" class="org.apache.log4j.DailyRollingFileAppender"&gt; --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"log4jError"</span>  <span class="attr">class</span>=<span class="string">"org.apache.log4j.rolling.RollingFileAppender"</span>&gt;</span>  </span><br><span class="line">       <span class="comment">&lt;!--  &lt;param name="File" value="/error_"/&gt;    </span></span><br><span class="line"><span class="comment">        &lt;param name="DatePattern" value="'.log'yyyy-MM-dd"/&gt; --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"Append"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span>  <span class="attr">class</span>=<span class="string">"org.apache.log4j.rolling.TimeBasedRollingPolicy"</span>&gt;</span>  </span><br><span class="line">               <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"FileNamePattern"</span> <span class="attr">value</span>=<span class="string">"./log/error_%d&#123;yyyy-MM-dd&#125;.log"</span> /&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span> </span><br><span class="line">        </span><br><span class="line">      <span class="comment">&lt;!--   &lt;param name="MaxFileSize" value="5KB"/&gt; --&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--   &lt;param name="MaxBackupIndex" value="2"/&gt; --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">layout</span> <span class="attr">class</span>=<span class="string">"org.apache.log4j.PatternLayout"</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"ConversionPattern"</span> <span class="attr">value</span>=<span class="string">"%d&#123;yyyy-MM-dd HH:mm:ss a&#125; [Thread: %t][ Class:%c Method: %l ]%n%p:%m%n"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"org.apache.log4j.varia.LevelRangeFilter"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"LevelMin"</span> <span class="attr">value</span>=<span class="string">"ERROR"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"LevelMax"</span> <span class="attr">value</span>=<span class="string">"ERROR"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--通过&lt;category&gt;&lt;/category&gt;的定义可以将各个包中的类日志输出到不同的日志文件中--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--     &lt;category name="com.gzy"&gt;</span></span><br><span class="line"><span class="comment">            &lt;priority value="debug" /&gt;</span></span><br><span class="line"><span class="comment">            &lt;appender-ref ref="log4jTestLogInfo" /&gt;</span></span><br><span class="line"><span class="comment">            &lt;appender-ref ref="log4jTestDebug" /&gt;</span></span><br><span class="line"><span class="comment">        &lt;/category&gt; --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"MAIL"</span>     </span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">"org.apache.log4j.net.SMTPAppender"</span>&gt;</span>     </span><br><span class="line">      <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"threshold"</span> <span class="attr">value</span>=<span class="string">"debug"</span> /&gt;</span>     </span><br><span class="line">      <span class="comment">&lt;!-- 日志的错误级别     </span></span><br><span class="line"><span class="comment">       &lt;param name="threshold" value="error"/&gt;     </span></span><br><span class="line"><span class="comment">      --&gt;</span>     </span><br><span class="line">      <span class="comment">&lt;!-- 缓存文件大小，日志达到512K时发送Email --&gt;</span>     </span><br><span class="line">      <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"BufferSize"</span> <span class="attr">value</span>=<span class="string">"512"</span> /&gt;</span><span class="comment">&lt;!-- 单位K --&gt;</span>     </span><br><span class="line">      <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"From"</span> <span class="attr">value</span>=<span class="string">"test@163.com"</span> /&gt;</span>     </span><br><span class="line">      <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"SMTPHost"</span> <span class="attr">value</span>=<span class="string">"smtp.163.com"</span> /&gt;</span>     </span><br><span class="line">      <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"Subject"</span> <span class="attr">value</span>=<span class="string">"juyee-log4jMessage"</span> /&gt;</span>     </span><br><span class="line">      <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"To"</span> <span class="attr">value</span>=<span class="string">"test@163.com"</span> /&gt;</span>     </span><br><span class="line">      <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"SMTPUsername"</span> <span class="attr">value</span>=<span class="string">"test"</span> /&gt;</span>     </span><br><span class="line">      <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"SMTPPassword"</span> <span class="attr">value</span>=<span class="string">"test"</span> /&gt;</span>     </span><br><span class="line">      <span class="tag">&lt;<span class="name">layout</span> <span class="attr">class</span>=<span class="string">"org.apache.log4j.PatternLayout"</span>&gt;</span>     </span><br><span class="line">       <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"ConversionPattern"</span>     </span></span><br><span class="line"><span class="tag">        <span class="attr">value</span>=<span class="string">"%-d&#123;yyyy-MM-dd HH:mm:ss.SSS a&#125; [%p]-[%c] %m%n"</span> /&gt;</span>     </span><br><span class="line">      <span class="tag">&lt;/<span class="name">layout</span>&gt;</span>     </span><br><span class="line">   <span class="tag">&lt;/<span class="name">appender</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">     <span class="tag">&lt;<span class="name">root</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">priority</span> <span class="attr">value</span>=<span class="string">"debug"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"CONSOLE"</span> /&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"log4jDebug"</span> /&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"log4jInfo"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"log4jWarn"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"log4jError"</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;appender-ref ref="MAIL" /&gt; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">log4j:configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><br><br></details></li><li><p>基于properties文件的配置<br><details><summary style="color:blue">点击展开代码</summary><br><a href="https://blog.csdn.net/manmanxiaohui/article/details/79922546" target="_blank">参考文档</a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"># priority  :debug&lt;info&lt;warn&lt;error</span><br><span class="line">#you cannot specify every priority with different file for log4j </span><br><span class="line">log4j.rootLogger=debug,stdout,info,debug,warn,error </span><br><span class="line"></span><br><span class="line">#console</span><br><span class="line">log4j.appender.stdout=org.apache.log4j.ConsoleAppender </span><br><span class="line">log4j.appender.stdout.layout=org.apache.log4j.PatternLayout </span><br><span class="line">log4j.appender.stdout.layout.ConversionPattern= [%d&#123;yyyy-MM-dd HH:mm:ss a&#125;]:%p %l%m%n</span><br><span class="line">#info log</span><br><span class="line">log4j.logger.info=info</span><br><span class="line">log4j.appender.info=org.apache.log4j.DailyRollingFileAppender </span><br><span class="line">log4j.appender.info.DatePattern=&apos;_&apos;yyyy-MM-dd&apos;.log&apos;</span><br><span class="line">log4j.appender.info.File=./src/com/hp/log/info.log</span><br><span class="line">log4j.appender.info.Append=true</span><br><span class="line">log4j.appender.info.Threshold=INFO</span><br><span class="line">log4j.appender.info.layout=org.apache.log4j.PatternLayout </span><br><span class="line">log4j.appender.info.layout.ConversionPattern=%d&#123;yyyy-MM-dd HH:mm:ss a&#125; [Thread: %t][ Class:%c &gt;&gt; Method: %l ]%n%p:%m%n</span><br><span class="line">#debug log</span><br><span class="line">log4j.logger.debug=debug</span><br><span class="line">log4j.appender.debug=org.apache.log4j.DailyRollingFileAppender </span><br><span class="line">log4j.appender.debug.DatePattern=&apos;_&apos;yyyy-MM-dd&apos;.log&apos;</span><br><span class="line">log4j.appender.debug.File=./src/com/hp/log/debug.log</span><br><span class="line">log4j.appender.debug.Append=true</span><br><span class="line">log4j.appender.debug.Threshold=DEBUG</span><br><span class="line">log4j.appender.debug.layout=org.apache.log4j.PatternLayout </span><br><span class="line">log4j.appender.debug.layout.ConversionPattern=%d&#123;yyyy-MM-dd HH:mm:ss a&#125; [Thread: %t][ Class:%c &gt;&gt; Method: %l ]%n%p:%m%n</span><br><span class="line">#warn log</span><br><span class="line">log4j.logger.warn=warn</span><br><span class="line">log4j.appender.warn=org.apache.log4j.DailyRollingFileAppender </span><br><span class="line">log4j.appender.warn.DatePattern=&apos;_&apos;yyyy-MM-dd&apos;.log&apos;</span><br><span class="line">log4j.appender.warn.File=./src/com/hp/log/warn.log</span><br><span class="line">log4j.appender.warn.Append=true</span><br><span class="line">log4j.appender.warn.Threshold=WARN</span><br><span class="line">log4j.appender.warn.layout=org.apache.log4j.PatternLayout </span><br><span class="line">log4j.appender.warn.layout.ConversionPattern=%d&#123;yyyy-MM-dd HH:mm:ss a&#125; [Thread: %t][ Class:%c &gt;&gt; Method: %l ]%n%p:%m%n</span><br><span class="line">#error</span><br><span class="line">log4j.logger.error=error</span><br><span class="line">log4j.appender.error = org.apache.log4j.DailyRollingFileAppender</span><br><span class="line">log4j.appender.error.DatePattern=&apos;_&apos;yyyy-MM-dd&apos;.log&apos;</span><br><span class="line">log4j.appender.error.File = ./src/com/hp/log/error.log </span><br><span class="line">log4j.appender.error.Append = true</span><br><span class="line">log4j.appender.error.Threshold = ERROR </span><br><span class="line">log4j.appender.error.layout = org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.error.layout.ConversionPattern = %d&#123;yyyy-MM-dd HH:mm:ss a&#125; [Thread: %t][ Class:%c &gt;&gt; Method: %l ]%n%p:%m%n</span><br></pre></td></tr></table></figure></details></p></li></ol><p></p><h3 id="5-2-log4j2配置"><a href="#5-2-log4j2配置" class="headerlink" title="5.2 log4j2配置"></a>5.2 log4j2配置</h3><details><summary style="color:blue">点击展开代码</summary><br><a href="https://www.cnblogs.com/WangBoBlog/p/7841217.html" target="_blank">参考文档</a><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span> <span class="attr">status</span>=<span class="string">"error"</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!--  先定义所有的appender --&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">appenders</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!--   这个输出控制台的配置 --&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">Console</span> <span class="attr">name</span>=<span class="string">"Console"</span> <span class="attr">target</span>=<span class="string">"SYSTEM_OUT"</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!--    控制台只输出level及以上级别的信息（onMatch），其他的直接拒绝（onMismatch） --&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">ThresholdFilter</span> <span class="attr">level</span>=<span class="string">"trace"</span> <span class="attr">onMatch</span>=<span class="string">"ACCEPT"</span> <span class="attr">onMismatch</span>=<span class="string">"DENY"</span>/&gt;</span> </span><br><span class="line"><span class="comment">&lt;!--    这个都知道是输出日志的格式 --&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">"%d&#123;HH:mm:ss.SSS&#125; %-5level %class&#123;36&#125; %L %M - %msg%xEx%n"</span>/&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">Console</span>&gt;</span> </span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!--   文件会打印出所有信息，这个log每次运行程序会自动清空，由append属性决定，这个也挺有用的，适合临时测试用 --&gt;</span> </span><br><span class="line"><span class="comment">&lt;!--   append为TRUE表示消息增加到指定文件中，false表示消息覆盖指定的文件内容，默认值是true --&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">File</span> <span class="attr">name</span>=<span class="string">"log"</span> <span class="attr">fileName</span>=<span class="string">"log/test.log"</span> <span class="attr">append</span>=<span class="string">"false"</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">"%d&#123;HH:mm:ss.SSS&#125; %-5level %class&#123;36&#125; %L %M - %msg%xEx%n"</span>/&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">File</span>&gt;</span> </span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!--   添加过滤器ThresholdFilter,可以有选择的输出某个级别以上的类别 onMatch="ACCEPT" onMismatch="DENY"意思是匹配就接受,否则直接拒绝 --&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">File</span> <span class="attr">name</span>=<span class="string">"ERROR"</span> <span class="attr">fileName</span>=<span class="string">"logs/error.log"</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">ThresholdFilter</span> <span class="attr">level</span>=<span class="string">"error"</span> <span class="attr">onMatch</span>=<span class="string">"ACCEPT"</span> <span class="attr">onMismatch</span>=<span class="string">"DENY"</span>/&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">"%d&#123;yyyy.MM.dd 'at' HH:mm:ss z&#125; %-5level %class&#123;36&#125; %L %M - %msg%xEx%n"</span>/&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">File</span>&gt;</span> </span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!--   这个会打印出所有的信息，每次大小超过size，则这size大小的日志会自动存入按年份-月份建立的文件夹下面并进行压缩，作为存档 --&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">RollingFile</span> <span class="attr">name</span>=<span class="string">"RollingFile"</span> <span class="attr">fileName</span>=<span class="string">"logs/web.log"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">filePattern</span>=<span class="string">"logs/$$&#123;date:yyyy-MM&#125;/web-%d&#123;MM-dd-yyyy&#125;-%i.log.gz"</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">"%d&#123;yyyy-MM-dd 'at' HH:mm:ss z&#125; %-5level %class&#123;36&#125; %L %M - %msg%xEx%n"</span>/&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">SizeBasedTriggeringPolicy</span> <span class="attr">size</span>=<span class="string">"2MB"</span>/&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">RollingFile</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;/<span class="name">appenders</span>&gt;</span> </span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!--  然后定义logger，只有定义了logger并引入的appender，appender才会生效 --&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">loggers</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!--   建立一个默认的root的logger --&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"trace"</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"RollingFile"</span>/&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"Console"</span>/&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"ERROR"</span> /&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"log"</span>/&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">root</span>&gt;</span> </span><br><span class="line"> </span><br><span class="line"> <span class="tag">&lt;/<span class="name">loggers</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><br><br></details><h3 id="5-3-logback配置"><a href="#5-3-logback配置" class="headerlink" title="5.3 logback配置"></a>5.3 logback配置</h3><details><summary style="color:blue">点击展开代码</summary><br><a href="https://www.jianshu.com/p/04065d8cb2a9" target="_blank">参考文档</a><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span> <span class="attr">debug</span>=<span class="string">"true"</span> <span class="attr">scan</span>=<span class="string">"true"</span> <span class="attr">scanPeriod</span>=<span class="string">"1 seconds"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">contextName</span>&gt;</span>logback<span class="tag">&lt;/<span class="name">contextName</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--定义参数,后面可以通过$&#123;app.name&#125;使用--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"app.name"</span> <span class="attr">value</span>=<span class="string">"logback_test"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--ConsoleAppender 用于在屏幕上输出日志--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"stdout"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--定义了一个过滤器,在LEVEL之下的日志输出不会被打印出来--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--这里定义了DEBUG，也就是控制台不会输出比ERROR级别小的日志--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.filter.ThresholdFilter"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">level</span>&gt;</span>DEBUG<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- encoder 默认配置为PatternLayoutEncoder --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--定义控制台输出格式--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d [%thread] %-5level %logger&#123;36&#125; [%file : %line] - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"file"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--定义日志输出的路径--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--这里的scheduler.manager.server.home 没有在上面的配置中设定，所以会使用java启动时配置的值--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--比如通过 java -Dscheduler.manager.server.home=/path/to XXXX 配置该属性--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">file</span>&gt;</span>$&#123;scheduler.manager.server.home&#125;/logs/$&#123;app.name&#125;.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--定义日志滚动的策略--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--定义文件滚动时的文件名的格式--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>$&#123;scheduler.manager.server.home&#125;/logs/$&#123;app.name&#125;.%d&#123;yyyy-MM-dd.HH&#125;.log.gz</span><br><span class="line">            <span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--60天的时间周期，日志量最大20GB--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>60<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 该属性在 1.1.6版本后 才开始支持--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">totalSizeCap</span>&gt;</span>20GB<span class="tag">&lt;/<span class="name">totalSizeCap</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">triggeringPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--每个日志文件最大100MB--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxFileSize</span>&gt;</span>100MB<span class="tag">&lt;/<span class="name">maxFileSize</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">triggeringPolicy</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--定义输出格式--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d [%thread] %-5level %logger&#123;36&#125; [%file : %line] - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--root是默认的logger 这里设定输出级别是debug--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"trace"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--定义了两个appender，日志会通过往这两个appender里面写--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"stdout"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"file"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--对于类路径以 com.example.logback 开头的Logger,输出级别设置为warn,并且只输出到控制台--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--这个logger没有指定appender，它会继承root节点中定义的那些appender--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"com.example.logback"</span> <span class="attr">level</span>=<span class="string">"warn"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--通过 LoggerFactory.getLogger("mytest") 可以获取到这个logger--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--由于这个logger自动继承了root的appender，root中已经有stdout的appender了，自己这边又引入了stdout的appender--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--如果没有设置 additivity="false" ,就会导致一条日志在控制台输出两次的情况--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--additivity表示要不要使用rootLogger配置的appender进行输出--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"mytest"</span> <span class="attr">level</span>=<span class="string">"info"</span> <span class="attr">additivity</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"stdout"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--由于设置了 additivity="false" ，所以输出时不会使用rootLogger的appender--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--但是这个logger本身又没有配置appender，所以使用这个logger输出日志的话就不会输出到任何地方--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"mytest2"</span> <span class="attr">level</span>=<span class="string">"info"</span> <span class="attr">additivity</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><br><br></details><p>附录：<a href="/2020/01/05/java-log-system/Alibaba-java-coding-guidelines.pdf">阿里巴巴Java代码规范手册</a></p>]]></content>
    
    <summary type="html">
    
      Java中各种日志层出不穷，都曾想一统天下，最落得个鱼龙混杂，受苦的还是我们这些程序员。这篇文章不讲日志的设计与实现，只说说日常开发中如何使用，如何统一，排除日志冲突，统一日志配置。PS：本文只讨论常规的Java开发场景，不深入讨论J2ME、Android等开发框架。附阿里巴巴Java代码规范手册。
    
    </summary>
    
      <category term="Java" scheme="http://blog.zjee.ml/categories/Java/"/>
    
    
      <category term="Java" scheme="http://blog.zjee.ml/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>HashMap源码完全解读</title>
    <link href="http://blog.zjee.ml/2019/12/29/hashmap-source-learning/"/>
    <id>http://blog.zjee.ml/2019/12/29/hashmap-source-learning/</id>
    <published>2019-12-29T09:31:19.000Z</published>
    <updated>2019-12-29T09:31:19.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、HashMap基础"><a href="#一、HashMap基础" class="headerlink" title="一、HashMap基础"></a>一、HashMap基础</h1><h3 id="1、HashMap成员变量及默认值"><a href="#1、HashMap成员变量及默认值" class="headerlink" title="1、HashMap成员变量及默认值"></a>1、HashMap成员变量及默认值</h3><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">类型</th><th style="text-align:center">默认值</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">DEFAULT_INITIAL_CAPACITY</td><td style="text-align:center">int</td><td style="text-align:center">$2^{4}$</td><td style="text-align:center">默认初始化容量 (这里的容量指table的长度而不是size，下同)</td></tr><tr><td style="text-align:center">MAXIMUM_CAPACITY</td><td style="text-align:center">int</td><td style="text-align:center">$2^{30}$</td><td style="text-align:center">最大容量（table最大长度）</td></tr><tr><td style="text-align:center">DEFAULT_LOAD_FACTOR</td><td style="text-align:center">float</td><td style="text-align:center">0.75f</td><td style="text-align:center">默认加载因子</td></tr><tr><td style="text-align:center">TREEIFY_THRESHOLD</td><td style="text-align:center">int</td><td style="text-align:center">8</td><td style="text-align:center">树形化阈值，如果链表长度&gt;=该值就考虑树形化</td></tr><tr><td style="text-align:center">UNTREEIFY_THRESHOLD</td><td style="text-align:center">int</td><td style="text-align:center">6</td><td style="text-align:center">链表化阈值，如果树的节点数&lt;=该值就考虑转换为链表</td></tr><tr><td style="text-align:center">MIN_TREEIFY_CAPACITY</td><td style="text-align:center">int</td><td style="text-align:center">64</td><td style="text-align:center">树形化需要的最小容量，只有table的长度&gt;=该值才会树形化</td></tr><tr><td style="text-align:center">table</td><td style="text-align:center">Node[]</td><td style="text-align:center">-</td><td style="text-align:center">hash桶，映射不同的hash地址</td></tr><tr><td style="text-align:center">entrySet</td><td style="text-align:center">Set&lt;Map.Entry&gt;</td><td style="text-align:center">-</td><td style="text-align:center">key-value set缓存</td></tr><tr><td style="text-align:center">size</td><td style="text-align:center">int</td><td style="text-align:center">-</td><td style="text-align:center">map包含的k-v节点个数（不是table长度）</td></tr><tr><td style="text-align:center">modCount</td><td style="text-align:center">int</td><td style="text-align:center">-</td><td style="text-align:center">Map结构修改次数（用于快速失败）</td></tr><tr><td style="text-align:center">threshold</td><td style="text-align:center">int</td><td style="text-align:center">-</td><td style="text-align:center">初始化容量或capacity*loadFactor</td></tr><tr><td style="text-align:center">loadFactor</td><td style="text-align:center">float</td><td style="text-align:center">-</td><td style="text-align:center">加载因子,决定什么时候该扩容</td></tr><tr><td style="text-align:center">keySet (from AbstrctMap)</td><td style="text-align:center">Set</td><td style="text-align:center">-</td><td style="text-align:center">key set 缓存</td></tr><tr><td style="text-align:center">values(from AbstrctMap)</td><td style="text-align:center">Collection</td><td style="text-align:center">-</td><td style="text-align:center">values 缓存</td></tr></tbody></table><h3 id="2、HashMap常用方法及实现原理"><a href="#2、HashMap常用方法及实现原理" class="headerlink" title="2、HashMap常用方法及实现原理"></a>2、HashMap常用方法及实现原理</h3><ol><li>hash值的计算：HashMap中的hash不是直接使用<code>Object.hashCode()</code>生成的，而是在这基础上将hashCode的高16位与低16位进行了一次异或。这么做的原因与hash地址计算方式有关，HashMap的hash地址计算方式为<code>hash&amp;(table.length-1)</code>，从二进制的角度来看，绝大多数情况下只有hashCode的低几位有效参与了地址计算，这种情况下如果开发人员的hashCode实现不够优良，就会存在数据分布不均的情况，而高16位与低16位的异或将高16位特征带到低16位，可以最大化保证hashCode在低位的均匀分布。<br><details><summary style="color:blue">点击展开代码</summary> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> h;</span><br><span class="line"><span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);<span class="comment">//null的hash为0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></li></ol><p></p><ol start="2"><li><p>判断传入的key是否可比较大小。</p><p><strong>🔶</strong> 在红黑树操作中，当key的hash发生碰撞时，就调用这些方法尝试比较key的大小。<br><details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//是不是可比较，返回null表示不可比较，否则返回x.getClass()</span></span><br><span class="line"><span class="keyword">static</span> Class&lt;?&gt; comparableClassFor(Object x) &#123;</span><br><span class="line">  <span class="keyword">if</span> (x <span class="keyword">instanceof</span> Comparable) &#123;</span><br><span class="line">    Class&lt;?&gt; c; Type[] ts, as; Type t; ParameterizedType p;</span><br><span class="line">    <span class="comment">// String可比较，直接返回（String用的最多，所以这里单独处理，加快程序速度）</span></span><br><span class="line">    <span class="keyword">if</span> ((c = x.getClass()) == String.class) </span><br><span class="line">      <span class="keyword">return</span> c;</span><br><span class="line">    <span class="comment">//获取该类的接口，如果接口中有Comparable.class,就表示x是可比较的，直接返回该class</span></span><br><span class="line">    <span class="keyword">if</span> ((ts = c.getGenericInterfaces()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ts.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (((t = ts[i]) <span class="keyword">instanceof</span> ParameterizedType) &amp;&amp;</span><br><span class="line">            ((p = (ParameterizedType)t).getRawType() ==</span><br><span class="line">             Comparable.class) &amp;&amp;</span><br><span class="line">            (as = p.getActualTypeArguments()) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            as.length == <span class="number">1</span> &amp;&amp; as[<span class="number">0</span>] == c) <span class="comment">// type arg is c</span></span><br><span class="line">          <span class="keyword">return</span> c;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;<span class="comment">//不可比较的对象直接返回null</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//比较两个对象k, x</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;) <span class="comment">// for cast to Comparable</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">compareComparables</span><span class="params">(Class&lt;?&gt; kc, Object k, Object x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (x == <span class="keyword">null</span> || x.getClass() != kc ? <span class="number">0</span> : <span class="comment">//注意对null和class不同时的处理</span></span><br><span class="line">          ((Comparable)k).compareTo(x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></p></li></ol><p></p><ol start="3"><li><p>根据给定的值重新计算tableSize：这一步是把我们自定义的capacity初始化为离cap最近的$2^{n}$的一个值，保证capacity是$2^{n}$的形式主要为了方便hash地址计算和扩容。</p><p><strong>🔶</strong> 试想一下假如初始化容量是15，根据hash地址的计算公式<code>hash&amp;(n-1)</code>，n-1也就是14，对应的二进制是1110，则<code>hash&amp;1110</code>结果必定是<code>xxx0</code>形式的，也就是说算出的地址最后一位永远是0，转换为10进制就发现奇数位的桶永远分配不到节点，这会导致HashMap严重分布不均。</p><p><strong>🔶</strong>  另一方面：扩容时，新容量是原容量的2倍，对于<code>hash&amp;(n-1)</code>来说，就相当于n-1的二进制向左扩展了1个1，比如(16-1)的二进制是<code>1111</code>，扩容后(32-1)的二进制<code>11111</code>，与原hash地址相比较只有最高位的1带来了差异（如下图所示），而hash中与之对应的位只有1和0两种情况，所以原链表/红黑树最多拆分为两个链表/红黑树就可以了，且拆分后的两个结构，一个留在原地(hash对应位为0)，一个升到高位置(hash对应位为1)，且这个高位是固定的，就是<code>hash&amp;(2n-1)</code>或者<code>hash&amp;(n-1)+n</code>。</p><img src="/2019/12/29/hashmap-source-learning/hash-addr.png" title="HashMap扩容"><p><strong>🔶</strong>  而当容量设置为15时，我们会发现14与29的二进制差异很大，这就给rehash的过程带来很大麻烦和不必要的开销。<br><details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将传入的cap变为相近的2的x次方的形式</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">  n |= n &gt;&gt;&gt; <span class="number">1</span>; <span class="comment">//将最高2位变为1</span></span><br><span class="line">  n |= n &gt;&gt;&gt; <span class="number">2</span>; <span class="comment">//将最高4位变为1</span></span><br><span class="line">  n |= n &gt;&gt;&gt; <span class="number">4</span>; <span class="comment">//将最高8位变为1</span></span><br><span class="line">  n |= n &gt;&gt;&gt; <span class="number">8</span>; <span class="comment">//将最高16位变为1</span></span><br><span class="line">  n |= n &gt;&gt;&gt; <span class="number">16</span>; <span class="comment">//32位全变为1(2^n-1)</span></span><br><span class="line">  <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;<span class="comment">//n+1就是2^n</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></p></li></ol><p></p><ol start="4"><li>HashMap构造方法<br><details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法：指定初始容量和加载因子</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> + initialCapacity);</span><br><span class="line">  <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">    initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">  <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> + loadFactor);</span><br><span class="line">  <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">  <span class="comment">//注意：用threshold保存初始化容量</span></span><br><span class="line">  <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造方法：指定初始容量，使用默认加载因子0.75</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造方法：无参构造方法，全部使用默认参数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造方法：从一个Map构造另一个Map，采用默认加载因子</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">  putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></li></ol><p></p><ol start="5"><li>插入另外一个Map的所有数据（putMapEntries）<br><details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//批量put元素， 当且仅当构造map并批量put时evict为false</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> s = m.size();<span class="comment">//现有Map元素数量</span></span><br><span class="line">  <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (table == <span class="keyword">null</span>) &#123; <span class="comment">// 如果table还未初始化</span></span><br><span class="line">      <span class="keyword">float</span> ft = ((<span class="keyword">float</span>)s / loadFactor) + <span class="number">1.0F</span>; <span class="comment">//计算需要的容量</span></span><br><span class="line">      <span class="keyword">int</span> t = ((ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">               (<span class="keyword">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class="line">      <span class="keyword">if</span> (t &gt; threshold) <span class="comment">//如果需要的容量大于之前设置的初始化容量</span></span><br><span class="line">        threshold = tableSizeFor(t);<span class="comment">//就重新确定一个比较大的初始化容量</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果table已经初始化了，且要加入的元素数量大于threshold就直接扩容</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; threshold) </span><br><span class="line">      resize();</span><br><span class="line">    <span class="comment">//放入新元素</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;</span><br><span class="line">      K key = e.getKey();</span><br><span class="line">      V value = e.getValue();</span><br><span class="line">      putVal(hash(key), key, value, <span class="keyword">false</span>, evict);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></li></ol><p></p><ol start="6"><li>公共常用方法：<br><details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取元素个数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Map是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据key获取元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">  Node&lt;K,V&gt; e;</span><br><span class="line">  <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//检查是否包含某个key，与get方法实现一致</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getNode(hash(key), key) != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新加入一个kay-value对，如果key已经存在就返回之前的value，否则返回null</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加入另外一个Map的所有元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    putMapEntries(m, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除key关联的元素，返回删除的元素，如果key不存在则返回null</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</span><br><span class="line">        <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除所有节点（注意：table.length没变）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//全部与table解挂就行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i)</span><br><span class="line">            tab[i] = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找是否存在给定的value（不建议使用）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; V v;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//遍历table</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">            <span class="comment">//遍历链表/树（这里可以看出树也有一条类似链表访问的路径）</span></span><br><span class="line">            <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((v = e.value) == value ||</span><br><span class="line">                    (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></li></ol><p></p><ol start="7"><li>根据指定的key查找对应Node节点，找不到对应key就返回<code>null</code>。<br><details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据给定的key获取节点</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="comment">//如果table不为空且对应hash地址的第首节点不为空</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//如果首节点的hash和key都与查询key匹配的话就直接返回首节点</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="comment">//否则检查首节点下面是否还有节点，有其他节点就继续查询</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果首节点是树状节点，就去红黑树中查询</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">//否则就遍历链表</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="comment">//如果找到某个key与给定key一致就返回该节点</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></li></ol><p></p><ol start="8"><li>插入一个新节点，并返回旧节点的值，旧节点不存在返回<code>null</code>。<br><details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//onlyIfAbsent表示是否仅当key不存在时才插入，evict为false表示在初始化(创建)模式</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">//table为空或长度为0时，重新扩容table</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">//如果插入的key对应的hash地址上没有值，则直接在该位置新增一个节点即可</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">//如果插入的key对应的hash地址上已经存在其他节点</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">//如果首节点就是key对应节点，就用一个临时变量e记录下来</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">//否则，如果首节点是树状节点，就去红黑树插入（找到）一个节点，并记录</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">//否则遍历链表</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//binCount记录链表长度</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">//如果整个链表都没找到key，则在末尾新创建一个节点</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">//如果链表长度达到树形化阈值，就将链表进行树形化或扩容操作</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果在链表中找到key就记录下来</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果插入的key已经存在就按要求替换值，并返回旧值</span></span><br><span class="line">        <span class="comment">//如果新插入节点e就是null，跳过这一步</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            <span class="comment">//更新节点完成后一些其他操作，HashMap这里什么也不做</span></span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="comment">//返回旧节点的值</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//统计Map结构修改次数,用于迭代器快速失败</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">//检查是否需要扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">//插入新节点后的一些额外操作，HashMap这里什么也不做</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></li></ol><p></p><ol start="9"><li>移除一个节点<br><details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除元素的实现，如果matchValue为true则还要匹配value</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</span><br><span class="line">    <span class="comment">//一顿空值检查</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;</span><br><span class="line">        <span class="comment">//第一个元素就是要删除的，用临时变量node记录</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            node = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//从树中找到要删除的元素node</span></span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//遍历链表</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                         (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e;<span class="comment">//p是e的前驱节点</span></span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果node不为空且value检查也符合条件</span></span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                             (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            <span class="comment">//从树中删除node</span></span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">            <span class="comment">//node就是首节点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">//删除node</span></span><br><span class="line">                p.next = node.next;</span><br><span class="line">            ++modCount;<span class="comment">//记录本次修改</span></span><br><span class="line">            --size;<span class="comment">//size-1</span></span><br><span class="line">            afterNodeRemoval(node);<span class="comment">//删除节点后的其他工作，HashMap什么也不做</span></span><br><span class="line">            <span class="keyword">return</span> node;<span class="comment">//返回删除的节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></li></ol><p></p><h3 id="3、HashMap扩容、Rehash和树形化"><a href="#3、HashMap扩容、Rehash和树形化" class="headerlink" title="3、HashMap扩容、Rehash和树形化"></a>3、HashMap扩容、Rehash和树形化</h3><ol><li><p>HashMap扩容方法</p><p>🔶 HashMap扩容的条件：1、初始化。2、HashMap中节点总数大于capacity*loadfactor。3、capacity小于<code>MIN_TREEIFY_CAPACITY</code>(64)，且单链表长度大于等于<code>TREEIFY_THRESHOLD</code>(8)。</p><p>🔶 达到扩容条件后并不是一定扩容成功，如果当前容量大于等于<code>MAXIMUM_CAPACITY</code>($2^{30}$)就不再扩容，threshold设置为<code>Integer.MAX_VALUE</code>。这里一定不会出现扩容后的容量大于<code>MAXIMUM_CAPACITY</code>的情况，因为capacity都是2的整数次方形式，一次扩容只扩大一倍，因此无限扩容时一定会命中<code>MAXIMUM_CAPACITY</code>，此后不再扩容。<br><details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//HashMap扩容操作，先扩容再重新分布（如果需要的话）</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//如果旧table长度大于0（非初始化）</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//如果旧table长度达最大值，就直接调整阈值到最大值</span></span><br><span class="line">        <span class="comment">//此后阈值失效，不再扩容，并直接返回旧table</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果新table长度小于MAXIMUM_CAPACITY，阈值x2</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            <span class="comment">//oldCap*2后可能&gt;=MAXIMUM_CAPACITY，此时newThr赋值操作跳过，就还是0</span></span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果初始化容量大于0，新容量就是这个值（注意这里没有设置newThr,newThr还是0）</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="comment">//根据默认情况初始化table</span></span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果非默认初始化时，新容量等于MAXIMUM_CAPACITY时，newThr为0，需要重新计算</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//rehash过程，重新分布元素</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//遍历旧table</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="comment">//如果j位置有元素就用临时变量e标记</span></span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//释放旧table[j]</span></span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">//如果e只有一个元素（不构成链表、树），就直接重新计算地址，然后放过去</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">//如果e是红黑树，就按红黑树的方式rehash</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="comment">//如果e是链表，就拆分为两个链表，一个在原位置一个在新位置</span></span><br><span class="line">                <span class="comment">//只需要拆分为两个链表的原因与其地址计算方式有关:hash&amp;(n-1)</span></span><br><span class="line">                <span class="comment">//扩容2倍，对于n-1的二进制来说就是左边多了一个1，这对于原来在该链表的key</span></span><br><span class="line">                <span class="comment">//来说，也只需要关注hash对应位置是0还是1，0则留在原地，1则搬到新住所</span></span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order（保留相对顺序）</span></span><br><span class="line">                    <span class="comment">//留在原地的链表头&amp;尾（新table地址低位，这里的高低就是数字大小）</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="comment">//乔迁新居的链表头&amp;尾（新table地址高位）</span></span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="comment">//遍历旧链表</span></span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">//是否留在原地，(e.hash &amp; oldCap)==0表示新增的那一位为0，</span></span><br><span class="line">                        <span class="comment">//不影响新地址计算，否则就要搬家</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)<span class="comment">//链表初始化</span></span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span> <span class="comment">//追加到尾部</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 乔迁新居</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">//如果拆分出来的链表不为空就把它放到对应位置上</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="comment">//新地址的计算方式：$oldAddr + oldCap</span></span><br><span class="line">                        <span class="comment">//hash&amp;(oldCap-1)+oldCap = hash&amp;(oldCap*2-1)</span></span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></p></li></ol><p></p><ol start="2"><li>树形化操作<br><details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//树形化，如果table长度(！！！不是size！！！)小于MIN_TREEIFY_CAPACITY(64)则进行扩容</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">//如果table为空或table长度小于MIN_TREEIFY_CAPACITY则进行扩容，why???</span></span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">//如果给定的hash对应位置不为空</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//先把节点类型全部换成TreeNode</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">                hd = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p.prev = tl;</span><br><span class="line">                tl.next = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tl = p;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//树形化，index就是地址: index = (n - 1) &amp; hash</span></span><br><span class="line">        <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">            hd.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></li></ol><p></p><h3 id="4、Node定义及与TreeNode转换操作"><a href="#4、Node定义及与TreeNode转换操作" class="headerlink" title="4、Node定义及与TreeNode转换操作"></a>4、Node定义及与TreeNode转换操作</h3><ol><li>Node定义<br><details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Node数据结构</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;<span class="comment">//key的hash</span></span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + value; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">        V oldValue = value;</span><br><span class="line">        value = newValue;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">            <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                Objects.equals(value, e.getValue()))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></li></ol><p></p><ol start="2"><li>Node、TreeNode构造及转换操作<br><details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a regular (non-tree) node</span></span><br><span class="line"><span class="function">Node&lt;K,V&gt; <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Node&lt;&gt;(hash, key, value, next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// For conversion from TreeNodes to plain nodes</span></span><br><span class="line"><span class="function">Node&lt;K,V&gt; <span class="title">replacementNode</span><span class="params">(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Node&lt;&gt;(p.hash, p.key, p.value, next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a tree bin node</span></span><br><span class="line"><span class="function">TreeNode&lt;K,V&gt; <span class="title">newTreeNode</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TreeNode&lt;&gt;(hash, key, value, next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// For treeifyBin</span></span><br><span class="line"><span class="function">TreeNode&lt;K,V&gt; <span class="title">replacementTreeNode</span><span class="params">(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TreeNode&lt;&gt;(p.hash, p.key, p.value, next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></li></ol><p></p><h3 id="5、-Set视图、迭代器-Iterator-与分割器-Spliterator"><a href="#5、-Set视图、迭代器-Iterator-与分割器-Spliterator" class="headerlink" title="5、 Set视图、迭代器(Iterator)与分割器(Spliterator)"></a>5、 Set视图、迭代器(Iterator)与分割器(Spliterator)</h3><ol><li><p>keySet</p><ul><li>KeySet定义<br><details><summary style="color:blue">点击展开代码</summary> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//HashMap御用KeySet</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KeySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>                 </span>&#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span>               </span>&#123; HashMap.<span class="keyword">this</span>.clear(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;K&gt; <span class="title">iterator</span><span class="params">()</span>     </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> KeyIterator(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123; <span class="keyword">return</span> containsKey(o); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>) != <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Spliterator&lt;K&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> KeySpliterator&lt;&gt;(HashMap.<span class="keyword">this</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> K&gt; action)</span> </span>&#123;</span><br><span class="line">      Node&lt;K,V&gt;[] tab;</span><br><span class="line">      <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">      <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; (tab = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">int</span> mc = modCount;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">              <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next)</span><br><span class="line">                  action.accept(e.key);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//迭代前后修改次数不一致则快速失败</span></span><br><span class="line">          <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></li></ul><p></p><ul><li>keySet方法<br><details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回key的集合【视图】,它并不是真正的Set，它仅仅提供了Set化的操作接口。</span></span><br><span class="line"><span class="comment">//Set与Map的任何修改都会相互体现出来。</span></span><br><span class="line"><span class="comment">//在Set迭代过程中修改了Map则迭代结果未定义。</span></span><br><span class="line"><span class="comment">//可以通过Set自带的方法修改Map，但不能添加key。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Set&lt;K&gt; ks = keySet;</span><br><span class="line">    <span class="keyword">if</span> (ks == <span class="keyword">null</span>) &#123;</span><br><span class="line">        ks = <span class="keyword">new</span> KeySet();</span><br><span class="line">        keySet = ks;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></li></ul></li></ol><p></p><ol start="2"><li><p>values</p><ul><li>Values定义<br><details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Values</span> <span class="keyword">extends</span> <span class="title">AbstractCollection</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>                 </span>&#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span>               </span>&#123; HashMap.<span class="keyword">this</span>.clear(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;V&gt; <span class="title">iterator</span><span class="params">()</span>     </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> ValueIterator(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123; <span class="keyword">return</span> containsValue(o); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Spliterator&lt;V&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ValueSpliterator&lt;&gt;(HashMap.<span class="keyword">this</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> V&gt; action)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab;</span><br><span class="line">        <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; (tab = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> mc = modCount;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next)</span><br><span class="line">                    action.accept(e.value);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//同样快速失败</span></span><br><span class="line">            <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></li></ul><p></p><ul><li>values方法<br><details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//values：类似KeySet</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Collection&lt;V&gt; <span class="title">values</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Collection&lt;V&gt; vs = values;</span><br><span class="line">    <span class="keyword">if</span> (vs == <span class="keyword">null</span>) &#123;</span><br><span class="line">        vs = <span class="keyword">new</span> Values();</span><br><span class="line">        values = vs;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></li></ul></li></ol><p></p><ol start="3"><li><p>entrySet</p><ul><li>EntrySet定义<br><details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EntrySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>                 </span>&#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span>               </span>&#123; HashMap.<span class="keyword">this</span>.clear(); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EntryIterator();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;</span><br><span class="line">        Object key = e.getKey();</span><br><span class="line">        Node&lt;K,V&gt; candidate = getNode(hash(key), key);</span><br><span class="line">        <span class="keyword">return</span> candidate != <span class="keyword">null</span> &amp;&amp; candidate.equals(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;</span><br><span class="line">            Object key = e.getKey();</span><br><span class="line">            Object value = e.getValue();</span><br><span class="line">            <span class="keyword">return</span> removeNode(hash(key), key, value, <span class="keyword">true</span>, <span class="keyword">true</span>) != <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Spliterator&lt;Map.Entry&lt;K,V&gt;&gt; spliterator() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EntrySpliterator&lt;&gt;(HashMap.<span class="keyword">this</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> Map.Entry&lt;K,V&gt;&gt; action)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab;</span><br><span class="line">        <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; (tab = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> mc = modCount;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next)</span><br><span class="line">                    action.accept(e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></li></ul><p></p><ul><li>entrySet方法<br><details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//EntrySet: same as keySet and values</span></span><br><span class="line"><span class="keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123;</span><br><span class="line">    Set&lt;Map.Entry&lt;K,V&gt;&gt; es;</span><br><span class="line">    <span class="keyword">return</span> (es = entrySet) == <span class="keyword">null</span> ? (entrySet = <span class="keyword">new</span> EntrySet()) : es;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></li></ul></li></ol><p></p><ol start="4"><li><p>迭代器(Itetator)</p><ul><li>HashIterator核心功能（抽象类）<br><details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//迭代器，注意是abstract</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HashIterator</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; next;        <span class="comment">// next entry to return</span></span><br><span class="line">    Node&lt;K,V&gt; current;     <span class="comment">// current entry</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount;  <span class="comment">// for fast-fail</span></span><br><span class="line">    <span class="keyword">int</span> index;             <span class="comment">// current slot</span></span><br><span class="line"></span><br><span class="line">    HashIterator() &#123;</span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">        Node&lt;K,V&gt;[] t = table;</span><br><span class="line">        current = next = <span class="keyword">null</span>;</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//找到第一个不为null的node，用next标记</span></span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123; <span class="comment">// advance to first entry</span></span><br><span class="line">            <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> next != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">nextNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] t;</span><br><span class="line">        Node&lt;K,V&gt; e = next;</span><br><span class="line">        <span class="comment">//迭代中途发生结构修改，直接快速失败</span></span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        <span class="comment">//如果当前链表/树遍历完了，就在table中寻找下一个不为null的节点</span></span><br><span class="line">        <span class="keyword">if</span> ((next = (current = e).next) == <span class="keyword">null</span> &amp;&amp; (t = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; p = current;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>)<span class="comment">//如果当前节点被删除了</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        current = <span class="keyword">null</span>;</span><br><span class="line">        K key = p.key;、</span><br><span class="line">            <span class="comment">//删除节点</span></span><br><span class="line">            removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//更新【期望修改次数】，很重要！！！</span></span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></li></ul><p></p><ul><li>遍历keySet使用的KeyIterator<br><details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//三种迭代器，都以abstract HashIterator为基础</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextNode().key; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></li></ul><p></p><ul><li>遍历values使用的ValueIterator<br><details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextNode().value; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></li></ul><p></p><ul><li>遍历entrySet使用的EntryIterator<br><details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EntryIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Map.<span class="function">Entry&lt;K,V&gt; <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextNode(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></li></ul></li></ol><p></p><ol start="5"><li><p>分割器(Spliterator)，Java8新引入的功能</p><ul><li>HashMapSpliterator核心功能（抽象类）<br><details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分割器，</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapSpliterator</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> HashMap&lt;K,V&gt; map;</span><br><span class="line">    Node&lt;K,V&gt; current;          <span class="comment">// current node</span></span><br><span class="line">    <span class="keyword">int</span> index;                  <span class="comment">// current index, modified on advance/split</span></span><br><span class="line">    <span class="keyword">int</span> fence;                  <span class="comment">// one past last index</span></span><br><span class="line">    <span class="keyword">int</span> est;                    <span class="comment">// size estimate</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount;       <span class="comment">// for comodification checks</span></span><br><span class="line"></span><br><span class="line">    HashMapSpliterator(HashMap&lt;K,V&gt; m, <span class="keyword">int</span> origin,</span><br><span class="line">                       <span class="keyword">int</span> fence, <span class="keyword">int</span> est,</span><br><span class="line">                       <span class="keyword">int</span> expectedModCount) &#123;</span><br><span class="line">        <span class="keyword">this</span>.map = m;</span><br><span class="line">        <span class="keyword">this</span>.index = origin;</span><br><span class="line">        <span class="keyword">this</span>.fence = fence;</span><br><span class="line">        <span class="keyword">this</span>.est = est;</span><br><span class="line">        <span class="keyword">this</span>.expectedModCount = expectedModCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getFence</span><span class="params">()</span> </span>&#123; <span class="comment">// initialize fence and size on first use</span></span><br><span class="line">        <span class="keyword">int</span> hi;</span><br><span class="line">        <span class="keyword">if</span> ((hi = fence) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            HashMap&lt;K,V&gt; m = map;</span><br><span class="line">            est = m.size;</span><br><span class="line">            expectedModCount = m.modCount;</span><br><span class="line">            Node&lt;K,V&gt;[] tab = m.table;</span><br><span class="line">            hi = fence = (tab == <span class="keyword">null</span>) ? <span class="number">0</span> : tab.length;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hi;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">estimateSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        getFence(); <span class="comment">// force init</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">long</span>) est;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></li></ul><p></p><ul><li>KeySpliterator<br><details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KeySpliterator</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMapSpliterator</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Spliterator</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">    KeySpliterator(HashMap&lt;K,V&gt; m, <span class="keyword">int</span> origin, <span class="keyword">int</span> fence, <span class="keyword">int</span> est,</span><br><span class="line">                   <span class="keyword">int</span> expectedModCount) &#123;</span><br><span class="line">        <span class="keyword">super</span>(m, origin, fence, est, expectedModCount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> KeySpliterator&lt;K,V&gt; <span class="title">trySplit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hi = getFence(), lo = index, mid = (lo + hi) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> (lo &gt;= mid || current != <span class="keyword">null</span>) ? <span class="keyword">null</span> :</span><br><span class="line">        <span class="keyword">new</span> KeySpliterator&lt;&gt;(map, lo, index = mid, est &gt;&gt;&gt;= <span class="number">1</span>,</span><br><span class="line">                             expectedModCount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> K&gt; action)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i, hi, mc;</span><br><span class="line">        <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        HashMap&lt;K,V&gt; m = map;</span><br><span class="line">        Node&lt;K,V&gt;[] tab = m.table;</span><br><span class="line">        <span class="keyword">if</span> ((hi = fence) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            mc = expectedModCount = m.modCount;</span><br><span class="line">            hi = fence = (tab == <span class="keyword">null</span>) ? <span class="number">0</span> : tab.length;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            mc = expectedModCount;</span><br><span class="line">        <span class="keyword">if</span> (tab != <span class="keyword">null</span> &amp;&amp; tab.length &gt;= hi &amp;&amp;</span><br><span class="line">            (i = index) &gt;= <span class="number">0</span> &amp;&amp; (i &lt; (index = hi) || current != <span class="keyword">null</span>)) &#123;</span><br><span class="line">            Node&lt;K,V&gt; p = current;</span><br><span class="line">            current = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">                    p = tab[i++];</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    action.accept(p.key);</span><br><span class="line">                    p = p.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">while</span> (p != <span class="keyword">null</span> || i &lt; hi);</span><br><span class="line">            <span class="keyword">if</span> (m.modCount != mc)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAdvance</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> K&gt; action)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hi;</span><br><span class="line">        <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        Node&lt;K,V&gt;[] tab = map.table;</span><br><span class="line">        <span class="keyword">if</span> (tab != <span class="keyword">null</span> &amp;&amp; tab.length &gt;= (hi = getFence()) &amp;&amp; index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (current != <span class="keyword">null</span> || index &lt; hi) &#123;</span><br><span class="line">                <span class="keyword">if</span> (current == <span class="keyword">null</span>)</span><br><span class="line">                    current = tab[index++];</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    K k = current.key;</span><br><span class="line">                    current = current.next;</span><br><span class="line">                    action.accept(k);</span><br><span class="line">                    <span class="keyword">if</span> (map.modCount != expectedModCount)</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">characteristics</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (fence &lt; <span class="number">0</span> || est == map.size ? Spliterator.SIZED : <span class="number">0</span>) |</span><br><span class="line">            Spliterator.DISTINCT;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></li></ul><p></p><ul><li>ValueSpliterator<br><details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueSpliterator</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMapSpliterator</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Spliterator</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    ValueSpliterator(HashMap&lt;K,V&gt; m, <span class="keyword">int</span> origin, <span class="keyword">int</span> fence, <span class="keyword">int</span> est,</span><br><span class="line">                     <span class="keyword">int</span> expectedModCount) &#123;</span><br><span class="line">        <span class="keyword">super</span>(m, origin, fence, est, expectedModCount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ValueSpliterator&lt;K,V&gt; <span class="title">trySplit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hi = getFence(), lo = index, mid = (lo + hi) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> (lo &gt;= mid || current != <span class="keyword">null</span>) ? <span class="keyword">null</span> :</span><br><span class="line">        <span class="keyword">new</span> ValueSpliterator&lt;&gt;(map, lo, index = mid, est &gt;&gt;&gt;= <span class="number">1</span>,</span><br><span class="line">                               expectedModCount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> V&gt; action)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i, hi, mc;</span><br><span class="line">        <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        HashMap&lt;K,V&gt; m = map;</span><br><span class="line">        Node&lt;K,V&gt;[] tab = m.table;</span><br><span class="line">        <span class="keyword">if</span> ((hi = fence) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            mc = expectedModCount = m.modCount;</span><br><span class="line">            hi = fence = (tab == <span class="keyword">null</span>) ? <span class="number">0</span> : tab.length;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            mc = expectedModCount;</span><br><span class="line">        <span class="keyword">if</span> (tab != <span class="keyword">null</span> &amp;&amp; tab.length &gt;= hi &amp;&amp;</span><br><span class="line">            (i = index) &gt;= <span class="number">0</span> &amp;&amp; (i &lt; (index = hi) || current != <span class="keyword">null</span>)) &#123;</span><br><span class="line">            Node&lt;K,V&gt; p = current;</span><br><span class="line">            current = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">                    p = tab[i++];</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    action.accept(p.value);</span><br><span class="line">                    p = p.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">while</span> (p != <span class="keyword">null</span> || i &lt; hi);</span><br><span class="line">            <span class="keyword">if</span> (m.modCount != mc)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAdvance</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> V&gt; action)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hi;</span><br><span class="line">        <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        Node&lt;K,V&gt;[] tab = map.table;</span><br><span class="line">        <span class="keyword">if</span> (tab != <span class="keyword">null</span> &amp;&amp; tab.length &gt;= (hi = getFence()) &amp;&amp; index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (current != <span class="keyword">null</span> || index &lt; hi) &#123;</span><br><span class="line">                <span class="keyword">if</span> (current == <span class="keyword">null</span>)</span><br><span class="line">                    current = tab[index++];</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    V v = current.value;</span><br><span class="line">                    current = current.next;</span><br><span class="line">                    action.accept(v);</span><br><span class="line">                    <span class="keyword">if</span> (map.modCount != expectedModCount)</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">characteristics</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (fence &lt; <span class="number">0</span> || est == map.size ? Spliterator.SIZED : <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></li></ul><p></p><ul><li>EntrySpliterator<br><details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EntrySpliterator</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMapSpliterator</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Spliterator</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>&#123;</span><br><span class="line">    EntrySpliterator(HashMap&lt;K,V&gt; m, <span class="keyword">int</span> origin, <span class="keyword">int</span> fence, <span class="keyword">int</span> est,</span><br><span class="line">                     <span class="keyword">int</span> expectedModCount) &#123;</span><br><span class="line">        <span class="keyword">super</span>(m, origin, fence, est, expectedModCount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> EntrySpliterator&lt;K,V&gt; <span class="title">trySplit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hi = getFence(), lo = index, mid = (lo + hi) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> (lo &gt;= mid || current != <span class="keyword">null</span>) ? <span class="keyword">null</span> :</span><br><span class="line">        <span class="keyword">new</span> EntrySpliterator&lt;&gt;(map, lo, index = mid, est &gt;&gt;&gt;= <span class="number">1</span>,</span><br><span class="line">                               expectedModCount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> Map.Entry&lt;K,V&gt;&gt; action)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i, hi, mc;</span><br><span class="line">        <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        HashMap&lt;K,V&gt; m = map;</span><br><span class="line">        Node&lt;K,V&gt;[] tab = m.table;</span><br><span class="line">        <span class="keyword">if</span> ((hi = fence) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            mc = expectedModCount = m.modCount;</span><br><span class="line">            hi = fence = (tab == <span class="keyword">null</span>) ? <span class="number">0</span> : tab.length;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            mc = expectedModCount;</span><br><span class="line">        <span class="keyword">if</span> (tab != <span class="keyword">null</span> &amp;&amp; tab.length &gt;= hi &amp;&amp;</span><br><span class="line">            (i = index) &gt;= <span class="number">0</span> &amp;&amp; (i &lt; (index = hi) || current != <span class="keyword">null</span>)) &#123;</span><br><span class="line">            Node&lt;K,V&gt; p = current;</span><br><span class="line">            current = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">                    p = tab[i++];</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    action.accept(p);</span><br><span class="line">                    p = p.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">while</span> (p != <span class="keyword">null</span> || i &lt; hi);</span><br><span class="line">            <span class="keyword">if</span> (m.modCount != mc)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAdvance</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> Map.Entry&lt;K,V&gt;&gt; action)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hi;</span><br><span class="line">        <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        Node&lt;K,V&gt;[] tab = map.table;</span><br><span class="line">        <span class="keyword">if</span> (tab != <span class="keyword">null</span> &amp;&amp; tab.length &gt;= (hi = getFence()) &amp;&amp; index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (current != <span class="keyword">null</span> || index &lt; hi) &#123;</span><br><span class="line">                <span class="keyword">if</span> (current == <span class="keyword">null</span>)</span><br><span class="line">                    current = tab[index++];</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    Node&lt;K,V&gt; e = current;</span><br><span class="line">                    current = current.next;</span><br><span class="line">                    action.accept(e);</span><br><span class="line">                    <span class="keyword">if</span> (map.modCount != expectedModCount)</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">characteristics</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (fence &lt; <span class="number">0</span> || est == map.size ? Spliterator.SIZED : <span class="number">0</span>) |</span><br><span class="line">            Spliterator.DISTINCT;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></li></ul></li></ol><p></p><h1 id="二、-Java8新特性"><a href="#二、-Java8新特性" class="headerlink" title="二、 Java8新特性"></a>二、 Java8新特性</h1><ol><li>带默认值的get方法<br><details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">getOrDefault</span><span class="params">(Object key, V defaultValue)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? defaultValue : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></li></ol><p></p><ol start="2"><li>缺失key或key为null才插入节点，返回旧节点的值，如果存在的话<br><details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">putIfAbsent</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">true</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></li></ol><p></p><ol start="3"><li>基于key和value两重验证的删除操作<br><details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> removeNode(hash(key), key, value, <span class="keyword">true</span>, <span class="keyword">true</span>) != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></li></ol><p></p><ol start="4"><li>基于key和value两重验证的替换操作<br><details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">replace</span><span class="params">(K key, V oldValue, V newValue)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e; V v;</span><br><span class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">        ((v = e.value) == oldValue || (v != <span class="keyword">null</span> &amp;&amp; v.equals(oldValue)))) &#123;</span><br><span class="line">        e.value = newValue;</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></li></ol><p></p><ol start="5"><li>value替换操作，仅当key存在才替换，注意与put的区别<br><details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">replace</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        V oldValue = e.value;</span><br><span class="line">        e.value = value;</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></li></ol><p></p><ol start="6"><li>如果给定的key在map中不存在，就从给定的function计算出一个value放进map，并返回这个value<br><details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">computeIfAbsent</span><span class="params">(K key, Function&lt;? <span class="keyword">super</span> K,? extends V&gt; mappingFunction)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mappingFunction == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    TreeNode&lt;K,V&gt; t = <span class="keyword">null</span>;</span><br><span class="line">    Node&lt;K,V&gt; old = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//是否需要初始化</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt; threshold || (tab = table) == <span class="keyword">null</span> ||</span><br><span class="line">        (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="keyword">if</span> ((first = tab[i = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//如果首个节点是树型节点，就在树中查找key，返回节点用old标记</span></span><br><span class="line">        <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            old = (t = (TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;K,V&gt; e = first; K k;</span><br><span class="line">            <span class="comment">//遍历链表查询key是否存在</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                    old = e;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//统计链表长度</span></span><br><span class="line">                ++binCount;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        V oldValue;</span><br><span class="line">        <span class="comment">//如果给定key存在，并且value不为null，就直接返回对应的值</span></span><br><span class="line">        <span class="keyword">if</span> (old != <span class="keyword">null</span> &amp;&amp; (oldValue = old.value) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            afterNodeAccess(old);<span class="comment">//Do nothing</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//否则就从给定的函数key -&gt; &#123;...&#125;，计算出一个value并插入</span></span><br><span class="line">    V v = mappingFunction.apply(key);</span><br><span class="line">    <span class="keyword">if</span> (v == <span class="keyword">null</span>) &#123; <span class="comment">//如果计算出的value是null则直接返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (old != <span class="keyword">null</span>) &#123; <span class="comment">//key存在但value为null就直接替换value并返回旧value</span></span><br><span class="line">        old.value = v;</span><br><span class="line">        afterNodeAccess(old);</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (t != <span class="keyword">null</span>) <span class="comment">//如果key不存在，且当前位置为一棵树，则向树中增加一个节点</span></span><br><span class="line">        t.putTreeVal(<span class="keyword">this</span>, tab, hash, key, v);</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">//如果key不存在，且当前位置为链表，则向表头增加一个节点</span></span><br><span class="line">        tab[i] = newNode(hash, key, v, first);</span><br><span class="line">        <span class="comment">//增加完成后判断是否需要树形化</span></span><br><span class="line">        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>)</span><br><span class="line">            treeifyBin(tab, hash);</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    ++size;<span class="comment">//插入新节点size+1</span></span><br><span class="line">    afterNodeInsertion(<span class="keyword">true</span>);<span class="comment">//Do nothing</span></span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></li></ol><p></p><ol start="7"><li>如果给定的key存在，就用<code>(k,oldV) -&gt; {}</code>计算出的值替换旧值，并返回计算出的新值<br><details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">computeIfPresent</span><span class="params">(K key, </span></span></span><br><span class="line"><span class="function"><span class="params">    BiFunction&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V, ? extends V&gt; remappingFunction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (remappingFunction == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    Node&lt;K,V&gt; e; V oldValue;</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="comment">//key存在且旧值不为null</span></span><br><span class="line">    <span class="keyword">if</span> ((e = getNode(hash, key)) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">        (oldValue = e.value) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//计算新值</span></span><br><span class="line">        V v = remappingFunction.apply(key, oldValue);</span><br><span class="line">        <span class="comment">//如果新值不为null则替换成新值，并返回新值</span></span><br><span class="line">        <span class="keyword">if</span> (v != <span class="keyword">null</span>) &#123;</span><br><span class="line">            e.value = v;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> v;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//否则删除旧节点(新值为null代表该节点无效)</span></span><br><span class="line">            removeNode(hash, key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//找不到key直接返回null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></li></ol><p></p><ol start="8"><li>用<code>(key, Oldv) -&gt; {}</code>计算出的新值替换key对应的旧值，返回新值<br><details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//key存在，新值为null，删除key节点</span></span><br><span class="line"><span class="comment">//key存在，新值不为null，修改key节点</span></span><br><span class="line"><span class="comment">//key不存在，新值为null，直接返回null</span></span><br><span class="line"><span class="comment">//key不存在，新值不为null，创建新节点</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">compute</span><span class="params">(K key,</span></span></span><br><span class="line"><span class="function"><span class="params">    BiFunction&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V, ? extends V&gt; remappingFunction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (remappingFunction == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    TreeNode&lt;K,V&gt; t = <span class="keyword">null</span>;</span><br><span class="line">    Node&lt;K,V&gt; old = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//table未初始化或需要扩容就执行扩容</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt; threshold || (tab = table) == <span class="keyword">null</span> ||</span><br><span class="line">        (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">//如果首节点不为null</span></span><br><span class="line">    <span class="keyword">if</span> ((first = tab[i = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//如果是红黑树就在树中查找key，对应node用old标记</span></span><br><span class="line">        <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            old = (t = (TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//遍历链表，用old标记找到的node</span></span><br><span class="line">            Node&lt;K,V&gt; e = first; K k;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                    old = e;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ++binCount;<span class="comment">//统计链表长度，用于判断是否需要树形化</span></span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    V oldValue = (old == <span class="keyword">null</span>) ? <span class="keyword">null</span> : old.value;</span><br><span class="line">    <span class="comment">//计算新value</span></span><br><span class="line">    V v = remappingFunction.apply(key, oldValue);</span><br><span class="line">    <span class="keyword">if</span> (old != <span class="keyword">null</span>) &#123;<span class="comment">//对应的key存在</span></span><br><span class="line">        <span class="keyword">if</span> (v != <span class="keyword">null</span>) &#123;<span class="comment">//如果新value不为null则替换成新value</span></span><br><span class="line">            old.value = v;</span><br><span class="line">            afterNodeAccess(old);<span class="comment">//Do nothing</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//否则删除key对应的旧节点</span></span><br><span class="line">            removeNode(hash, key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (v != <span class="keyword">null</span>) &#123; <span class="comment">//如果新value不为null，且key不存在，则添加新节点</span></span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>)<span class="comment">//如果是树型结构就在树中添加新节点</span></span><br><span class="line">            t.putTreeVal(<span class="keyword">this</span>, tab, hash, key, v);</span><br><span class="line">        <span class="keyword">else</span> &#123;<span class="comment">//否则就在链表头部添加新节点</span></span><br><span class="line">            tab[i] = newNode(hash, key, v, first);</span><br><span class="line">            <span class="comment">//如果需要树形化就开始树形化操作</span></span><br><span class="line">            <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>)</span><br><span class="line">                treeifyBin(tab, hash);</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        ++size;<span class="comment">//插入新节点size+1</span></span><br><span class="line">        afterNodeInsertion(<span class="keyword">true</span>);<span class="comment">//Do nothing</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></li></ol><p></p><ol start="9"><li>合并两个key一样的value，新值生成函数<code>(oldV, newV) -&gt; {}</code>，用生成的新值去替换旧值<br><details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意：只有old value不为null才去调用这个函数，否则直接插入新value</span></span><br><span class="line"><span class="comment">//Stream中toMap会用到，一般解决key冲突</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">merge</span><span class="params">(K key, V value,</span></span></span><br><span class="line"><span class="function"><span class="params">    BiFunction&lt;? <span class="keyword">super</span> V, ? <span class="keyword">super</span> V, ? extends V&gt; remappingFunction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">if</span> (remappingFunction == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    TreeNode&lt;K,V&gt; t = <span class="keyword">null</span>;</span><br><span class="line">    Node&lt;K,V&gt; old = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &gt; threshold || (tab = table) == <span class="keyword">null</span> ||</span><br><span class="line">        (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="keyword">if</span> ((first = tab[i = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            old = (t = (TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;K,V&gt; e = first; K k;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                    old = e;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ++binCount;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (old != <span class="keyword">null</span>) &#123;</span><br><span class="line">        V v;</span><br><span class="line">        <span class="keyword">if</span> (old.value != <span class="keyword">null</span>)</span><br><span class="line">            v = remappingFunction.apply(old.value, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            v = value;</span><br><span class="line">        <span class="keyword">if</span> (v != <span class="keyword">null</span>) &#123;</span><br><span class="line">            old.value = v;</span><br><span class="line">            afterNodeAccess(old);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            removeNode(hash, key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>)</span><br><span class="line">            t.putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tab[i] = newNode(hash, key, value, first);</span><br><span class="line">            <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>)</span><br><span class="line">                treeifyBin(tab, hash);</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        ++size;</span><br><span class="line">        afterNodeInsertion(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></li></ol><p></p><ol start="10"><li>用给定的consumer循环处理每个key-value pair<br><details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(BiConsumer&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V&gt; action)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab;</span><br><span class="line">    <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; (tab = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> mc = modCount;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next)</span><br><span class="line">                action.accept(e.key, e.value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果中间发生过修改则快速失败，并抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></li></ol><p></p><ol start="11"><li>用给定的函数<code>(k,v)-&gt;{}</code>生成一个新值，并用新值替换旧值，这个操作作用于所有元素<br><details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">replaceAll</span><span class="params">(BiFunction&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V, ? extends V&gt; function)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab;</span><br><span class="line">    <span class="keyword">if</span> (function == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; (tab = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> mc = modCount;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                e.value = function.apply(e.key, e.value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (modCount != mc)<span class="comment">//线程安全检查</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></li></ol><p></p><h1 id="三、-红黑树相关操作"><a href="#三、-红黑树相关操作" class="headerlink" title="三、 红黑树相关操作"></a>三、 红黑树相关操作</h1><ol><li>红黑树节点定义（仅含构造方法）<br><details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TreeNode定义，从Node上继承了key, value和next相关成员</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">    TreeNode&lt;K,V&gt; left;</span><br><span class="line">    TreeNode&lt;K,V&gt; right;</span><br><span class="line">    TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">    <span class="keyword">boolean</span> red;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, val, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></li></ol><p></p><ol start="2"><li>找到当前树的root节点<br><details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">root</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//从当前节点向前，一直到parent为null的节点就是root节点</span></span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; r = <span class="keyword">this</span>, p;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((p = r.parent) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        r = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></li></ol><p></p><ol start="3"><li>将root节点放到该hash地址的首个节点位置上<br><details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function"><span class="keyword">void</span> <span class="title">moveRootToFront</span><span class="params">(Node&lt;K,V&gt;[] tab, TreeNode&lt;K,V&gt; root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span> &amp;&amp; tab != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = (n - <span class="number">1</span>) &amp; root.hash;<span class="comment">//首个节点地址</span></span><br><span class="line">        TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index];</span><br><span class="line">        <span class="comment">//如果首个节点不是root节点，就把root节点提到首位</span></span><br><span class="line">        <span class="keyword">if</span> (root != first) &#123;</span><br><span class="line">            Node&lt;K,V&gt; rn;</span><br><span class="line">            tab[index] = root;<span class="comment">//地址节点直接指向root</span></span><br><span class="line">            TreeNode&lt;K,V&gt; rp = root.prev; <span class="comment">//rp:root之前的部分</span></span><br><span class="line">            <span class="keyword">if</span> ((rn = root.next) != <span class="keyword">null</span>) <span class="comment">//rn:root之后的部分</span></span><br><span class="line">                <span class="comment">//root之后的部分pre直接与root之前的部分相连</span></span><br><span class="line">                ((TreeNode&lt;K,V&gt;)rn).prev = rp;</span><br><span class="line">            <span class="keyword">if</span> (rp != <span class="keyword">null</span>)</span><br><span class="line">                rp.next = rn; <span class="comment">//root之前的部分next直接与root之后的部分相连</span></span><br><span class="line">            <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">                first.prev = root; <span class="comment">//first与root相连</span></span><br><span class="line">            root.next = first;</span><br><span class="line">            root.prev = <span class="keyword">null</span>;<span class="comment">//root前驱节点为null</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">checkInvariants</span><span class="params">(root)</span></span>;<span class="comment">//检查红黑树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></li></ol><p></p><ol start="4"><li>从当前节点查找key对应的Node<br><details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//从当前节点查找key，kc缓存了key的class，如果key.class是Comparable的，否则为null</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">find</span><span class="params">(<span class="keyword">int</span> h, Object k, Class&lt;?&gt; kc)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; p = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> ph, dir; K pk;</span><br><span class="line">        TreeNode&lt;K,V&gt; pl = p.left, pr = p.right, q;</span><br><span class="line">        <span class="comment">//如果查找的hash key小于当前hash key，就转向左子树查找</span></span><br><span class="line">        <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">            p = pl;</span><br><span class="line">        <span class="comment">//如果查找的hash key大于当前hash key，就转向右子树查找</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">            p = pr;</span><br><span class="line">        <span class="comment">//hash一致，key一致就表示找到了，直接返回该节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        <span class="comment">//hash一致，key不一致，且左子树为空，直接转向右子树（只可能在右子树）</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pl == <span class="keyword">null</span>)</span><br><span class="line">            p = pr;</span><br><span class="line">        <span class="comment">//hash一致，key不一致，且右子树为空，直接转向左子树（只可能在左子树）</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pr == <span class="keyword">null</span>)</span><br><span class="line">            p = pl;</span><br><span class="line">        <span class="comment">//hash一致，key不一致，且右子树都不为空，但key是可比较的，并且能比较出大小</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((kc != <span class="keyword">null</span> ||</span><br><span class="line">                  (kc = comparableClassFor(k)) != <span class="keyword">null</span>) &amp;&amp;</span><br><span class="line">                 (dir = compareComparables(kc, k, pk)) != <span class="number">0</span>)</span><br><span class="line">            p = (dir &lt; <span class="number">0</span>) ? pl : pr;<span class="comment">//根据key的比较结果决定去那个子树搜索</span></span><br><span class="line">        <span class="comment">//hash一致，key不一致，且右子树都不为空，且key不可比较或无法比较出大小</span></span><br><span class="line">        <span class="comment">//先搜索右子树，如果在右子树中找到key，就返回对应node</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((q = pr.find(h, k, kc)) != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> q;</span><br><span class="line">        <span class="comment">//右子树没找到，接着遍历左子树（为什么不用tieBreakOrder确定查左子树还是右子树？）</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p = pl;</span><br><span class="line">    &#125; <span class="keyword">while</span> (p != <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></li></ol><p></p><ol start="5"><li>从root节点开始查询某个key，就是正常的查询<br><details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">getTreeNode</span><span class="params">(<span class="keyword">int</span> h, Object k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((parent != <span class="keyword">null</span>) ? root() : <span class="keyword">this</span>).find(h, k, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></li></ol><p></p><ol start="6"><li><p>深层次比较两个key的大小，调用这个方法就表示发生了<strong>hash碰撞</strong></p><p>注意：<strong>hash碰撞</strong>与<strong>hash地址碰撞</strong>不是一个概念，hash碰撞是指两个key算出来的hash一样，hash碰撞必定会发生hash地址碰撞，但hash地址(hash&amp;(n-1))碰撞只是低x位碰撞，不代表整个hash值一样<br><details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当key的hash值一致(hash碰撞)，且key不可比较时，identityHashCode进行比较，null的hash为0</span></span><br><span class="line"><span class="comment">//identityHashCode总是调用Object实现的hashCode，xx.hashCode是调用重写后的hashCode</span></span><br><span class="line"><span class="comment">//注意：identityHashCode也可能会重复，但概率相当小。</span></span><br><span class="line"><span class="comment">//这里的比较结果分为-1和1，0归到-1里面，所以元素的相对顺序就无法保证了，但没有关系</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">tieBreakOrder</span><span class="params">(Object a, Object b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> d;</span><br><span class="line"><span class="comment">//a或b其中一个是null，或a、b的类型是一样的时候才可比较</span></span><br><span class="line"><span class="keyword">if</span> (a == <span class="keyword">null</span> || b == <span class="keyword">null</span> ||</span><br><span class="line">(d = a.getClass().getName().</span><br><span class="line">compareTo(b.getClass().getName())) == <span class="number">0</span>)</span><br><span class="line">d = (System.identityHashCode(a) &lt;= System.identityHashCode(b) ?</span><br><span class="line">-<span class="number">1</span> : <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></p></li></ol><p></p><ol start="7"><li>树形化操作（以当前节点为root节点）,一般在链表首节点调用该方法<br><details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//树形化</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeify</span><span class="params">(Node&lt;K,V&gt;[] tab)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; root = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//这里的this实际就是链表的首节点，遍历链表</span></span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; x = <span class="keyword">this</span>, next; x != <span class="keyword">null</span>; x = next) &#123;</span><br><span class="line">        next = (TreeNode&lt;K,V&gt;)x.next;</span><br><span class="line">        x.left = x.right = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//初始化root节点</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            x.parent = <span class="keyword">null</span>;</span><br><span class="line">            x.red = <span class="keyword">false</span>;<span class="comment">//root节点为黑色</span></span><br><span class="line">            root = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            K k = x.key;</span><br><span class="line">            <span class="keyword">int</span> h = x.hash;</span><br><span class="line">            Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//一直遍历，直到找到一个可插入的位置（可插入叶子节点）</span></span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> dir, ph;</span><br><span class="line">                K pk = p.key;</span><br><span class="line">                <span class="comment">//h &lt; ph 走左边</span></span><br><span class="line">                <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                    dir = -<span class="number">1</span>;</span><br><span class="line">                <span class="comment">//h &gt; ph 走右边</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                    dir = <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//h == ph，且(key不可比较，或key比较结果无法区分大小)</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                          (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                         (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>)</span><br><span class="line">                    <span class="comment">//采用identify hashcode再次比较(0和-1合并为-1)</span></span><br><span class="line">                    dir = tieBreakOrder(k, pk);</span><br><span class="line"></span><br><span class="line">                TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">                <span class="comment">//如果x已经到达可以插入的位置，就插入x节点</span></span><br><span class="line">                <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    x.parent = xp;</span><br><span class="line">                    <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                        xp.left = x;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        xp.right = x;</span><br><span class="line">                    <span class="comment">//重新平衡红黑树</span></span><br><span class="line">                    root = balanceInsertion(root, x);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//否则继续查找能插入的位置</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重新平衡树后root节点可能发生了变化，需要重新将叶子节点放到首个节点的位置</span></span><br><span class="line">    moveRootToFront(tab, root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></li></ol><p></p><ol start="8"><li>解树形化（红黑树转换为链表）<br><details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">untreeify</span><span class="params">(HashMap&lt;K,V&gt; map)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt; q = <span class="keyword">this</span>; q != <span class="keyword">null</span>; q = q.next) &#123;</span><br><span class="line">        Node&lt;K,V&gt; p = map.replacementNode(q, <span class="keyword">null</span>);<span class="comment">//节点类型替换一下就可以了</span></span><br><span class="line">        <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">            hd = p;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            tl.next = p;</span><br><span class="line">        tl = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></li></ol><p></p><ol start="9"><li>在树中插入一个节点<br><details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">putTreeVal</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[]tab,<span class="keyword">int</span> h, K k, V v)</span> </span>&#123;</span><br><span class="line">     Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">     <span class="keyword">boolean</span> searched = <span class="keyword">false</span>;</span><br><span class="line">     TreeNode&lt;K,V&gt; root = (parent != <span class="keyword">null</span>) ? root() : <span class="keyword">this</span>;</span><br><span class="line">     <span class="comment">//从root开始遍历，如果key已存在就返回相关节点，否则找到一个合适位置新增一个节点，</span></span><br><span class="line">     <span class="comment">//使得新增节点是叶子节点</span></span><br><span class="line">     <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">         <span class="keyword">int</span> dir, ph; K pk;</span><br><span class="line">         <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">             dir = -<span class="number">1</span>;</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">             dir = <span class="number">1</span>;</span><br><span class="line">         <span class="comment">//key已经存在直接返回，上层方法统一替换value</span></span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">             <span class="keyword">return</span> p;</span><br><span class="line">         <span class="comment">//ph==h 并且key不可比较或无法比较出大小</span></span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                   (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                  (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>) &#123;</span><br><span class="line">             <span class="comment">//搜索左子树&amp;右子树</span></span><br><span class="line">             <span class="keyword">if</span> (!searched) &#123;</span><br><span class="line">                 TreeNode&lt;K,V&gt; q, ch;</span><br><span class="line">                 <span class="comment">//左右子树只需要搜索一次，后续遍历其他节点无需再搜索它们的子树</span></span><br><span class="line">                 searched = <span class="keyword">true</span>;</span><br><span class="line">                 <span class="keyword">if</span> (((ch = p.left) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                      (q = ch.find(h, k, kc)) != <span class="keyword">null</span>) ||</span><br><span class="line">                     ((ch = p.right) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                      (q = ch.find(h, k, kc)) != <span class="keyword">null</span>))</span><br><span class="line">                     <span class="keyword">return</span> q;<span class="comment">//只要找到了key就直接返回</span></span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">//左右子树没找到，准备新追加一个节点，现在判断追加到左子树还是右子树</span></span><br><span class="line">             dir = tieBreakOrder(k, pk);</span><br><span class="line">         &#125;<span class="comment">//if</span></span><br><span class="line"></span><br><span class="line">         <span class="comment">//追加新节点</span></span><br><span class="line">         TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">         <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">             Node&lt;K,V&gt; xpn = xp.next;<span class="comment">//注意这里在进行树的追加操作时仍然保留了双向链表的特性</span></span><br><span class="line">             TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn);</span><br><span class="line">             <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                 xp.left = x;</span><br><span class="line">             <span class="keyword">else</span></span><br><span class="line">                 xp.right = x;</span><br><span class="line">             xp.next = x;</span><br><span class="line">             x.parent = x.prev = xp;</span><br><span class="line">             <span class="keyword">if</span> (xpn != <span class="keyword">null</span>)</span><br><span class="line">                 ((TreeNode&lt;K,V&gt;)xpn).prev = x;</span><br><span class="line">             <span class="comment">//重新平衡树并调整node到首个节点</span></span><br><span class="line">             moveRootToFront(tab, balanceInsertion(root, x));</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></details></li></ol><p></p><ol start="10"><li>移除当前节点<br><details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意：HashMap红黑树具有双向链表和树的两种特性，都要进行调整</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">removeTreeNode</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> index = (n - <span class="number">1</span>) &amp; hash;</span><br><span class="line">    TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index], root = first, rl;</span><br><span class="line">    <span class="comment">//succ为当前节点的后置节点， perd为前驱节点</span></span><br><span class="line">    TreeNode&lt;K,V&gt; succ = (TreeNode&lt;K,V&gt;)next, pred = prev;</span><br><span class="line">    <span class="comment">//如果前驱节点不存在(删除的是root节点)</span></span><br><span class="line">    <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">        tab[index] = first = succ; <span class="comment">//first直接指向root后置节点即可</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pred.next = succ; <span class="comment">//否则前驱节点与后置节点相连即可</span></span><br><span class="line">    <span class="keyword">if</span> (succ != <span class="keyword">null</span>) <span class="comment">//关联prev指针</span></span><br><span class="line">        succ.prev = pred;</span><br><span class="line">    <span class="keyword">if</span> (first == <span class="keyword">null</span>)<span class="comment">//删除的节点不存在</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (root.parent != <span class="keyword">null</span>) </span><br><span class="line">        root = root.root();<span class="comment">//重新找root节点</span></span><br><span class="line">    <span class="comment">//如果root为null或者(允许移动节点，并且左子树或右子树为null)，就转换为链表</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span> || (movable &amp;&amp; (root.right == <span class="keyword">null</span></span><br><span class="line">                                     || (rl = root.left) == <span class="keyword">null</span></span><br><span class="line">                                     || rl.left == <span class="keyword">null</span>))) &#123;</span><br><span class="line">        tab[index] = first.untreeify(map);  <span class="comment">// too small</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//截至到这里，只是调整了作为双向链表的那一部分指针，作为树的相关内容还未进行调整</span></span><br><span class="line">    <span class="comment">//进行红黑树的删除操作，红黑树删除操作分3中情况</span></span><br><span class="line">    TreeNode&lt;K,V&gt; p = <span class="keyword">this</span>, pl = left, pr = right, replacement;</span><br><span class="line">    <span class="comment">//情况1：删除节点左右子树不为null，用后继结点（大于删除结点的最小结点）替换删除结点</span></span><br><span class="line">    <span class="keyword">if</span> (pl != <span class="keyword">null</span> &amp;&amp; pr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; s = pr, sl; <span class="comment">//s是右子节点</span></span><br><span class="line">        <span class="comment">//找到删除节点的后继节点(右子树的最左边叶子节点)</span></span><br><span class="line">        <span class="keyword">while</span> ((sl = s.left) != <span class="keyword">null</span>) <span class="comment">// find successor</span></span><br><span class="line">            s = sl;<span class="comment">//s就是后继节点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//交换s和p的颜色</span></span><br><span class="line">        <span class="keyword">boolean</span> c = s.red; s.red = p.red; p.red = c; <span class="comment">// swap colors</span></span><br><span class="line">        TreeNode&lt;K,V&gt; sr = s.right;</span><br><span class="line">        TreeNode&lt;K,V&gt; pp = p.parent;</span><br><span class="line">        <span class="comment">//s是待删除节点的右子节点，把当前节点挂到s的右子节点（互换位置）</span></span><br><span class="line">        <span class="keyword">if</span> (s == pr) &#123; <span class="comment">// p was s's direct parent（p的右子节点无左子节点）</span></span><br><span class="line">            p.parent = s;</span><br><span class="line">            s.right = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; sp = s.parent;</span><br><span class="line">            <span class="comment">//还是互换s和p的位置，设置部分其他属性</span></span><br><span class="line">            <span class="comment">//如果s是左子节点就把p放到sp的左子节点上，反之亦然</span></span><br><span class="line">            <span class="keyword">if</span> ((p.parent = sp) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s == sp.left)</span><br><span class="line">                    sp.left = p;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    sp.right = p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//s的右子节点指向p的右子节点，p右子节点父指针指向s</span></span><br><span class="line">            <span class="keyword">if</span> ((s.right = pr) != <span class="keyword">null</span>)</span><br><span class="line">                pr.parent = s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//修补s和p交换后断开的节点(pl, pp, sr, root)</span></span><br><span class="line">        p.left = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//p.right = sr;</span></span><br><span class="line">        <span class="keyword">if</span> ((p.right = sr) != <span class="keyword">null</span>)</span><br><span class="line">            sr.parent = p;</span><br><span class="line">        <span class="comment">//s.left = pl; </span></span><br><span class="line">        <span class="keyword">if</span> ((s.left = pl) != <span class="keyword">null</span>)</span><br><span class="line">            pl.parent = s;</span><br><span class="line">        <span class="keyword">if</span> ((s.parent = pp) == <span class="keyword">null</span>)</span><br><span class="line">            root = s; <span class="comment">//s是root</span></span><br><span class="line">        <span class="comment">// s.parent = pp;</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">            pp.left = s;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pp.right = s;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//现在sr已经放到p.right,p.left已经是null了，要删除p，还要处理p.right</span></span><br><span class="line">        <span class="comment">//这里用replacement来填充被删除节点的位置</span></span><br><span class="line">        <span class="keyword">if</span> (sr != <span class="keyword">null</span>)</span><br><span class="line">            replacement = sr;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            replacement = p;<span class="comment">//临时的，p是要删除的</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//情况2：删除节点只有左子节点，直接用左子节点替换待删除节点即可</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pl != <span class="keyword">null</span>)</span><br><span class="line">        replacement = pl;</span><br><span class="line">    <span class="comment">//情况3：删除节点只有左子节点，直接用左子节点替换待删除节点即可</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pr != <span class="keyword">null</span>)</span><br><span class="line">        replacement = pr;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        replacement = p;<span class="comment">//临时的</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果用于替换p位置的内容是有效的(不是p)，就用replacement代替p的位置（真正的删除操作）</span></span><br><span class="line">    <span class="keyword">if</span> (replacement != p) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; pp = replacement.parent = p.parent;</span><br><span class="line">        <span class="keyword">if</span> (pp == <span class="keyword">null</span>)</span><br><span class="line">            root = replacement;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">            pp.left = replacement;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pp.right = replacement;</span><br><span class="line">        p.left = p.right = p.parent = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//考虑替换节点s的颜色(前面和p交换过了，这里用p判断)</span></span><br><span class="line">    <span class="comment">//如果是红色，则不影响树的平衡，直接结束</span></span><br><span class="line">    <span class="comment">//如果是黑色，则需要重新平衡红黑树（这里是整个红黑树删除最复杂的地方）</span></span><br><span class="line">    <span class="comment">//这里返回的r就是新选出来的root节点</span></span><br><span class="line">    TreeNode&lt;K,V&gt; r = p.red ? root : balanceDeletion(root, replacement);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果p无子节点，直接与pp解挂即可</span></span><br><span class="line">    <span class="keyword">if</span> (replacement == p) &#123;  <span class="comment">// detach</span></span><br><span class="line">        TreeNode&lt;K,V&gt; pp = p.parent;</span><br><span class="line">        p.parent = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (pp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">                pp.left = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.right)</span><br><span class="line">                pp.right = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将root放到首节点位置</span></span><br><span class="line">    <span class="keyword">if</span> (movable)</span><br><span class="line">        moveRootToFront(tab, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></li></ol><p></p><ol start="11"><li>红黑树的分裂，仅仅会发生在table扩容时，红黑树进行rehash的过程<br><details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> index, <span class="keyword">int</span> bit)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; b = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// 这里的lo就是低地址未，也就是原位置，hi表示高位置，也就是新地址</span></span><br><span class="line">    <span class="comment">// 由于地址的算法特性，一个旧地址上的节点只可能对应一个新地址</span></span><br><span class="line">    TreeNode&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">    TreeNode&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//遍历整个链表（别忘了红黑树仍保留了双向链表的特性），将一个链表拆成两个链表</span></span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; e = b, next; e != <span class="keyword">null</span>; e = next) &#123;</span><br><span class="line">        next = (TreeNode&lt;K,V&gt;)e.next;</span><br><span class="line">        e.next = <span class="keyword">null</span>;<span class="comment">//与下游解挂</span></span><br><span class="line">        <span class="comment">//需要留在原地的节点</span></span><br><span class="line">        <span class="keyword">if</span> ((e.hash &amp; bit) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                loHead = e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                loTail.next = e;</span><br><span class="line">            loTail = e;</span><br><span class="line">            ++lc;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//需要迁移到新地址的节点</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                hiHead = e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                hiTail.next = e;</span><br><span class="line">            hiTail = e;</span><br><span class="line">            ++hc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果留在原地的链表不为空</span></span><br><span class="line">    <span class="keyword">if</span> (loHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//如果节点数小于树形化阈值，就转换为链表</span></span><br><span class="line">        <span class="keyword">if</span> (lc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">            tab[index] = loHead.untreeify(map);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tab[index] = loHead;</span><br><span class="line">            <span class="comment">//如果有拆分出去的节点，那么留下来的就需要重新树形化</span></span><br><span class="line">            <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) <span class="comment">//hi不为null就表示有拆分出去的节点</span></span><br><span class="line">                loHead.treeify(tab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果新拆分出来的链表不为空，处理方式与lo一致</span></span><br><span class="line">    <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">            tab[index + bit] = hiHead.untreeify(map);<span class="comment">//注意hi地址的计算方式</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tab[index + bit] = hiHead;</span><br><span class="line">            <span class="keyword">if</span> (loHead != <span class="keyword">null</span>)</span><br><span class="line">                hiHead.treeify(tab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></li></ol><p></p><ol start="12"><li>红黑树左旋<br><details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">rotateLeft</span><span class="params">(TreeNode&lt;K,V&gt; root, TreeNode&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; r, pp, rl;</span><br><span class="line">    <span class="comment">//p不为空，p的右子节点(r)不为空，左旋才有意义</span></span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span> &amp;&amp; (r = p.right) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//p的右子节点连接r的左子节点</span></span><br><span class="line">        <span class="keyword">if</span> ((rl = p.right = r.left) != <span class="keyword">null</span>)</span><br><span class="line">            rl.parent = p;</span><br><span class="line">        <span class="comment">//如果p是root，则旋转后r是root，颜色为黑色</span></span><br><span class="line">        <span class="keyword">if</span> ((pp = r.parent = p.parent) == <span class="keyword">null</span>)</span><br><span class="line">            (root = r).red = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//否则，r挂到p的parent(pp)下</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pp.left == p)</span><br><span class="line">            pp.left = r;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pp.right = r;</span><br><span class="line">        <span class="comment">//p成为r的左子节点</span></span><br><span class="line">        r.left = p;</span><br><span class="line">        p.parent = r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></li></ol><p></p><ol start="13"><li>红黑树右旋<br><details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">rotateRight</span><span class="params">(TreeNode&lt;K,V&gt; root, TreeNode&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; l, pp, lr;</span><br><span class="line">    <span class="comment">//l为p的左子节点</span></span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span> &amp;&amp; (l = p.left) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//l的右子节点挂载到p的左子节点位置</span></span><br><span class="line">        <span class="keyword">if</span> ((lr = p.left = l.right) != <span class="keyword">null</span>)</span><br><span class="line">            lr.parent = p;</span><br><span class="line">        <span class="comment">//如果p是root节点，旋转后l是root节点</span></span><br><span class="line">        <span class="keyword">if</span> ((pp = l.parent = p.parent) == <span class="keyword">null</span>)</span><br><span class="line">            (root = l).red = <span class="keyword">false</span>;<span class="comment">//root为黑色</span></span><br><span class="line">        <span class="comment">//否则将l挂载到pp下</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pp.right == p)</span><br><span class="line">            pp.right = l;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pp.left = l;</span><br><span class="line">        <span class="comment">//p成为l的右子节点</span></span><br><span class="line">        l.right = p;</span><br><span class="line">        p.parent = l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></li></ol><p></p><ol start="14"><li>平衡插入操作<br><details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">balanceInsertion</span><span class="params">(TreeNode&lt;K,V&gt; root, TreeNode&lt;K,V&gt; x)</span></span>&#123;</span><br><span class="line">     x.red = <span class="keyword">true</span>;<span class="comment">//新插入的节点为红色</span></span><br><span class="line">     <span class="comment">//一直重复操作，直到红黑树平衡</span></span><br><span class="line">     <span class="keyword">for</span> (TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) &#123;</span><br><span class="line">         <span class="comment">//如果插入的节点就是root</span></span><br><span class="line">         <span class="keyword">if</span> ((xp = x.parent) == <span class="keyword">null</span>) &#123;</span><br><span class="line">             x.red = <span class="keyword">false</span>;<span class="comment">//root为黑色</span></span><br><span class="line">             <span class="keyword">return</span> x;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//如果插入的节点的父节点为黑节点，或父节点是root则无需调整，直接返回</span></span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (!xp.red || (xpp = xp.parent) == <span class="keyword">null</span>)</span><br><span class="line">             <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">         <span class="comment">//如果父节点(xp)是红节点，且父节点是祖父节点(xpp)的左子节点(xppl)</span></span><br><span class="line">         <span class="keyword">if</span> (xp == (xppl = xpp.left)) &#123;</span><br><span class="line">             <span class="comment">//如果叔叔节点(父节点的兄弟节点xppr)存在且为红色</span></span><br><span class="line">             <span class="keyword">if</span> ((xppr = xpp.right) != <span class="keyword">null</span> &amp;&amp; xppr.red) &#123;</span><br><span class="line">                 xppr.red = <span class="keyword">false</span> <span class="comment">//叔叔节点为黑色</span></span><br><span class="line">                     xp.red = <span class="keyword">false</span>;  <span class="comment">//父节点为黑色</span></span><br><span class="line">                 xpp.red = <span class="keyword">true</span>;  <span class="comment">//祖父节点为红色</span></span><br><span class="line">                 x = xpp; <span class="comment">//将祖父节点设为插入节点，继续进行插入平衡操作</span></span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">//叔叔节点不存在或为黑色</span></span><br><span class="line">             <span class="keyword">else</span> &#123;</span><br><span class="line">                 <span class="comment">//插入节点是其父节点的右子节点</span></span><br><span class="line">                 <span class="keyword">if</span> (x == xp.right) &#123;</span><br><span class="line">                     <span class="comment">//对插入节点的父节点进行左旋</span></span><br><span class="line">                     root = rotateLeft(root, x = xp);</span><br><span class="line">                     xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent;</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="comment">//插入节点是左子节点就无需旋转</span></span><br><span class="line">                 <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                     xp.red = <span class="keyword">false</span>;<span class="comment">//父节点设为黑色</span></span><br><span class="line">                     <span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                         xpp.red = <span class="keyword">true</span>;<span class="comment">//祖父节点为红色</span></span><br><span class="line">                         <span class="comment">//对祖父节点进行右旋</span></span><br><span class="line">                         root = rotateRight(root, xpp);</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//如果父节点(xp)是红节点，且父节点是祖父节点(xpp)的右子节点(xppr)</span></span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="comment">//叔叔节点存在且为红色</span></span><br><span class="line">             <span class="keyword">if</span> (xppl != <span class="keyword">null</span> &amp;&amp; xppl.red) &#123;</span><br><span class="line">                 xppl.red = <span class="keyword">false</span>; <span class="comment">//叔叔节点为黑色</span></span><br><span class="line">                 xp.red = <span class="keyword">false</span>;   <span class="comment">//父节点为黑色</span></span><br><span class="line">                 xpp.red = <span class="keyword">true</span>;   <span class="comment">//祖父节点为红色</span></span><br><span class="line">                 x = xpp; <span class="comment">//将祖父节点设为插入节点，继续进行插入平衡操作</span></span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">//叔叔节点不存在或为黑色</span></span><br><span class="line">             <span class="keyword">else</span> &#123;</span><br><span class="line">                 <span class="comment">//插入节点是其父节点的左子节点</span></span><br><span class="line">                 <span class="keyword">if</span> (x == xp.left) &#123;</span><br><span class="line">                     <span class="comment">//将父节点进行右旋,然后进行下面操作</span></span><br><span class="line">                     root = rotateRight(root, x = xp);</span><br><span class="line">                     xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent;</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                     <span class="comment">//父节点为黑色</span></span><br><span class="line">                     xp.red = <span class="keyword">false</span>;</span><br><span class="line">                     <span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                         xpp.red = <span class="keyword">true</span>;<span class="comment">//祖父节点为红色</span></span><br><span class="line">                         <span class="comment">//对祖父节点进行左旋</span></span><br><span class="line">                         root = rotateLeft(root, xpp);</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></details></li></ol><p></p><ol start="15"><li>平衡删除操作<br><details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">balanceDeletion</span><span class="params">(TreeNode&lt;K,V&gt; root,TreeNode&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//一直平衡，直到平衡为止</span></span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; xp, xpl, xpr;;) &#123;</span><br><span class="line">        <span class="comment">//如果替换节点就是root或者null，直接返回root</span></span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span> || x == root)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果日换节点是root节点，颜色设置为黑色，返回替换节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((xp = x.parent) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            x.red = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果替换节点是红色</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x.red) &#123;</span><br><span class="line">            x.red = <span class="keyword">false</span>; <span class="comment">//颜色设置为黑色</span></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//替换节点是黑节点，且替换节点使其父节点的左子节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((xpl = xp.left) == x) &#123;</span><br><span class="line">            <span class="comment">//替换节点的兄弟节点(xpr)是红节点</span></span><br><span class="line">            <span class="keyword">if</span> ((xpr = xp.right) != <span class="keyword">null</span> &amp;&amp; xpr.red) &#123;</span><br><span class="line">                xpr.red = <span class="keyword">false</span>; <span class="comment">//兄弟设为黑色</span></span><br><span class="line">                xp.red = <span class="keyword">true</span>;   <span class="comment">//父节点设为红色</span></span><br><span class="line">                root = rotateLeft(root, xp); <span class="comment">//将P节点左旋</span></span><br><span class="line">                xpr = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果兄弟节点为null，将父节点当作替换节点重新进行平衡操作</span></span><br><span class="line">            <span class="keyword">if</span> (xpr == <span class="keyword">null</span>)</span><br><span class="line">                x = xp;</span><br><span class="line">            <span class="comment">//兄弟节点存在，且为黑色</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; sl = xpr.left, sr = xpr.right;</span><br><span class="line">                <span class="comment">//兄弟节点的子节点都为黑节点</span></span><br><span class="line">                <span class="keyword">if</span> ((sr == <span class="keyword">null</span> || !sr.red) &amp;&amp;</span><br><span class="line">                    (sl == <span class="keyword">null</span> || !sl.red)) &#123;</span><br><span class="line">                    xpr.red = <span class="keyword">true</span>; <span class="comment">// 兄弟节点设为红色</span></span><br><span class="line">                    x = xp; <span class="comment">//将父节点当作替换节点重新进行平衡操作</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//如果兄弟节点的右子节点为黑色（左子节点为红色）</span></span><br><span class="line">                    <span class="keyword">if</span> (sr == <span class="keyword">null</span> || !sr.red) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (sl != <span class="keyword">null</span>)</span><br><span class="line">                            sl.red = <span class="keyword">false</span>; <span class="comment">//兄弟节点的左子节点设为黑色</span></span><br><span class="line">                        xpr.red = <span class="keyword">true</span>;     <span class="comment">//兄弟节点设为红色</span></span><br><span class="line">                        root = rotateRight(root, xpr); <span class="comment">//对兄弟节点进行右旋</span></span><br><span class="line">                        xpr = (xp = x.parent) == <span class="keyword">null</span> ?</span><br><span class="line">                            <span class="keyword">null</span> : xp.right;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//兄弟节点的右子节点是红色，左子节点任意</span></span><br><span class="line">                    <span class="keyword">if</span> (xpr != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//兄弟节点的颜色设为父亲节点的颜色</span></span><br><span class="line">                        xpr.red = (xp == <span class="keyword">null</span>) ? <span class="keyword">false</span> : xp.red;</span><br><span class="line">                        <span class="keyword">if</span> ((sr = xpr.right) != <span class="keyword">null</span>)</span><br><span class="line">                            sr.red = <span class="keyword">false</span>;<span class="comment">//兄弟节点的右子节点设为黑色</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        xp.red = <span class="keyword">false</span>; <span class="comment">//父亲节点设为黑色</span></span><br><span class="line">                        root = rotateLeft(root, xp);<span class="comment">//对父亲节点进行左旋</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    x = root;<span class="comment">//结束平衡操作</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//替换节点是黑节点，且替换节点使其父节点的右子节点（操作与上一个IF是对称的）</span></span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// symmetric</span></span><br><span class="line">            <span class="comment">//兄弟节点存在且是红色</span></span><br><span class="line">            <span class="keyword">if</span> (xpl != <span class="keyword">null</span> &amp;&amp; xpl.red) &#123;</span><br><span class="line">                xpl.red = <span class="keyword">false</span>; <span class="comment">//兄弟节点设为黑色</span></span><br><span class="line">                xp.red = <span class="keyword">true</span>;   <span class="comment">//父节点为红色</span></span><br><span class="line">                root = rotateRight(root, xp); <span class="comment">//按父节点右旋</span></span><br><span class="line">                xpl = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//兄弟节点为空，就把父节点当作替换节点重新平衡</span></span><br><span class="line">            <span class="keyword">if</span> (xpl == <span class="keyword">null</span>)</span><br><span class="line">                x = xp;</span><br><span class="line">            <span class="comment">//兄弟节点是黑节点</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; sl = xpl.left, sr = xpl.right;</span><br><span class="line">                <span class="comment">//兄弟节点的左子节点全是黑色</span></span><br><span class="line">                <span class="keyword">if</span> ((sl == <span class="keyword">null</span> || !sl.red) &amp;&amp;</span><br><span class="line">                    (sr == <span class="keyword">null</span> || !sr.red)) &#123;</span><br><span class="line">                    xpl.red = <span class="keyword">true</span>; <span class="comment">//兄弟节点设为红色</span></span><br><span class="line">                    x = xp; <span class="comment">//父节点为替换节点重新进行平衡操作</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//兄弟节点左子节点为黑色（右子节点为红色）</span></span><br><span class="line">                    <span class="keyword">if</span> (sl == <span class="keyword">null</span> || !sl.red) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (sr != <span class="keyword">null</span>)</span><br><span class="line">                            sr.red = <span class="keyword">false</span>; <span class="comment">//兄弟节点右子节点设为黑色</span></span><br><span class="line">                        xpl.red = <span class="keyword">true</span>; <span class="comment">//兄弟节点设为红色</span></span><br><span class="line">                        root = rotateLeft(root, xpl);<span class="comment">//对兄弟节点进行左旋</span></span><br><span class="line">                        xpl = (xp = x.parent) == <span class="keyword">null</span> ?</span><br><span class="line">                            <span class="keyword">null</span> : xp.left;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//兄弟节点的左子节点是红色，右子节点任意</span></span><br><span class="line">                    <span class="keyword">if</span> (xpl != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//将兄弟节点颜色设为父节点颜色</span></span><br><span class="line">                        xpl.red = (xp == <span class="keyword">null</span>) ? <span class="keyword">false</span> : xp.red;</span><br><span class="line">                        <span class="keyword">if</span> ((sl = xpl.left) != <span class="keyword">null</span>)z</span><br><span class="line">                            sl.red = <span class="keyword">false</span>; <span class="comment">//兄弟节点左子节点设为黑色</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        xp.red = <span class="keyword">false</span>; <span class="comment">//父节点设为黑色</span></span><br><span class="line">                        root = rotateRight(root, xp); <span class="comment">//对父节点右旋</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    x = root; <span class="comment">//结束平衡操作</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></li></ol><p></p><ol start="16"><li>红黑树自检<br><details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">checkInvariants</span><span class="params">(TreeNode&lt;K,V&gt; t)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; tp = t.parent, tl = t.left, tr = t.right,</span><br><span class="line">    tb = t.prev, tn = (TreeNode&lt;K,V&gt;)t.next;</span><br><span class="line">    <span class="comment">//如果t的前驱节点的后置节点不是t，检查失败</span></span><br><span class="line">    <span class="keyword">if</span> (tb != <span class="keyword">null</span> &amp;&amp; tb.next != t)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//如果t的后置节点的前驱节点不是t，检查失败</span></span><br><span class="line">    <span class="keyword">if</span> (tn != <span class="keyword">null</span> &amp;&amp; tn.prev != t)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//如果t不是其父节点的左子节点也不是右子节点，检查失败</span></span><br><span class="line">    <span class="keyword">if</span> (tp != <span class="keyword">null</span> &amp;&amp; t != tp.left &amp;&amp; t != tp.right)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//如果t的左子节点的父亲不是t，或左子节点hash大于t的hash，检查失败</span></span><br><span class="line">    <span class="keyword">if</span> (tl != <span class="keyword">null</span> &amp;&amp; (tl.parent != t || tl.hash &gt; t.hash))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//如果t的右子节点的父亲不是t，或右子节点hash小于t的hash，检查失败</span></span><br><span class="line">    <span class="keyword">if</span> (tr != <span class="keyword">null</span> &amp;&amp; (tr.parent != t || tr.hash &lt; t.hash))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//如果t是红色但子节点还是红色，检查失败</span></span><br><span class="line">    <span class="keyword">if</span> (t.red &amp;&amp; tl != <span class="keyword">null</span> &amp;&amp; tl.red &amp;&amp; tr != <span class="keyword">null</span> &amp;&amp; tr.red)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//递归检查左子树</span></span><br><span class="line">    <span class="keyword">if</span> (tl != <span class="keyword">null</span> &amp;&amp; !checkInvariants(tl))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//递归检查右子树</span></span><br><span class="line">    <span class="keyword">if</span> (tr != <span class="keyword">null</span> &amp;&amp; !checkInvariants(tr))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></li></ol><p></p><h1 id="四、其他方法"><a href="#四、其他方法" class="headerlink" title="四、其他方法"></a>四、其他方法</h1><ol><li>Clone方法重写<br><details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//浅拷贝</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HashMap&lt;K,V&gt; result;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        result = (HashMap&lt;K,V&gt;)<span class="keyword">super</span>.clone();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">        <span class="comment">// this shouldn't happen, since we are Cloneable</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e);</span><br><span class="line">    &#125;</span><br><span class="line">    result.reinitialize();</span><br><span class="line">    result.putMapEntries(<span class="keyword">this</span>, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></li></ol><p></p><ol start="2"><li>序列化、反序列化相关方法<br><details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// These methods are also used when serializing HashSets</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">float</span> <span class="title">loadFactor</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> loadFactor; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">capacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (table != <span class="keyword">null</span>) ? table.length :</span><br><span class="line">    (threshold &gt; <span class="number">0</span>) ? threshold :</span><br><span class="line">    DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//序列化</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> buckets = capacity();</span><br><span class="line">    <span class="comment">// Write out the threshold, loadfactor, and any hidden stuff</span></span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line">    s.writeInt(buckets);</span><br><span class="line">    s.writeInt(size);</span><br><span class="line">    internalWriteEntries(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//反序列化</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="comment">// Read in the threshold (ignored), loadfactor, and any hidden stuff</span></span><br><span class="line">    s.defaultReadObject();</span><br><span class="line">    reinitialize();</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                         loadFactor);</span><br><span class="line">    s.readInt();                <span class="comment">// Read and ignore number of buckets</span></span><br><span class="line">    <span class="keyword">int</span> mappings = s.readInt(); <span class="comment">// Read number of mappings (size)</span></span><br><span class="line">    <span class="keyword">if</span> (mappings &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(<span class="string">"Illegal mappings count: "</span> +</span><br><span class="line">                                         mappings);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (mappings &gt; <span class="number">0</span>) &#123; <span class="comment">// (if zero, use defaults)</span></span><br><span class="line">        <span class="comment">// Size the table using given load factor only if within</span></span><br><span class="line">        <span class="comment">// range of 0.25...4.0</span></span><br><span class="line">        <span class="keyword">float</span> lf = Math.min(Math.max(<span class="number">0.25f</span>, loadFactor), <span class="number">4.0f</span>);</span><br><span class="line">        <span class="keyword">float</span> fc = (<span class="keyword">float</span>)mappings / lf + <span class="number">1.0f</span>;</span><br><span class="line">        <span class="keyword">int</span> cap = ((fc &lt; DEFAULT_INITIAL_CAPACITY) ?</span><br><span class="line">                   DEFAULT_INITIAL_CAPACITY :</span><br><span class="line">                   (fc &gt;= MAXIMUM_CAPACITY) ?</span><br><span class="line">                   MAXIMUM_CAPACITY :</span><br><span class="line">                   tableSizeFor((<span class="keyword">int</span>)fc));</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)cap * lf;</span><br><span class="line">        threshold = ((cap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; MAXIMUM_CAPACITY) ?</span><br><span class="line">                     (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check Map.Entry[].class since it's the nearest public type to</span></span><br><span class="line">        <span class="comment">// what we're actually creating.</span></span><br><span class="line">        SharedSecrets.getJavaOISAccess().checkArray(s, Map.Entry[].class, cap);</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">        Node&lt;K,V&gt;[] tab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[cap];</span><br><span class="line">        table = tab;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// Read the keys and values, and put the mappings in the HashMap</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mappings; i++) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            K key = (K) s.readObject();</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            V value = (V) s.readObject();</span><br><span class="line">            putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Called only from writeObject, to ensure compatible ordering.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">internalWriteEntries</span><span class="params">(java.io.ObjectOutputStream s)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab;</span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; (tab = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                s.writeObject(e.key);</span><br><span class="line">                s.writeObject(e.value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reset to initial default state.  Called by clone and readObject.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reinitialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    table = <span class="keyword">null</span>;</span><br><span class="line">    entrySet = <span class="keyword">null</span>;</span><br><span class="line">    keySet = <span class="keyword">null</span>;</span><br><span class="line">    values = <span class="keyword">null</span>;</span><br><span class="line">    modCount = <span class="number">0</span>;</span><br><span class="line">    threshold = <span class="number">0</span>;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></li></ol><p></p><ol start="3"><li>回调方法，在HashMap中无作用，为LinkedHashMap做铺垫<br><details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Callbacks to allow LinkedHashMap post-actions</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure></details></li></ol><p></p><p>源码阅读.md<br><a href="/2019/12/29/hashmap-source-learning/HashMap.txt"> 点击下载</a></p>]]></content>
    
    <summary type="html">
    
      HashMap源码全解析。本次以Oracle JDK1.8作为示例，深入解读HashMap实现原理，精细阅读每一行源码，并结合各互联网厂商的常见面试问题，对HashMap的实现方案、思想以及使用注意事项做深入探讨。
    
    </summary>
    
      <category term="Java" scheme="http://blog.zjee.ml/categories/Java/"/>
    
    
      <category term="Java源码" scheme="http://blog.zjee.ml/tags/Java%E6%BA%90%E7%A0%81/"/>
    
      <category term="HashMap" scheme="http://blog.zjee.ml/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>Java基本类型与包装类型</title>
    <link href="http://blog.zjee.ml/2019/11/19/java-primitive-and-wrapper-type/"/>
    <id>http://blog.zjee.ml/2019/11/19/java-primitive-and-wrapper-type/</id>
    <published>2019-11-19T09:06:49.000Z</published>
    <updated>2019-11-19T09:06:49.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、Java中的数据类型"><a href="#一、Java中的数据类型" class="headerlink" title="一、Java中的数据类型"></a>一、Java中的数据类型</h3><p>熟悉Java的朋友都知道Java中的数据类型分为<strong>基本类型</strong>和<strong>引用类型</strong>，基本类型就是我们日常使用的<code>int</code>，<code>long</code>等，引用类型就是用class定义出来的类型，如<code>String</code>、<code>HashMap</code>等。Java中有8种基本数据类型，它们同时都对应一个引用数据类型（又称<strong>包装类型</strong>），具体内容如下：</p><table><thead><tr><th style="text-align:center">基本类型</th><th style="text-align:center">占用空间</th><th style="text-align:center">取值范围</th><th style="text-align:center">包装类型</th></tr></thead><tbody><tr><td style="text-align:center">byte</td><td style="text-align:center">1B</td><td style="text-align:center">$-2^{7}$ ~ $2^{7}-1$</td><td style="text-align:center">java.lang.Byte</td></tr><tr><td style="text-align:center">char</td><td style="text-align:center">2B (unicode)</td><td style="text-align:center">$0$ ~ $2^{16}-1$</td><td style="text-align:center">java.lang.Character</td></tr><tr><td style="text-align:center">short</td><td style="text-align:center">2B</td><td style="text-align:center">$-2^{15}$ ~ $2^{15}-1$</td><td style="text-align:center">java.lang.Short</td></tr><tr><td style="text-align:center">int</td><td style="text-align:center">4B</td><td style="text-align:center">$-2^{31}$ ~ ${2^{31}-1}$</td><td style="text-align:center">java.lang.Integer</td></tr><tr><td style="text-align:center">long</td><td style="text-align:center">8B</td><td style="text-align:center">$-2^{63}$ ~ $2^{63}-1$</td><td style="text-align:center">java.lang.Long</td></tr><tr><td style="text-align:center">float</td><td style="text-align:center">4B</td><td style="text-align:center">参见<a href="https://zh.wikipedia.org/wiki/IEEE_754" target="_blank" rel="noopener">IEEE754</a></td><td style="text-align:center">java.lang.Float</td></tr><tr><td style="text-align:center">double</td><td style="text-align:center">8B</td><td style="text-align:center">参见<a href="https://zh.wikipedia.org/wiki/IEEE_754" target="_blank" rel="noopener">IEEE754</a></td><td style="text-align:center">java.lang.Double</td></tr><tr><td style="text-align:center">boolean</td><td style="text-align:center">1B</td><td style="text-align:center">${True, False}$</td><td style="text-align:center">java.lang.Boolean</td></tr></tbody></table><h3 id="二、自动装箱与拆箱"><a href="#二、自动装箱与拆箱" class="headerlink" title="二、自动装箱与拆箱"></a>二、自动装箱与拆箱</h3><p>Java是一个纯面向对象的语言，为了让基本数据类型也拥有引用类型的特征（比如取null值），Java工程师特意为他们设计了包装类型。包装类型简单来说就是用一个class声明的类将基本类型包装了一下，并附带了很多常用工具，这样我们就能按面向对象的方式去使用基本数据类型了。下面是Integer类的部分源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Integer</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_VALUE = -<span class="number">2147483648</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_VALUE = <span class="number">2147483647</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//核心内容</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> value;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//构造方法    </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Integer</span><span class="params">(<span class="keyword">int</span> var1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = var1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//装箱方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> var0)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> var0 &gt;= -<span class="number">128</span> &amp;&amp; var0 &lt;= Integer.IntegerCache.high ?                      Integer.IntegerCache.cache[var0 + <span class="number">128</span>] : <span class="keyword">new</span> Integer(var0);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//拆箱方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">intValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Integer缓存</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            <span class="comment">// high value may be configured by property</span></span><br><span class="line">            <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">            String integerCacheHighPropValue =</span><br><span class="line">                sun.misc.VM.getSavedProperty(<span class="string">"java.lang.Integer.IntegerCache.high"</span>);</span><br><span class="line">            <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class="line">                    i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">                    <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">                    h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">                    <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            high = h;</span><br><span class="line">            cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> j = low;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">                cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line">            <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">            <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们从源码中可以看到包装类型中保存数据的核心成员变量就是<code>value</code>，所有对包装类型的操作最终都反映到value字段上。包装类型中的<code>valueOf</code>方法（有多种重载）就是常说的装箱方法，使用该方法可以将一个基本类型变量转变为包装类型，如<code>Integer a = Integer.valueOf(2);</code>。同样，<code>intValue</code>方法（有多种变形，如<code>longValue</code>、<code>charValue</code>等）就是拆箱方法，它可以将包装类型转变为基本类型，如<code>int b = a.intValue();</code> 。早期的Java中基本类型与包装类型的转换是需要开发人员手工去调用方法实现的，自JDK 5.0开发，Java引入了自动装箱和拆箱机制，极大的方便了开发人员，自动装箱与拆箱简单说就是JVM自动去调用<code>valueOf</code>和<code>intValue</code>方法，于是我们的代码就可以这样写了<code>int a = new Integer(1); Integer b = 4;</code>。</p><h4 id="问题拓展"><a href="#问题拓展" class="headerlink" title="问题拓展"></a>问题拓展</h4><p>我们知道在C/C++中写一个可以交换两个int变量值的函数，如下所示，那在Java中怎么实现这样一个方法呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C(通过指针交换)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span>* b)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> c = *a;</span><br><span class="line">*a = *b;</span><br><span class="line">*b = c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//C++(通过引用交换)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>&amp; a, <span class="keyword">int</span>&amp; b)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> c = a;</span><br><span class="line">a = b;</span><br><span class="line">b = c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java中没有指针，但有对象引用（与C/C++中的指针概念类似），我们可以利用此概念实现同样的功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Integer a = <span class="keyword">new</span> Integer(<span class="number">1</span>); <span class="comment">//不能用自动装箱</span></span><br><span class="line">        Integer b = <span class="keyword">new</span> Integer(<span class="number">2</span>); <span class="comment">//不能用自动装箱</span></span><br><span class="line">        swap(a, b);</span><br><span class="line">        System.out.println(<span class="string">"a="</span>+a+<span class="string">", b="</span>+b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swapa</span><span class="params">(Integer a, Integer b)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> c = a;<span class="comment">//暂存a的值(使用自动拆箱)</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//通过反射的方式强行更改value</span></span><br><span class="line">        Field field = a.getClass().getDeclaredField(<span class="string">"value"</span>);</span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        field.set(a, b);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过反射的方式强行更改value</span></span><br><span class="line">        field = b.getClass().getDeclaredField(<span class="string">"value"</span>);</span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        field.set(b, c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 输出：a=2, b=1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>上面的代码可以实现值的交换，但存在一些限制：</p><ol><li>实参和形参都必须是包装类型，因为只有包装类型传参时是传引用（相当与C/C++中的指针）。</li><li><span style="color:red;">实参不能使用自动装箱生成，如<code>Integer a = 100;</code>。</span></li><li>效率不高。</li></ol><p>下面我们看一下为什么不能使用自动装箱，首先看一下自动装箱的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> var0)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> var0 &gt;= -<span class="number">128</span> &amp;&amp; var0 &lt;= Integer.IntegerCache.high ?                      Integer.IntegerCache.cache[var0 + <span class="number">128</span>] : <span class="keyword">new</span> Integer(var0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到如果自动装箱的值在<code>[-128, high]</code>（<code>high∈[127, Integer.MAX_VALUE-129]</code>）,就会返回<code>Integer.IntegerCache.cache[var0 + 128]</code>这样一个值，其中的<code>Integer.IntegerCache.cache</code>就是我们提到的<strong>缓存</strong>，在Integer中缓存默认范围是[-128， 127]，也就是说这个范围类的数字对应的包装对象在加载Integer类的时候都已经生成好了，以后谁要采用自动装箱获取Integer对象，只要值在缓存范围内，就直接返回缓存对象即可。</p><p>在上面的swap示例中，如果传入的实参是采用自动装箱生成的，且数值范围在缓存范围内，就会将<strong>缓存的引用</strong>传入swap方法中，然后用<strong>反射修改的就是这些缓存的值</strong>。最终，我们最初的问题是解决了，但接着会带来更大的麻烦，示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Integer a = <span class="number">1</span>;</span><br><span class="line">        Integer b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        swap(a, b);</span><br><span class="line">        System.out.println(<span class="string">"a="</span>+a+<span class="string">", b="</span>+b);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//!!! Big trouble !!!</span></span><br><span class="line">        System.out.println(<span class="string">"Integer.valueOf(1) = "</span> + Integer.valueOf(<span class="number">1</span>)); <span class="comment">//缓存被修改了</span></span><br><span class="line">        System.out.println(<span class="string">"(Integer)2 = "</span> + (Integer)<span class="number">2</span>);<span class="comment">//缓存被修改了</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Integer a, Integer b)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Integer c = <span class="keyword">new</span> Integer(a); <span class="comment">//原始值进行深度拷贝</span></span><br><span class="line"></span><br><span class="line">        Field field = a.getClass().getDeclaredField(<span class="string">"value"</span>);</span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        field.set(a, b);</span><br><span class="line"></span><br><span class="line">        field = b.getClass().getDeclaredField(<span class="string">"value"</span>);</span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        field.set(b, c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 输出：</span></span><br><span class="line"><span class="comment">* a=2, b=1</span></span><br><span class="line"><span class="comment">* Integer.valueOf(1) = 2</span></span><br><span class="line"><span class="comment">* (Integer)2 = 1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>☠ 我们看到由于直接修改了<code>1</code>和<code>2</code>缓存，后续所有用到这两个缓存的值将全部出错，这是一种很危险的行为。</p><p><strong><em>忠告</em></strong>：在java中上诉两种交换值的方式请都<strong>不要使用</strong>，如果有此类需求，可以考虑以下方案：</p><ul><li>不使用方法，直接就地解决。</li><li>使用方法，把原始两个参数合并成list或数组传入swap方法</li><li>使用方法，把原始数据包装进一个对象中传入swap方法</li></ul><h3 id="三、Java基本数据类型缓存"><a href="#三、Java基本数据类型缓存" class="headerlink" title="三、Java基本数据类型缓存"></a>三、Java基本数据类型缓存</h3><p>在Java5中，为节省内存提高性能，除Float和Double之外，所有基本类型的包装类型都引入了缓存，一般缓存[-128, 127]（Charactor是[0, 127]）之间的所有包装类对象。这些缓存在对应类加载的时候都完成了初始化，后续使用时如果用到自动装箱且数值在缓存范围内，则直接返回缓存对象。</p><p>Integer的缓存范围上界是可调整的（也是唯一可调范围的类型），在JVM启动参数中加入<code>-XX:AutoBoxCacheMax=&lt;size&gt;</code>调整Integer缓存范围。其中<code>size</code>的可取范围是[127, 2147483518]，如果不在此范围就取该范围的边界值。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Integer a = <span class="number">100</span>; <span class="comment">//use cache</span></span><br><span class="line">Integer b = Integer.valueOf(-<span class="number">128</span>); <span class="comment">//use cache</span></span><br><span class="line">Integer c = Integer.valueOf(<span class="string">"23"</span>); <span class="comment">//use cache</span></span><br><span class="line">Integer d = <span class="keyword">new</span> Integer(<span class="number">23</span>);<span class="comment">// not use cache</span></span><br><span class="line">Integer e = <span class="number">7367</span>; <span class="comment">//not use cache by default</span></span><br></pre></td></tr></table></figure><h3 id="四、延申思考"><a href="#四、延申思考" class="headerlink" title="四、延申思考"></a>四、延申思考</h3><h4 id="4-1-方法重载优先级"><a href="#4-1-方法重载优先级" class="headerlink" title="4.1 方法重载优先级"></a>4.1 方法重载优先级</h4><p>问题如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;&#125; <span class="comment">//m1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Integer a, <span class="keyword">int</span> b)</span></span>&#123;&#125; <span class="comment">//m2</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a, Integer b)</span></span>&#123;&#125; <span class="comment">//m3</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Integer a, Integer b)</span></span>&#123;&#125; <span class="comment">//m4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line">swap(<span class="number">2</span>, <span class="number">3</span>); <span class="comment">//调用m1</span></span><br><span class="line">swap((Integer)<span class="number">2</span>, <span class="number">3</span>); <span class="comment">//调用m2</span></span><br><span class="line">swap((Integer)<span class="number">2</span>, (Integer)<span class="number">3</span>); <span class="comment">//调用m4</span></span><br></pre></td></tr></table></figure><p>java在重载的时候优先按相同类型精确匹配，当匹配不上时再尝试包装类型，但是将包装类型和基本类型混用时旧需要明确指定类型，否则会导致编译失败。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a, Integer b)</span></span>&#123;&#125; <span class="comment">//m3</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Integer a, Integer b)</span></span>&#123;&#125; <span class="comment">//m4</span></span><br><span class="line"></span><br><span class="line">swap(<span class="number">2</span>, <span class="number">3</span>); <span class="comment">// compile error</span></span><br><span class="line">swap((Integer)<span class="number">2</span>, <span class="number">3</span>); <span class="comment">// compile error</span></span><br><span class="line">swap((Integer)<span class="number">2</span>, (Integer)<span class="number">3</span>); <span class="comment">//m4 ok</span></span><br><span class="line">swap(<span class="number">3</span>, (Integer)<span class="number">4</span>);<span class="comment">//m3 ok</span></span><br></pre></td></tr></table></figure><h4 id="4-2泛型"><a href="#4-2泛型" class="headerlink" title="4.2泛型"></a>4.2泛型</h4><p>java中泛型不支持基本数据类型，即<code>int</code>,<code>float</code>这样的，但数组是个例外，数据在java中是个对象，不过这个对象没有明确的class，我们可像操作对象一样操作数组，所以泛型是可以接收数组的，示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list1 = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">// ok</span></span><br><span class="line">List&lt;<span class="keyword">int</span>[]&gt; list2 = <span class="keyword">new</span> ArrayList&lt;&gt;();   <span class="comment">// also ok</span></span><br><span class="line">List&lt;<span class="keyword">int</span>&gt; list3 = <span class="keyword">new</span> ArrayList&lt;&gt;();     <span class="comment">// compile error</span></span><br></pre></td></tr></table></figure><p>我们日常开发中有一个数组转List的工具用的特别多，它就是<code>Arrays.asList(T... a)</code>，这个方法接收可变参数，我们知道可变参数可以传多个参数或一个数组，当传数组的时候需要注意，泛型会将int[]视为一个整体，也就是说这里传<code>new Integer[]{1,2,3}</code>与<code>new int[]{1,2,3}</code>是不一样的。对于前者来说，相当于传入3个<code>Integer</code>参数，最后接收方收到的参数长度为3。而后者相当于传入一个类型为<code>int[]</code>的参数，接收方收到的参数长度为1。因此，我们在使用<code>Arrays.asList</code>的时候要特别注意用包装类型而不是基本类型。</p>]]></content>
    
    <summary type="html">
    
      用了很久的Java，偶然闲谈中才发现自己竟然说不明白Java的基本类型与包装类型的关系，深感愧疚，便写下此篇文章，给自己长个记性。本文涉及的内容：Java基本类型与包装类型的区别及联系、自动装箱与拆箱、包装类型缓存及其它问题的思考。
    
    </summary>
    
      <category term="Java" scheme="http://blog.zjee.ml/categories/Java/"/>
    
    
      <category term="Java" scheme="http://blog.zjee.ml/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java中的同步、互斥机制</title>
    <link href="http://blog.zjee.ml/2019/08/24/java-lock-util/"/>
    <id>http://blog.zjee.ml/2019/08/24/java-lock-util/</id>
    <published>2019-08-23T16:00:00.000Z</published>
    <updated>2019-08-23T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>在Java多线程编程中，同步和互斥是一个不可避免的话题。Java为开发人员提供了以下几种锁机制：</p><ol><li><code>synchronized</code>关键字</li><li><code>Lock</code>接口</li><li><code>ReadWriteLock</code>接口</li></ol><p>这几种锁机制在日常编程中用的很多，但它们有什么联系和区别呢？</p><h3 id="一、Synchronized"><a href="#一、Synchronized" class="headerlink" title="一、Synchronized"></a>一、Synchronized</h3><ol><li><p><code>synchronized</code>关键字是Java内置的关键字，可以轻松实现临界区资源的同步互斥访问。synchronized关键字使用很简单，可以加在方法上或代码块上，用在方法声明中表示整个方法调用是互斥的，用在代码块上表示被包围的代码执行是互斥的，示例如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consumer1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//synchronize 用在代码块上，表示该代码块互斥</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123; </span><br><span class="line">        resource -- ;</span><br><span class="line">        System.out.println(<span class="string">" resource: "</span> + resource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="comment">//synchronize用在方法上，表示整个方法调用互斥</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">consumer2</span><span class="params">()</span></span>&#123; </span><br><span class="line">    resource -- ;</span><br><span class="line">    System.out.println(<span class="string">"resource: "</span> + resource);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//synchronize用在静态方法上，使用Class对象作为对象锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">consumer3</span><span class="params">()</span></span>&#123; </span><br><span class="line">    resource -- ;</span><br><span class="line">    System.out.println(<span class="string">"resource: "</span> + resource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>synchronized</code>关键字需要一个<strong>锁对象</strong>,当代码执行到synchronized修饰的方法或包围的代码块时就会获取该锁对象的锁，本质上就是获取锁对象的监视器(monitor，可以理解为锁标记)，如果获取到锁就继续执行临界区代码，否则就一直等待。如果<code>synchronized</code>修饰的是一个<strong>非静态</strong>方法，那么锁对象就是这个<strong>对象本身</strong>；如果<code>synchronized</code>修饰的是一个<strong>静态</strong>方法，那么锁对象就是这个<strong>类对象</strong>。同理，我们在使用synchronized代码块时，需要提供一个锁对象，一般可用<code>this</code>表示使用对象本身作为锁对象，当然也可以使用其他自定义对象，比如 <code>new Object()</code>。这里需要注意一点，不要使用<code>String</code>或常用的数字对象去作为锁对象，因为他们在JVM缓存在一个常量池中，是一个共享对象，如果多处使用这些对象作为锁对象，可能会导致不可预期的死锁。</p></li><li><p><strong>可重入</strong>是锁的一个重要特性，它是指一个线程重复获取获取它<strong><em>已经拥有的锁</em></strong>，如果可以获取到则表示该锁是<strong>可重入</strong>的，否则就是<strong>不可重入</strong>的。<code>synchronized</code>是<strong>可重入</strong>的，示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> resource = <span class="number">100</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        test.consumer1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">consumer1</span><span class="params">()</span> </span>&#123; <span class="comment">//第一次获取锁</span></span><br><span class="line">        resource--;</span><br><span class="line">        System.out.println(<span class="string">"consumer1: "</span> + resource);</span><br><span class="line">        <span class="keyword">this</span>.consumer2(); <span class="comment">//调用另外一个synchronized修饰的方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">consumer2</span><span class="params">()</span> </span>&#123; <span class="comment">//第二次获取锁</span></span><br><span class="line">        resource--;</span><br><span class="line">        System.out.println(<span class="string">"consumer2: "</span> + resource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 输出：</span></span><br><span class="line"><span class="comment"> * consumer1: 99</span></span><br><span class="line"><span class="comment"> * consumer2: 98</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></li><li><p><code>synchronized</code>是<strong>不可中断</strong>的，当一个线程因获取不到锁而进入阻塞状态时，这个线程就一直会阻塞下去，不会响应外界的中断信号，这也是synchronize的最大缺陷。</p></li><li><p>总结：</p><ul><li>synchronized优点：使用简单，速度快(JVM底层支持，编译后会形成<code>monitorenter</code>、<code>monitorenter</code>两条指令)，自动释放锁，保证了互斥性和变量修改的可见性（一个线程对变量的修改对其他线程立即可见）。</li><li>synchronized缺点：synchronized获取锁的过程无法被中断，也不能尝试非阻塞、超时返回等策略获取锁，这在高并发环境下将会带来很大的性能损失。</li></ul></li></ol><h3 id="二、Lock"><a href="#二、Lock" class="headerlink" title="二、Lock"></a>二、Lock</h3><ol><li><p>Lock是Java5开始提供的一个JDK层面的用于控制同步互斥的接口，它位于<code>java.util.concurrent.locks</code>包下。此外，该包下还有Condition和ReadWriteLock两兄弟，它们都是为多线程同步、互斥服务的，其类图如下：</p><img src="/2019/08/24/java-lock-util/001.png" title="Lock家族类图"><p>我们可以看到Lock接口下一般供开发人员直接使用的实现是<code>ReentrantLock</code>，这个类基本解决了<code>synchronized</code>存在的不足，我们看一下Lock接口提供的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">    <span class="comment">//开始获取锁(进入临界区,阻塞方法)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>; </span><br><span class="line">    <span class="comment">//开始获取锁，同时可以响应中断事件，可在捕获InterruptedException异常后做后续处理(阻塞方法)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>; </span><br><span class="line">    <span class="comment">//尝试获取锁，无论成功或失败都立即返回(非阻塞)</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//尝试获取锁，如果成功立即返回，否则等待给定时间后返回，并且等待中还可以响应中断事件</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> var1, TimeUnit var3)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="comment">//释放锁</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//条件变量，用于线程间通信及同步协作(生产者、消费者模型会用到)</span></span><br><span class="line">    <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过Lock接口提供的方法我们看到Lock锁更加细粒度化，它可以让开发人员根据实际需求灵活处理获取锁期间的等待行为。使用Lock一定要<strong>手动释放锁</strong>，这是很重要的一点，如果处理不慎将会导致不可预期的死锁，一般为了可靠释放锁，会将unlock调用放在<code>finally</code>块中。</p></li><li><p>说完Lock接口我们来看一下它的实现<code>ReentrantLock</code>，从字面上就知道这个锁是一个<strong>可重入的</strong>，下面是该类提供的方法（仅列举部分方法）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//构造方法，默认非公平锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="comment">//构造方法，传入一个boolean值指定是否需要公平锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> var1)</span> </span>&#123;...&#125;</span><br><span class="line"><span class="comment">//获取当前线程对该锁的持有数量(可重入特性)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getHoldCount</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line"><span class="comment">//是否被当前线程持有</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isHeldByCurrentThread</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line"><span class="comment">//是否成功获取锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line"><span class="comment">//是否公平锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isFair</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line"><span class="comment">//返回当前持有此锁的线程</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Thread <span class="title">getOwner</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line"><span class="comment">//是否有可能正在等待获取此锁的线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedThreads</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line"><span class="comment">//查询指定线程是否正在等待获取此锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedThread</span><span class="params">(Thread var1)</span> </span>&#123;...&#125;</span><br><span class="line"><span class="comment">//返回可能获取此锁的等待线程数量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getQueueLength</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line"><span class="comment">//返回可能正在等待此锁的线程集合</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Collection&lt;Thread&gt; <span class="title">getQueuedThreads</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的构造方法可知，<code>ReentrantLock</code>默认是<strong>非公平锁</strong>，但可根据需要配置成<strong>公平锁</strong>。除此之外，它还提供了一系列查询方法，用于查询当前锁的获取状态，这里不一一描述了。</p></li><li><p>基础用法：</p><ol><li><p><strong>lock</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br><span class="line">lock.lock(); <span class="comment">//lock</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line"><span class="comment">//handle exception</span></span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock(); <span class="comment">//unlock</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>lockInterruptibly</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123; </span><br><span class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br><span class="line">    lock.lockInterruptibly(); <span class="comment">//向上抛出中断异常，也可以自己try cache处理</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//Do something</span></span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line"><span class="comment">//handle exception</span></span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock(); <span class="comment">//unlock</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>tryLock</strong>：（两种使用方式）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非阻塞</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">if</span>(lock.tryLock()) &#123; <span class="comment">//尝试获取锁，这个调用不会阻塞</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//do something</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">//handle exception</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock(); <span class="comment">//unlock</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//获取锁失败</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//阻塞，可设置超时时间，可中断</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAnything</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     Lock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">if</span>(lock.tryLock(<span class="number">5</span>, TimeUnit.SECONDS)) &#123; <span class="comment">//超时设为5s</span></span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">                 <span class="comment">//do something</span></span><br><span class="line">             &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                 <span class="comment">//handle exception</span></span><br><span class="line">             &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                 lock.unlock(); <span class="comment">//unlock</span></span><br><span class="line">             &#125;</span><br><span class="line">         &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="comment">//获取锁失败</span></span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">         <span class="comment">//处理中断事件</span></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>在上面的代码演示中，不难发现unlock操作都是放在finally语句中，而获取锁却不再对应try-catch中，这是因为对于非阻塞或可中断的获取锁方发来说，如果获取锁失败，后面再去调用unlock就会抛出<code>IllegalMonitorStateException</code>异常，这会带来不必要的麻烦，所以一般获取锁不成功就不会执行unlock。对于可中断的锁一般采用向上抛出，这是因为多线程环境下获取锁失败的后该是各线程自行采取相应处理策略，而不是由被调用者处理。</p></li></ol></li></ol><h3 id="三、ReadWriteLock"><a href="#三、ReadWriteLock" class="headerlink" title="三、ReadWriteLock"></a>三、ReadWriteLock</h3><ol><li><p>JDK中除提供了基本的满足同步、互斥的Lock机制外，还提供了一种特殊的读写锁模型，该模型一定程度上降低了互斥要求，带来更好的性能体验。读写锁具体来说分为两方面：</p><ul><li>ReadLock：读锁不同线程可以重复获取（与可重入概念不一样），即一个资源是可以并发读的，资源加了读锁后只能再加读锁。</li><li>WriteLock：写锁是完全互斥的，即一个资源加写锁后不能再施加其他锁，当然加了读锁的资源也不能加写锁。</li></ul></li><li><p>读写锁在数据库中运用非常广泛，比如一行数据可以多个客户端读取，但不能同时写，也不能边读边写。下面演示读写锁的具体用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ReadWriteLock readWriteLock;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; resource; <span class="comment">//模拟公共资源</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LockTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        readWriteLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">        resource = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        resource.add(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//主方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        LockTest lockTest = <span class="keyword">new</span> LockTest();</span><br><span class="line">        Thread r1 = <span class="keyword">new</span> Thread(() -&gt; &#123; <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;++i) &#123; lockTest.read();&#125; &#125;, <span class="string">"reader1"</span>);</span><br><span class="line">        Thread r2 = <span class="keyword">new</span> Thread(() -&gt; &#123; <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;++i) &#123; lockTest.read();&#125; &#125;, <span class="string">"reader2"</span>);</span><br><span class="line">        Thread w1 = <span class="keyword">new</span> Thread(()-&gt;&#123; <span class="keyword">try</span>&#123; lockTest.write(); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"writer1被中断"</span>); &#125;&#125;, <span class="string">"writer1"</span>);</span><br><span class="line">        Thread w2 = <span class="keyword">new</span> Thread(()-&gt;&#123; <span class="keyword">try</span>&#123; lockTest.write(); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"writer2被中断"</span>); &#125;&#125;, <span class="string">"writer2"</span>);</span><br><span class="line"></span><br><span class="line">        r1.start();</span><br><span class="line">        r2.start();</span><br><span class="line">        w2.start();</span><br><span class="line">        w1.start();</span><br><span class="line">        Thread.sleep(<span class="number">3</span>);<span class="comment">//等待3ms</span></span><br><span class="line">        w1.interrupt(); <span class="comment">//尝试中断writer1的阻塞</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取资源</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        readWriteLock.readLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">": "</span> +resource);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readWriteLock.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写入资源</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        readWriteLock.writeLock().lockInterruptibly();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            resource.add(Thread.currentThread().getName());</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">": add resource"</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readWriteLock.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**输出：</span></span><br><span class="line"><span class="comment"> * reader2: [main]</span></span><br><span class="line"><span class="comment"> * reader1: [main]</span></span><br><span class="line"><span class="comment"> * writer2: add resource</span></span><br><span class="line"><span class="comment"> * writer1被中断</span></span><br><span class="line"><span class="comment"> * reader2: [main, writer2]</span></span><br><span class="line"><span class="comment"> * reader1: [main, writer2]</span></span><br><span class="line"><span class="comment"> * reader1: [main, writer2]</span></span><br><span class="line"><span class="comment"> * reader2: [main, writer2]</span></span><br><span class="line"><span class="comment"> * reader1: [main, writer2]</span></span><br><span class="line"><span class="comment"> * reader2: [main, writer2]</span></span><br><span class="line"><span class="comment"> * reader1: [main, writer2]</span></span><br><span class="line"><span class="comment"> * reader2: [main, writer2]</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>上面演示了并发环境下ReadWriteLock的使用，这里需要注意的是最终的输出不是一个固定结果，如果writer1在3ms内获取到锁就不会输出<code>writer1被中断</code>（<code>w1.interrupt();</code>将会中断writer1里面的sleep），这个结果完全是随机的。虽然ReentrantReadWriteLock没实现Lock接口，但其内部类<code>ReentrantReadWriteLock.WriteLock</code>和<code>ReentrantReadWriteLock.ReadLock</code>实现了Lock接口，因此读写锁也具有Lock的全部特性。</p></li></ol><h3 id="四、相关概念"><a href="#四、相关概念" class="headerlink" title="四、相关概念"></a>四、相关概念</h3><ol><li><p><strong>乐观锁/悲观锁</strong></p><p>乐观锁和悲观锁不是一种具体的锁，而是对待并发的一种态度。<strong>悲观锁</strong>认为对于同一资源的并发访问一定会发生修改操作，不加锁的并发访问一定会出问题，因此一定要加锁。<strong>乐观锁</strong>则认为并发访问很少发生资源修改操作，即使发生也会采用不断尝试的方式更新资源，不加锁的并发访问是不会出问题的。悲观锁适合写操作多的场景，乐观锁适合读操作多的场景。Java中各种加锁编程就属于悲观锁范围，而使用concurrent包下的AtomicXXX实现原子操作就属于乐观锁范围，因为Atomic类型是使用<a href="https://segmentfault.com/a/1190000017943658" target="_blank" rel="noopener">CAS算法</a>实现原子操作的，并没有使用锁，属于无锁编程，一般来说乐观锁的性能好于悲观锁。</p></li></ol><hr><ol start="2"><li><p><strong>可重入锁</strong></p><p>可重入是只可重复递归调用的锁，在加锁的方法类可递归调用该方法，并不会发生死锁。<code>ReentrantLock</code>和<code>synchronized</code>都是可重入锁。</p></li></ol><hr><ol start="3"><li><p><strong>独占锁（排它锁）</strong> / <strong>共享锁</strong></p><p>独占锁即一个锁只能一个线程占有，如<code>ReentrantLock</code>、<code>ReentrantReadWriteLock.WriteLock</code>就是独占锁。共享锁可被多个线程共享，如<code>ReentrantReadWriteLock.ReadLock</code></p></li></ol><hr><ol start="4"><li><p><strong>公平锁</strong> / <strong>非公平锁</strong></p><p>公平锁是指获取锁的顺序跟申请锁的顺序一致，反之亦然。</p></li></ol><hr><ol start="5"><li><p><strong>分段锁</strong></p><p>分段锁是一种锁的设计，它的核心思想是减小加锁粒度。比如在<code>ConcurrentHashMap</code>中就采用分段锁的思想，ConcurrentHashMap中有16个锁，每个散列桶由第N%16个锁来保护，所以一次加锁理论上（与数据分布均匀程度有关）只锁定整个Map的1/16的数据，其他部分的数据访问不受限制，ConcurrentHashMap最多可支持16个线程的并发写入。同样在MySQL中也有类似的设计出现，比如行锁就是一种分段锁，更新数据时只需要锁定特定行，其他行可供正常访问。</p></li></ol><hr><ol start="6"><li><p><strong><em>偏向锁</em></strong> / <strong><em>轻量级锁</em></strong> / <strong><em>重量级锁</em></strong></p><p>这3种分类非Java语言提供的特性，因此不做深入研究，可参考：<a href="https://www.cnblogs.com/wzj4858/p/8215369.html" target="_blank" rel="noopener">偏向锁/轻量级锁/重量级锁</a></p></li></ol><hr><ol start="7"><li><p><strong>自旋锁</strong></p><p>自旋锁关注的是在获取锁的过程中线程处所处状态，当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将<strong>循环等待</strong>（不进入阻塞状态），然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环。注意，自旋锁的设计是为了减少线程状态切换带来的开销（用户态-&gt;内核态，active-&gt;blocked）,当加锁区域的代码执行的非常快时，该设计能大大提高性能。而加锁区域执行缓慢时则相反，自旋锁不会释放CPU资源，如果长时间处于自旋状态将严重拖累系统性能，所以是否采用自旋锁需要根据需求而定。</p></li></ol><h3 id="五、参考资料"><a href="#五、参考资料" class="headerlink" title="五、参考资料"></a>五、参考资料</h3><ol><li><a href="https://blog.csdn.net/justloveyou_/article/details/54972105" target="_blank" rel="noopener">Java 并发：Lock 框架详解</a></li><li><a href="http://blog.itpub.net/31545684/viewspace-2375117/" target="_blank" rel="noopener">Java 种15种锁的介绍：公平锁，可重入锁，独享锁，互斥锁等等…</a></li><li><a href="https://www.cnblogs.com/wzj4858/p/8215369.html" target="_blank" rel="noopener">javas的四种状态 无锁状态 偏向锁状态 轻量级锁状态 重量级锁状态</a></li><li><a href="https://zhuanlan.zhihu.com/p/40729293" target="_blank" rel="noopener">面试必备之深入理解自旋锁</a></li><li><a href="http://tool.oschina.net/apidocs/apidoc?api=jdk-zh" target="_blank" rel="noopener">JDK文档</a></li></ol>]]></content>
    
    <summary type="html">
    
      并发编程中，锁是一个永远绕不过的话题，深入认识Java中的同步、互斥机制是Java并发编程的必经之路。本篇文章就Java原生锁机制做一个简单的描述，让自己能全面宏观认识整个框架，在工作学习中能正确、高效使用Java同步、互斥相关工具。
    
    </summary>
    
      <category term="Java" scheme="http://blog.zjee.ml/categories/Java/"/>
    
    
      <category term="多线程" scheme="http://blog.zjee.ml/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="Java锁机制" scheme="http://blog.zjee.ml/tags/Java%E9%94%81%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>Hive on Spark 实践</title>
    <link href="http://blog.zjee.ml/2018/12/02/hive-on-spark/"/>
    <id>http://blog.zjee.ml/2018/12/02/hive-on-spark/</id>
    <published>2018-12-02T13:02:57.000Z</published>
    <updated>2018-12-02T13:02:57.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、准备"><a href="#一、准备" class="headerlink" title="一、准备"></a>一、准备</h3><ol><li>jdk、hadoop、Hive、mysql和spark。为避免兼容问题，本人全部采用cdh版本，对应cdh5.15.0，不过貌似spark版本有点低，不过无所谓，毕竟只是实验。</li><li>由于本人之前搭建过kylin环境，因此hadoop和hive环境已经配置妥当，都是yarn管理下的伪分布式集群。</li><li>安装scala，mac下通过brew安装：<code>brew install scala</code>，网速慢可以使用代理或<a href="https://www.cnblogs.com/jay54520/p/6347729.html" target="_blank" rel="noopener">国内源</a>。</li><li><a href="https://www.cnblogs.com/binarylei/p/8903601.html" target="_blank" rel="noopener">hadoop</a>、<a href="https://www.cnblogs.com/wujiadong2014/p/6058552.html" target="_blank" rel="noopener">hive</a>、<a href="https://www.jianshu.com/p/e41b18a7e202" target="_blank" rel="noopener">spark</a>的基本概念，原理，运行方式可做一个初步了解，方便以后问题排查。</li></ol><h3 id="二、配置SPARK"><a href="#二、配置SPARK" class="headerlink" title="二、配置SPARK"></a>二、配置SPARK</h3><ol><li><p>在/etc/profile或~/.bash_profile（假设你没有使用zsh之类的shell）中加入SPARK_HOME环境变量，并将bin路径添加到PATH中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export SPARK_HOME=/Users/xxx/spark-1.6.0-cdh5.15.0</span><br><span class="line">export PATH=$PATH:$SPARK_HOME/bin</span><br></pre></td></tr></table></figure></li><li><p>在spark下的config目录中找到spark-env.sh和spark-defaults.conf(如果没有就自己创建)，然后添加如下配置:</p><p>spark-env.sh</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> !/usr/bin/env bash</span><br><span class="line">export SCALA_HOME=/usr/local/Cellar/scala/2.12.7 #注意scala版本</span><br><span class="line">export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home</span><br><span class="line">export HADOOP_HOME=/Users/xxx/hadoop-2.6.0-cdh5.15.0</span><br><span class="line">export HADOOP_CONF_DIR=$HADOOP_HOME/etc/hadoop #hadoop配置文件目录</span><br><span class="line">export YARN_CONF_DIR=$HADOOP_HOME/etc/hadoop #yarn配置文件目录(和hadoop配置在一起)</span><br><span class="line">export SPARK_MASTER_IP=localhost #master节点IP，本地搭建使用localhost</span><br><span class="line">export SPARK_MASTER_HOST=localhost #master机器名称，本地搭建可使用localhost代替</span><br><span class="line">export SPARK_EXECUTOR_MEMORY=512m #每个executor可分配的内存，可根据机器实际情况设置为512m到1g</span><br><span class="line">export SPARK_DRIVER_MEMORY=512m #driver可分配的内存，可根据机器实际情况设置为512m到1g</span><br><span class="line">export SPARK_DIST_CLASSPATH=$($&#123;HADOOP_HOME&#125;/bin/hadoop classpath) #saprk运行依赖hadoop的库</span><br></pre></td></tr></table></figure><p>spark-defaults.conf</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">spark<span class="selector-class">.master</span>                     yarn</span><br><span class="line">spark<span class="selector-class">.home</span>                       /Users/xxx/spark-<span class="number">1.6</span>.<span class="number">0</span>-cdh5.<span class="number">15.0</span></span><br><span class="line">spark<span class="selector-class">.eventLog</span><span class="selector-class">.enabled</span>           true</span><br><span class="line">spark<span class="selector-class">.eventLog</span><span class="selector-class">.dir</span>               hdfs:<span class="comment">//localhost:8001/spark_history</span></span><br><span class="line">spark<span class="selector-class">.serializer</span>                 org<span class="selector-class">.apache</span><span class="selector-class">.spark</span><span class="selector-class">.serializer</span><span class="selector-class">.KryoSerializer</span></span><br><span class="line">spark<span class="selector-class">.executor</span><span class="selector-class">.memory</span>            <span class="number">512</span>m</span><br><span class="line">spark<span class="selector-class">.driver</span><span class="selector-class">.memory</span>              <span class="number">512</span>m</span><br><span class="line">spark<span class="selector-class">.executor</span><span class="selector-class">.extraJavaOptions</span>  -XX:+PrintGCDetails -Dkey=value -Dnumbers=<span class="string">"one two three"</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：这里将spark托管到yarn上，所以spark.master配置为yarn，日志目录必须是hdfs路径下的<strong><em>已经存在</em></strong>的目录，如果不存在请手动创建<code>hdfs dfs -mkdir /spark_history</code>，这个目录也是后面的spark history服务依赖的目录。</p></li></ol><h3 id="三、配置Hive"><a href="#三、配置Hive" class="headerlink" title="三、配置Hive"></a>三、配置Hive</h3><ol><li><p>将spark-defaults.conf中的配置同步到hive配置中，在hive下的conf目录下找到hive-site.xml，增加如下内容：<br> hive-site.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 注意：hive.execution.engine在这里设置表示hive默认使用spark引擎，</span></span><br><span class="line"><span class="comment">也可以不在这里设置，进入hive cli或客户端后使用set hive.execution.engine=spark</span></span><br><span class="line"><span class="comment">启用spark引擎，但这种方式只针对当前会话有效。--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>hive.execution.engine<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>spark<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="params">&lt;property&gt;</span></span><br><span class="line"><span class="params">&lt;name&gt;</span>spark.home<span class="params">&lt;/name&gt;</span></span><br><span class="line"><span class="params">&lt;value&gt;</span>/Users<span class="meta-keyword">/xxx/</span>spark<span class="number">-1.6</span><span class="number">.0</span>-cdh5<span class="number">.15</span><span class="number">.0</span><span class="params">&lt;/value&gt;</span></span><br><span class="line"><span class="params">&lt;/property&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="params">&lt;property&gt;</span></span><br><span class="line"><span class="params">&lt;name&gt;</span>spark.master<span class="params">&lt;/name&gt;</span></span><br><span class="line"><span class="params">&lt;value&gt;</span>yarn<span class="params">&lt;/value&gt;</span></span><br><span class="line"><span class="params">&lt;/property&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="params">&lt;property&gt;</span></span><br><span class="line"><span class="params">&lt;name&gt;</span>spark.executor.memory<span class="params">&lt;/name&gt;</span></span><br><span class="line"><span class="params">&lt;value&gt;</span><span class="number">512</span>m<span class="params">&lt;/value&gt;</span></span><br><span class="line"><span class="params">&lt;/property&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="params">&lt;property&gt;</span></span><br><span class="line"><span class="params">&lt;name&gt;</span>spark.driver.memory<span class="params">&lt;/name&gt;</span></span><br><span class="line"><span class="params">&lt;value&gt;</span><span class="number">512</span>m<span class="params">&lt;/value&gt;</span></span><br><span class="line"><span class="params">&lt;/property&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="params">&lt;property&gt;</span></span><br><span class="line"><span class="params">&lt;name&gt;</span>spark.serializer<span class="params">&lt;/name&gt;</span></span><br><span class="line"><span class="params">&lt;value&gt;</span>org.apache.spark.serializer.KryoSerializer<span class="params">&lt;/value&gt;</span></span><br><span class="line"><span class="params">&lt;/property&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="params">&lt;property&gt;</span></span><br><span class="line">  <span class="params">&lt;name&gt;</span>spark.enentLog.enabled<span class="params">&lt;/name&gt;</span></span><br><span class="line">  <span class="params">&lt;value&gt;</span>true<span class="params">&lt;/value&gt;</span></span><br><span class="line"><span class="params">&lt;/property&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="params">&lt;property&gt;</span></span><br><span class="line">  <span class="params">&lt;name&gt;</span>spark.enentLog.dir<span class="params">&lt;/name&gt;</span></span><br><span class="line">  <span class="params">&lt;value&gt;</span>hdfs:<span class="comment">//localhost:8001/spark_history&lt;/value&gt;</span></span><br><span class="line"><span class="params">&lt;/property&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="params">&lt;property&gt;</span></span><br><span class="line">  <span class="params">&lt;name&gt;</span>spark.executor.extraJavaOptions<span class="params">&lt;/name&gt;</span></span><br><span class="line">  <span class="params">&lt;value&gt;</span>-XX:+PrintGCDetails -Dkey=value -Dnumbers=<span class="string">"one two three"</span><span class="params">&lt;/value&gt;</span></span><br><span class="line"><span class="params">&lt;/property&gt;</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：这里的配置务必和spark-defaults.conf中的一致，尤其是<code>spark.executor.memory</code>和<code>spark.driver.memory</code>，自己配置时填错了这两项，结果一堆莫名其妙的异常。</p></li></ol><h3 id="四、配置yarn"><a href="#四、配置yarn" class="headerlink" title="四、配置yarn"></a>四、配置yarn</h3><ol><li><p>配置yarn，在hadoop的etc/hadoop目录下找到yarn-site.xml，增加（修改）如下内容：<br>yarn-site.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- yarn资源调度器：公平调度 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.scheduler.class<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>org.apache.hadoop.yarn.server.resourcemanager.scheduler.fair.FairScheduler<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- NM的web监控地址，主要是端口设置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.webapp.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>0.0.0.0:8042<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- NM可分派的内存量，单机的话看机器剩余内存量配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.resource.memory-mb<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>8192<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- NM可分配的虚拟CPU数，单机的话配置为CPU核数-2或-1 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.resource.cpu-vcores<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>6<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="五、其他配置"><a href="#五、其他配置" class="headerlink" title="五、其他配置"></a>五、其他配置</h3><ol><li>你以为这就完了？没有，CDH版本的Hive与Spark并没有联系，所以需要我们手动将spark lib中的<code>spark-assembly-1.6.0-cdh5.15.0-hadoop2.6.0-cdh5.15.0.jar</code>拷贝到hive lib下，hive才能与spark建立联系。</li><li>理论上一切OK了，但你可能会发现在hive中使用spark引擎时返回3号错误，总之就是spark运行不正常，这时可以使用spark自带的example进行测试诊断（cd到spark bin目下）：<code>./spark-submit --master yarn --class org.apache.spark.examples.SparkPi ../lib/spark-examples-1.6.0-cdh5.15.0-hadoop2.6.0-cdh5.15.0.jar 10</code>，具体example jar路径及文件名自行查看。运行起来后有一个异常解决一个异常，直到跑出结果为止，没本人测试中发现以下问题：</li></ol><hr><ul><li><p><strong>没有jackson模块</strong>：WTF，官网下载的spark居然包都不带全，随后查了一下cdh版本确实没带jackson的相关包，然后去maven官网下载(三个都要下载)，放到<code>{HADOOP_HOME}/share/hadoop/common/lib</code>下，至于为什么放在这儿而不是spark lib，这是因为我们在前面配置了<code>SPARK_DIST_CLASSPATH</code>（看不明白就在shell中echo一下），它会加入到spark类路径下，这个路径就包含上面的<code>{HADOOP_HOME}/share/hadoop/common/lib</code>，而且它下面还有jackson的其他包，顺理成章就放这儿了。随后再试！</p><hr></li><li><p><strong>jackson版本问题</strong>：WTF，这回找到jackson了，但jackson内部抛异常了，上网查发现是版本问题，于是按热心网友推荐采用2.4.4的版本，这回不抛异常了！</p><hr></li><li><p><strong>无限ACCEPT</strong>：虽然异常是没了，可这个程序一直是ACCEPT（等一个小时了），然后又上网搜索找到部分答案，测试无果，再回头看前面的配置，发现sparkk-env.sh中<code>SPARK_MASTER_IP</code>和<code>SPARK_MASTER_HOST</code>跟那些傻屌网友一样配成了master，可是我的机器不叫master，所以yarn找不到执行机器，也就无法分配内存，遂更改为localhost(本篇文章开头配置已更改)，然后 everything is OK！</p><hr></li><li><p>如果你的机器内存较小，导致分配资源缓慢，可适当调整一下<code>${HADOOP_HOME}/etc/hadoop/capacity-scheduler.xml</code>中的<code>yarn.scheduler.capacity.maximum-am-resource-percent</code>，可以由0.1调整为0.5，它表示yarn所管理的资源中，最多可以有多少资源可以用来运行application master，即控制当前激活状态的应用，默认是10%，在我们自己机器上来说太小了，因此可适当调大比例。</p></li></ul><hr><ol start="3"><li>终极测试：<img src="/2018/12/02/hive-on-spark/001.png" title="Hive on Spark 测试结果"></li></ol>]]></content>
    
    <summary type="html">
    
      作为大数据开发人员，一直将精力放在业务上，很久没有关注大数据工具hive了。最近在写一个UDF函数时发现在hive(mr)引擎能通过，在spark引擎下却报错，于是就借此机会粗略研究一下hive on mr、hive on spark和spark sql等内容。本篇为整个系列开篇，介绍了MAC下Hive on spark的环境搭建，及遇到的坑。
    
    </summary>
    
      <category term="大数据" scheme="http://blog.zjee.ml/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="hive" scheme="http://blog.zjee.ml/tags/hive/"/>
    
      <category term="spark" scheme="http://blog.zjee.ml/tags/spark/"/>
    
      <category term="hadoop" scheme="http://blog.zjee.ml/tags/hadoop/"/>
    
      <category term="大数据" scheme="http://blog.zjee.ml/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>RPC框架之Thrift</title>
    <link href="http://blog.zjee.ml/2018/11/29/thrift-grama/"/>
    <id>http://blog.zjee.ml/2018/11/29/thrift-grama/</id>
    <published>2018-11-29T05:37:11.000Z</published>
    <updated>2019-12-28T14:54:13.451Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h3><p>​        Thrift 接口定义语言 Thrift 接口定义语言(IDL, Interface Definition Language)中允许使用的是 thrift types。每个 thrift 文件主要有 hearder，类型定义，异常及服务组成，每个 thrift 文档包含 0 个或多个 headers 以及 0 个或多个 definitions。</p><h4 id="1、thrift-文件的组成"><a href="#1、thrift-文件的组成" class="headerlink" title="1、thrift 文件的组成"></a>1、thrift 文件的组成</h4><ul><li>Header ：header 可以是 thrift include，C++ include，或者是 namespace 声明。 </li><li><p>Thrift include 的目的是使得其他 thrift 文件中的所有定义都能够通过 include 声明添加到该 thrift 文档产生的代码中。 语法：<code>include &quot;../../***.thrift&quot;</code> ，被引用的 thrift 文件产生的代码中的头文件即可包含在 thrift 产生的代码的头部，使得其能够使用、访问。 </p></li><li><p>C++ include 能够将 C++定义的头文件添加到该 thrift 文件产生的 C++代码中。 语法：<code>cpp_include &quot;../../***.h&quot;</code> ，被引用的.h 文件将包含到 thrift 产生的代码的头部。 </p></li><li><p>namespace 的声明方式采用为 namespaces/package/module/etc。namespace scope 表示该 namespace 应用于哪种编程语言，若 scope 的取值为“*”，则表示该 namespace 适用于所有的目标语言。 语法： <code>namespace namespaceScope 名称</code>，其中namespaceScope 的取值有<code>*| cpp | java | py | perl | rb | cocoa | csharp</code>。 </p></li></ul><h4 id="2、Definition"><a href="#2、Definition" class="headerlink" title="2、Definition"></a>2、Definition</h4><p> thrift 中可以定义的类型有 const | typedef | enum | struct | exception | service </p><ul><li>const 语法： <code>const 字段类型 标识符 = 值</code></li><li>typedef 语法： <code>typedef 为一个类型创建一个别名</code></li><li>enum 语法： <code>enum 标识符 {***，***，…}</code>。其中，第一个值的取值默认为 0。 </li><li>struct 语法： <code>struct 标识符 { Field* }</code>。其中，每个 Field 的定义语法为： <code>FieldId: (required | optional) FieldType Identifier ( = value)</code>。 </li><li>exception： Exceptions 的定义与 struts 的定义相似，exception 中每个 field 的定义必须唯一 语法： <code>exception 标识符 { Field* }</code></li><li>service： Service 定义了 server 端提供的功能集合的接口。一个 service 可以继承另一个 service。 语法： <code>service 标识符 (extends otherService) { Function* }</code></li></ul><h3 id="二、类型详解"><a href="#二、类型详解" class="headerlink" title="二、类型详解"></a>二、类型详解</h3><p>Thrift类型系统包括<strong>预定义基本类型</strong>，<strong>用户自定义结构体</strong>，<strong>容器类型</strong>，<strong>异常</strong>和<strong>服务</strong>定义。</p><h4 id="1、基本类型"><a href="#1、基本类型" class="headerlink" title="1、基本类型"></a>1、基本类型</h4><ul><li>bool: 布尔类型，占一个字节</li><li>byte: 有符号字节 </li><li>i16：16位有符号整型 </li><li>i32：32位有符号整型 </li><li>i64：64位有符号整型 </li><li>double：64位浮点数 </li><li>string：未知编码或者二进制的字符串 </li><li>注意：<strong><em>thrift不支持无符号整形，因为很多目标语言不存在无符号整形（比如java）</em></strong> </li></ul><h4 id="2、容器类型"><a href="#2、容器类型" class="headerlink" title="2、容器类型"></a>2、容器类型</h4><ul><li>List<t1>：一系列t1类型的元素组成的有序列表，元素可以重复，映射到Java的ArrayList，c++的vector，脚本语言的Arrays等。 </t1></li><li>Set<t1>：一些t1类型的元素组成的无序集合，元素唯一不重复，映射到Java的HashSet，c++的STL中的set。 </t1></li><li>Map&lt;t1,t2&gt;：key/value对，key唯一，映射到Java的HashMap， c++的STL中的map。 </li><li>容器中的元素类型可以是除service以外的任何合法的thrift类型，包括结构体和异常类型 。</li></ul><h4 id="3、结构体和异常"><a href="#3、结构体和异常" class="headerlink" title="3、结构体和异常"></a>3、结构体和异常</h4><ul><li>Thrift结构体在概念上同c语言的<strong>结构体</strong>类似，在面向对象语言中，thrift结构体将被转化为<strong>类</strong>。 </li><li>thrift 结构体之间<strong><em>不能继承</em></strong>，每个结构体都有一组类型定义的字段，每个 field 都有一个唯一的命名标识符。 </li><li>异常在语法和功能上类似于结构体，只是异常使用关键字<code>exception</code>而不是struct关键字来声明。但它在语义上不同于结构体，当定义一个RPC服务时，开发者可能需要声明一个远程方法抛出一个异常。 </li><li>异常可以继承目标编程语言的异常类，目的是与给定编程语言的异常处理功能无缝的结合。 </li></ul><h4 id="4、服务"><a href="#4、服务" class="headerlink" title="4、服务"></a>4、服务</h4><ul><li>Thrift中服务定义的方式和语法等同于面向对象语言中定义<strong>接口</strong>。Thrift编译器会产生实现接口的client和server stubs。 </li><li>一个服务包括一个命名的 functions 集合，每个 function 有一个<strong>参数列表</strong>，一个<strong>返回值</strong>以及抛出或产生的一个<strong>异常列表</strong>。这些异常是 thrift 本身的<code>exception</code>类型。 </li><li>注意： void 是一种确定的 function 返回值类型，<strong><em>oneway 关键词（加在 void 之前）等同于 <u>async</u></em></strong>，这种方法产生的客户端代码无需等待 server 端的响应（异步调用）。 </li><li>单纯的 void 函数将会为 client 返回一个确认，用于表示操作在 server 端已经执行完毕。 </li><li><strong><em>当调用 oneway 方法时，client 端只保证 request 已成功发送至 transport 层，不能保证 server 端看到过这个 message，单个 client connection 的 oneway/async 方法可以在 server 端并行执行。</em></strong>  </li></ul><p>####5、类型重定义</p><ul><li>Thrift支持C/C++风格的typedef: <code>typedef i32 MyInteger /*a typedef Tweet ReTweet*/</code></li><li>说明：末尾没有逗号、分号，struct可以使用typedef </li></ul><h3 id="三、数据结构定义"><a href="#三、数据结构定义" class="headerlink" title="三、数据结构定义"></a>三、数据结构定义</h3><h4 id="1、常量"><a href="#1、常量" class="headerlink" title="1、常量"></a>1、常量</h4><p>​    Thrift允许用户定义常量，复杂的类型和结构体可以使用JSON形式表示： </p><ul><li><code>const i32 INT_CONST = 1234;</code>  </li><li><code>const map&lt;string,string&gt; MAP_CONST = {&quot;hello&quot;: &quot;world&quot;, &quot;goodnight&quot;: &quot;moon&quot;}</code></li><li>说明：<strong>分号是可选的</strong>，支持十六进制赋值 </li></ul><h4 id="2、枚举类型"><a href="#2、枚举类型" class="headerlink" title="2、枚举类型"></a>2、枚举类型</h4><p>可以像C/C++那样定义枚举类型，如： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> TweetType</span><br><span class="line">&#123;</span><br><span class="line">TWEET,</span><br><span class="line">RETWEET = <span class="number">2</span>,</span><br><span class="line">DM = <span class="number">0xa</span>,</span><br><span class="line">REPLY</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>编译器默认从0开始赋值 </li><li>可以赋予某个常量 </li><li>允许常量是十六进制整数 </li><li>给常量赋缺省值时，使用常量的全称 </li><li>不同于protocol buffer，<strong>thrift不支持枚举类嵌套，枚举常量必须是32位正整数</strong> </li></ul><h4 id="3、定义结构体"><a href="#3、定义结构体" class="headerlink" title="3、定义结构体"></a>3、定义结构体</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tweet</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="number">1</span>: required i32 userId;                  <span class="comment">// a</span></span><br><span class="line">    <span class="number">2</span>: required <span class="built_in">string</span> userName;             <span class="comment">// b</span></span><br><span class="line">    <span class="number">3</span>: required <span class="built_in">string</span> text;</span><br><span class="line">    <span class="number">4</span>: optional Location loc;                <span class="comment">// c</span></span><br><span class="line">    <span class="number">16</span>: optional <span class="built_in">string</span> language = <span class="string">"english"</span> <span class="comment">// d</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct Location</span><br><span class="line">&#123;</span><br><span class="line">    <span class="number">1</span>: required <span class="keyword">double</span> latitude;</span><br><span class="line">    <span class="number">2</span>: required <span class="keyword">double</span> longitude;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>每一个域都有一个唯一的正整数标识符（如示例中冒号前的数字），称为数字标签，这些数字标签在传输时用来确定序列化顺序，一旦使用消息类型，标签不可改变。（随着项目的进展，可以变更Thrift文件，最好不要改变原有的数字标签） </li><li>每个域可以标识为<code>required（必选的）</code>或者<code>optional(可选的)</code>（也可以不注明） </li><li>结构体可以包含其他结构体 </li><li>域可以有缺省值 </li><li>一个thrift中可以定义多个结构体，并存在引用关系 </li><li>规范的struct定义中的每个域均会使用required或者optional关键字进行标识。如果required标识的域没有赋值，thrift将给予提示。<strong>如果optional标识的域没有赋值，该域将不会被序列化传输</strong>。如果某个optional标识域有缺省值而用户没有重新赋值，则该域的值一直为缺省值。 </li><li>与service不同，<strong><em>结构体不支持继承</em></strong>，即一个结构体不能继承另一个结构体。 </li></ul><h4 id="4、定义服务"><a href="#4、定义服务" class="headerlink" title="4、定义服务"></a>4、定义服务</h4><p>​        在流行的序列化/反序列化框架（如protocol buffer）中，thrift是少有的提供多语言间RPC服务的框架。Thrift编译器会根据选择的目标语言为server产生服务接口代码，为client产生桩代码。 </p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//“Twitter”与“&#123;”之间需要有空格！！！</span></span><br><span class="line"><span class="comment">//方法定义方式类似于C语言中的方式，它有一个返回值，一系列参数和可选的异常</span></span><br><span class="line"><span class="comment">//注意，参数列表和异常列表定义方式与结构体中域定义方式一致</span></span><br><span class="line"><span class="comment">//”oneway”标识符表示client发出请求后不必等待回复（非阻塞）直接进行下面的操作，”oneway”方法的返回值必须是void</span></span><br><span class="line">service Twitter &#123;</span><br><span class="line">void ping(),                                    // a</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">postTweet</span><span class="params">(<span class="number">1</span>:Tweet tweet)</span></span>;                  <span class="comment">// b</span></span><br><span class="line"><span class="function">TweetSearchResult <span class="title">searchTweets</span><span class="params">(<span class="number">1</span>:<span class="built_in">string</span> query)</span></span>; <span class="comment">// c</span></span><br><span class="line"><span class="function">oneway <span class="keyword">void</span> <span class="title">zip</span><span class="params">()</span>                               <span class="comment">// d</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>函数定义可以使用<strong>逗号</strong>或<strong>分号</strong>标识结束 </li><li>参数可以是基本类型或者结构体，参数只能是只读的（const），不可以作为返回值（参数不可携带数据返回） </li><li>返回值可以是基本类型或者结构体 </li><li>返回值可以是void </li><li>Service支持继承，一个service可使用extends关键字继承另一个service </li></ul><h3 id="四、注释、命名空间、文件包含"><a href="#四、注释、命名空间、文件包含" class="headerlink" title="四、注释、命名空间、文件包含"></a>四、注释、命名空间、文件包含</h3><h4 id="1、注释"><a href="#1、注释" class="headerlink" title="1、注释"></a>1、注释</h4><p>Thrift支持shell注释风格、C/C++语言中的单行或多行注释风格</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># This is a valid comment.  shell风格注释</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* This is a multi-line comment.</span></span><br><span class="line"><span class="comment">* Just like in C.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// C++/Java style single-line comments work just as well.</span></span><br></pre></td></tr></table></figure><h4 id="2、命名空间"><a href="#2、命名空间" class="headerlink" title="2、命名空间"></a>2、命名空间</h4><p>​       Thrift中的命名空间同C++中的namespace和java中的package类似，它们均提供了一种组织（隔离）代码的方式。因为每种语言均有自己的命名空间定义方式（如python中有module），thrift允许开发者针对特定语言定义namespace： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> cpp com.example.project  <span class="comment">// a</span></span><br><span class="line"><span class="keyword">namespace</span> java com.example.project <span class="comment">// b</span></span><br></pre></td></tr></table></figure><h4 id="3、文件包含"><a href="#3、文件包含" class="headerlink" title="3、文件包含"></a>3、文件包含</h4><p>Thrift允许文件包含，需要使用thrift文件名作为前缀访问被包含的对象，如： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">include <span class="string">"tweet.thrift"</span>           <span class="comment">// a</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TweetSearchResult</span> &#123;</span></span><br><span class="line"><span class="number">1</span>: <span class="built_in">list</span>&lt;tweet.Tweet&gt; tweets; <span class="comment">// b</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>thrift文件名需要双引号包含，末尾没有逗号或者分号 </li><li>注意tweet前缀 ，前缀为引入的thrift文件名（不含后缀）</li></ul>]]></content>
    
    <summary type="html">
    
      Thrift is an interface definition language and binary communication protocol used for defining and creating services for numerous languages. It forms a remote procedure call (RPC) framework and was developed at Facebook for &quot;scalable cross-language services development&quot;.
    
    </summary>
    
      <category term="后端开发基础" scheme="http://blog.zjee.ml/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="thrift" scheme="http://blog.zjee.ml/tags/thrift/"/>
    
      <category term="rpc" scheme="http://blog.zjee.ml/tags/rpc/"/>
    
  </entry>
  
  <entry>
    <title>代码版本控制系统Git</title>
    <link href="http://blog.zjee.ml/2018/11/29/learn-git/"/>
    <id>http://blog.zjee.ml/2018/11/29/learn-git/</id>
    <published>2018-11-29T05:20:32.000Z</published>
    <updated>2019-12-28T14:53:56.906Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、创建本地仓库的两种途径："><a href="#1、创建本地仓库的两种途径：" class="headerlink" title="1、创建本地仓库的两种途径："></a>1、创建本地仓库的两种途径：</h4><ol><li><p>从远程仓库克隆一份：<code>git clone [remote git url]</code></p></li><li><p>创建一个目录：<code>mkdir git</code>, 然后用 <code>git init</code> 去初始化这个目录，使之成为一个git仓库。</p></li></ol><h4 id="2、git-config文件配置："><a href="#2、git-config文件配置：" class="headerlink" title="2、git config文件配置："></a>2、git config文件配置：</h4><ol><li>配置全局用户名：<code>git config --global user.name &quot;xxxxxx&quot;</code></li><li>配置全局E-mail：<code>git config --global user.email &quot;xxxxxx@xx.com&quot;</code>, 如果需要在项目中配置不同的用户名和邮件，则只需要在项目目录下执行上面的命令，不带 <code>--global</code> 即可。</li><li>查看配置文件: <code>git config --list</code></li></ol><h4 id="3、将本地仓库和远程仓库关联（适用于git-init创建的仓库）："><a href="#3、将本地仓库和远程仓库关联（适用于git-init创建的仓库）：" class="headerlink" title="3、将本地仓库和远程仓库关联（适用于git init创建的仓库）："></a>3、将本地仓库和远程仓库关联（适用于git init创建的仓库）：</h4><ol><li>添加远程仓库：<code>git remote add [host-name] [git-url]</code>, 一般host-name取<code>origin</code>, 这也是git默认主机名。</li><li>拉取本地还没有的远程仓库的信息：<code>git fetch [host-name] [branch-name]</code>,从远程仓库下载制定分支的信息到本地，但不会与本地的仓库合并，需手动合并<code>git merge [host-name] [branch-name]</code>，如：<code>git fetch origin dev; git merge origin dev;</code></li><li>拉取远程信息，并尝试与本地合并(相当于fetch和merge的合体)：<code>git pull [host-name] [branch-name]</code>, 有冲突需手动解决再手动合并。</li><li>查看远程仓库信息：<code>git remote -v</code>。</li></ol><h4 id="4、将本地信息推送到远程"><a href="#4、将本地信息推送到远程" class="headerlink" title="4、将本地信息推送到远程"></a>4、将本地信息推送到远程</h4><ol><li><code>git push [host] [branch]</code>，如果远程没有对应分支，则需要带上 <code>-u</code> 参数创建相应分支。</li><li>如果本地分支没有与远程分支关联，则需要：<code>git branch --set-upstream [remote-branch]</code>建立关联。</li><li>如果远程分支有其他人提交过，则必须先<code>git pull</code>,尝试与本地合并合并（有冲突解决冲突）后才可以push。</li></ol><h4 id="5、添加文件，修改，提交修改"><a href="#5、添加文件，修改，提交修改" class="headerlink" title="5、添加文件，修改，提交修改"></a>5、添加文件，修改，提交修改</h4><ol><li>添加文件到暂存区：<code>git add [file-name or directory-name]</code>,可以使用通配符。</li><li>所有做的修改都需要使用<code>git add</code>后在进行<code>git commit</code>操作。</li><li>提交修改到本地仓库：<code>git commit -m &#39;说明信息&#39;</code>。</li><li>撤销修改/恢复删除文件：<code>git check --[file-name]</code>，注意两个’-‘。</li><li>查看git状态：<code>git status</code>。</li><li>查看commit日志：<code>git log</code>，单行显示：<code>git log --pretty=oneline</code>。</li><li>查看上次的修改：<code>git diff file-name</code>。</li><li>从暂存区删除一个文件：<code>git rm file-name</code>。</li></ol><h4 id="6、创建、切换分支"><a href="#6、创建、切换分支" class="headerlink" title="6、创建、切换分支"></a>6、创建、切换分支</h4><ol><li>创建并切换分支：<code>git checkout -b [branch-name]</code>，他相当于<code>git branch [branch-name]; git checkout [branch-name];</code>。</li><li>切换分支：<code>git checkout [branch-name]</code>。</li><li>删除分支：<code>git branch -d &lt;name&gt;</code>，使用<code>-D</code>强行删除。</li><li>查看分支合并情况：<code>git log --graph --pretty=oneline --abbrev-commit</code></li></ol><h4 id="7、版本回退"><a href="#7、版本回退" class="headerlink" title="7、版本回退"></a>7、版本回退</h4><ol><li>本地仓库回退：<code>git reset --hard HEAD^</code>，一个<code>^</code>表示回退一个版本，两个<code>^^</code>表示回退两个版本，一次类推，回退100个版本可以这样写<code>HEAD~100</code>，也可以指定回退到具体某个版本<code>git reset --hard 1094adb</code>。</li><li>重返未来：使用<code>git reflog</code>查看操作历史，找到要回去的版本号，使用1中命令即可回到未来。</li></ol><h4 id="8、保存工作现场"><a href="#8、保存工作现场" class="headerlink" title="8、保存工作现场"></a>8、保存工作现场</h4><ol><li><code>git stash</code>，保存工作现场后，working dir就是干净的，这时就可以创建别的分支，进行别的工作，比如紧急修复bug场景。PS：如果当前工作区不干净git不允许创建新的分支。</li><li>恢复工作区：<code>git stash pop</code>，它相当于<code>git stash apply; git stash drop;</code>，恢复并删除stash内容。</li></ol><h4 id="9、标签管理"><a href="#9、标签管理" class="headerlink" title="9、标签管理"></a>9、标签管理</h4><ol><li>commit打标签：<code>$ git tag v0.9 [-m &#39;说明文字&#39;] f52c633</code>，可以省略commit号，默认打在最新commit上。</li><li>使用<code>git show tag-name</code>查看说明文字。</li><li>使用<code>git tag</code>查看所有标签。</li><li>使用<code>git tag -d v0.1</code>删除标签。</li><li>将标签推送到远程：<code>git push origin &lt;tagname&gt;</code>，使用<code>git push origin --tags</code>推送全部tag。</li><li>使用<code>git push origin :refs/tags/&lt;tagname&gt;</code>可以删除一个远程标签，需要先删除本地对应标签。</li></ol>]]></content>
    
    <summary type="html">
    
      Git是目前世界上最先进的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。因此Git也是程序猿入门的必备技能之一，有了它我们就可以在代码的世界里穿越古今，自由翱翔！
    
    </summary>
    
      <category term="后端开发基础" scheme="http://blog.zjee.ml/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="git" scheme="http://blog.zjee.ml/tags/git/"/>
    
  </entry>
  
</feed>
