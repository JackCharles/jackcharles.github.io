<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>江影不沉浮</title>
  
  <subtitle>You can, just if you want!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.zjee.ml/"/>
  <updated>2019-08-23T16:00:00.000Z</updated>
  <id>http://blog.zjee.ml/</id>
  
  <author>
    <name>jackcharles</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java中的同步、互斥机制</title>
    <link href="http://blog.zjee.ml/2019/08/24/java-lock-util/"/>
    <id>http://blog.zjee.ml/2019/08/24/java-lock-util/</id>
    <published>2019-08-23T16:00:00.000Z</published>
    <updated>2019-08-23T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>在Java多线程编程中，同步和互斥是一个不可避免的话题。Java为开发人员提供了以下几种锁机制：</p><ol><li>synchronized关键字</li><li>Lock接口</li><li>ReadWriteLock接口</li></ol><p>这几种锁机制在日常编程中用的很多，但它们有什么联系和区别呢？</p><h3 id="一、Synchronized"><a href="#一、Synchronized" class="headerlink" title="一、Synchronized"></a>一、Synchronized</h3><ol><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```java</span><br><span class="line">public void consumer1()&#123;</span><br><span class="line">//synchronize 用在代码块上，表示该代码块互斥</span><br><span class="line">synchronized (this) &#123; </span><br><span class="line">resource -- ;</span><br><span class="line">System.out.println(&quot; resource: &quot; + resource);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//synchronize用在方法上，表示整个方法调用互斥</span><br><span class="line">public synchronized boolean consumer2()&#123; </span><br><span class="line">resource -- ;</span><br><span class="line">System.out.println(&quot;resource: &quot; + resource);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//synchronize用在静态方法上，使用Class对象作为对象锁</span><br><span class="line">public static synchronized boolean consumer3()&#123; </span><br><span class="line">resource -- ;</span><br><span class="line">System.out.println(&quot;resource: &quot; + resource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><figcaption><span>```new Object()```。这里需要注意一点，不要使用```String```或常用的数字对象去作为锁对象，因为他们在JVM缓存在一个常量池中，是一个共享对象，如果多处使用这些对象作为锁对象，可能会导致不可预期的死锁。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. **可重入**是锁的一个重要特性，它是指一个线程重复获取获取它***已经拥有的锁***，如果可以获取到则表示该锁是**可重入**的，否则就是**不可重入**的。```synchronized```是**可重入**的，示例如下：</span><br><span class="line"></span><br><span class="line">   ```java</span><br><span class="line">   public class Test &#123;</span><br><span class="line">       private int resource = 100;</span><br><span class="line">       public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">           Test test = new Test();</span><br><span class="line">           test.consumer1();</span><br><span class="line">       &#125;</span><br><span class="line">   </span><br><span class="line">       public synchronized void consumer1() &#123; //第一次获取锁</span><br><span class="line">           resource--;</span><br><span class="line">           System.out.println(&quot;consumer1: &quot; + resource);</span><br><span class="line">           this.consumer2(); //调用另外一个synchronized修饰的方法</span><br><span class="line">       &#125;</span><br><span class="line">   </span><br><span class="line">       public synchronized void consumer2() &#123; //第二次获取锁</span><br><span class="line">           resource--;</span><br><span class="line">           System.out.println(&quot;consumer2: &quot; + resource);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   /**</span><br><span class="line">    * 输出：</span><br><span class="line">    * consumer1: 99</span><br><span class="line">    * consumer2: 98</span><br><span class="line">    */</span><br></pre></td></tr></table></figure></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">4. 总结：</span><br><span class="line">   - synchronized优点：使用简单，速度快(JVM底层支持，编译后会形成`monitorenter`、`monitorenter`两条指令)，自动释放锁，保证了互斥性和变量修改的可见性（一个线程对变量的修改对其他线程立即可见）。</span><br><span class="line">   - synchronized缺点：synchronized获取锁的过程无法被中断，也不能尝试非阻塞、超时返回等策略获取锁，这在高并发环境下将会带来很大的性能损失。</span><br><span class="line"></span><br><span class="line">### 二、Lock</span><br><span class="line"></span><br><span class="line">1. Lock是Java5开始提供的一个JDK层面的用于控制同步互斥的接口，它位于```java.util.concurrent.locks```包下。此外，该包下还有Condition和ReadWriteLock两兄弟，它们都是为多线程同步、互斥服务的，其类图如下：</span><br><span class="line"></span><br><span class="line">   ![Lock家族类图](C:\Users\zhongjie\Desktop\Lock.png &apos;Lock家族类图&apos;)</span><br><span class="line"></span><br><span class="line">   我们可以看到Lock接口下一般供开发人员直接使用的实现是`ReentrantLock`，这个类基本解决了`synchronized`存在的不足，我们看一下Lock接口提供的方法：</span><br><span class="line">   </span><br><span class="line">   ```java</span><br><span class="line">   public interface Lock &#123;</span><br><span class="line">       //开始获取锁(进入临界区,阻塞方法)</span><br><span class="line">       void lock(); </span><br><span class="line">       //开始获取锁，同时可以响应中断事件，可在捕获InterruptedException异常后做后续处理(阻塞方法)</span><br><span class="line">       void lockInterruptibly() throws InterruptedException; </span><br><span class="line">       //尝试获取锁，无论成功或失败都立即返回(非阻塞)</span><br><span class="line">       boolean tryLock();</span><br><span class="line">       //尝试获取锁，如果成功立即返回，否则等待给定时间后返回，并且等待中还可以响应中断事件</span><br><span class="line">       boolean tryLock(long var1, TimeUnit var3) throws InterruptedException;</span><br><span class="line">       //释放锁</span><br><span class="line">       void unlock();</span><br><span class="line">       //条件变量，用于线程间通信及同步协作(生产者、消费者模型会用到)</span><br><span class="line">       Condition newCondition();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ol><p>   通过Lock接口提供的方法我们看到Lock锁更加细粒度化，它可以让开发人员根据实际需求灵活处理获取锁期间的等待行为。使用Lock一定要<strong>手动释放锁</strong>，这是很重要的一点，如果处理不慎将会导致不可预期的死锁，一般为了可靠释放锁，会将unlock调用放在<code>finally</code>块中。</p><ol start="2"><li><p>说完Lock接口我们来看一下它的实现<code>ReentrantLock</code>，从字面上就知道这个锁是一个<strong>可重入的</strong>，下面是该类提供的方法（仅列举部分方法）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//构造方法，默认非公平锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="comment">//构造方法，传入一个boolean值指定是否需要公平锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> var1)</span> </span>&#123;...&#125;</span><br><span class="line"><span class="comment">//获取当前线程对该锁的持有数量(可重入特性)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getHoldCount</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line"><span class="comment">//是否被当前线程持有</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isHeldByCurrentThread</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line"><span class="comment">//是否成功获取锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line"><span class="comment">//是否公平锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isFair</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line"><span class="comment">//返回当前持有此锁的线程</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Thread <span class="title">getOwner</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line"><span class="comment">//是否有可能正在等待获取此锁的线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedThreads</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line"><span class="comment">//查询指定线程是否正在等待获取此锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedThread</span><span class="params">(Thread var1)</span> </span>&#123;...&#125;</span><br><span class="line"><span class="comment">//返回可能获取此锁的等待线程数量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getQueueLength</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line"><span class="comment">//返回可能正在等待此锁的线程集合</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Collection&lt;Thread&gt; <span class="title">getQueuedThreads</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的构造方法可知，<code>ReentrantLock</code>默认是<strong>非公平锁</strong>，但可根据需要配置成<strong>公平锁</strong>。除此之外，它还提供了一系列查询方法，用于查询当前锁的获取状态，这里不一一描述了。</p></li><li><p>基础用法：</p><ul><li><p>lock：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br><span class="line">lock.lock(); <span class="comment">//lock</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line"><span class="comment">//handle exception</span></span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock(); <span class="comment">//unlock</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>lockInterruptibly：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123; </span><br><span class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br><span class="line">    lock.lockInterruptibly(); <span class="comment">//向上抛出中断异常，也可以自己try cache处理</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//Do something</span></span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line"><span class="comment">//handle exception</span></span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock(); <span class="comment">//unlock</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>tryLock：（两种使用方式）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非阻塞</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">if</span>(lock.tryLock()) &#123; <span class="comment">//尝试获取锁，这个调用不会阻塞</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//do something</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">//handle exception</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock(); <span class="comment">//unlock</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//获取锁失败</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//阻塞，可设置超时时间，可中断</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAnything</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     Lock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">if</span>(lock.tryLock(<span class="number">5</span>, TimeUnit.SECONDS)) &#123; <span class="comment">//超时设为5s</span></span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">                 <span class="comment">//do something</span></span><br><span class="line">             &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                 <span class="comment">//handle exception</span></span><br><span class="line">             &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                 lock.unlock(); <span class="comment">//unlock</span></span><br><span class="line">             &#125;</span><br><span class="line">         &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="comment">//获取锁失败</span></span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">         <span class="comment">//处理中断事件</span></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>在上面的代码演示中，不难发现unlock操作都是放在finally语句中，而获取锁却不再对应try-catch中，这是因为对于非阻塞或可中断的获取锁方发来说，如果获取锁失败，后面再去调用unlock就会抛出<code>IllegalMonitorStateException</code>异常，这会带来不必要的麻烦，所以一般获取锁不成功就不会执行unlock。对于可中断的锁一般采用向上抛出，这是因为多线程环境下获取锁失败的后该是各线程自行采取相应处理策略，而不是由被调用者处理。</p></li></ul></li></ol><h3 id="三、ReadWriteLock"><a href="#三、ReadWriteLock" class="headerlink" title="三、ReadWriteLock"></a>三、ReadWriteLock</h3><ol><li><p>JDK中除提供了基本的满足同步、互斥的Lock机制外，还提供了一种特殊的读写锁模型，该模型一定程度上降低了互斥要求，带来更好的性能体验。读写锁具体来说分为两方面：</p><ul><li>ReadLock：读锁不同线程可以重复获取（与可重入概念不一样），即一个资源是可以并发读的，资源加了读锁后只能再加读锁。</li><li>WriteLock：写锁是完全互斥的，即一个资源加写锁后不能再施加其他锁，当然加了读锁的资源也不能加写锁。</li></ul></li><li><p>读写锁在数据库中运用非常广泛，比如一行数据可以多个客户端读取，但不能同时写，也不能边读边写。下面演示读写锁的具体用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ReadWriteLock readWriteLock;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; resource; <span class="comment">//模拟公共资源</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LockTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        readWriteLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">        resource = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        resource.add(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//主方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        LockTest lockTest = <span class="keyword">new</span> LockTest();</span><br><span class="line">        Thread r1 = <span class="keyword">new</span> Thread(() -&gt; &#123; <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;++i) &#123; lockTest.read();&#125; &#125;, <span class="string">"reader1"</span>);</span><br><span class="line">        Thread r2 = <span class="keyword">new</span> Thread(() -&gt; &#123; <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;++i) &#123; lockTest.read();&#125; &#125;, <span class="string">"reader2"</span>);</span><br><span class="line">        Thread w1 = <span class="keyword">new</span> Thread(()-&gt;&#123; <span class="keyword">try</span>&#123; lockTest.write(); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"writer1被中断"</span>); &#125;&#125;, <span class="string">"writer1"</span>);</span><br><span class="line">        Thread w2 = <span class="keyword">new</span> Thread(()-&gt;&#123; <span class="keyword">try</span>&#123; lockTest.write(); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"writer2被中断"</span>); &#125;&#125;, <span class="string">"writer2"</span>);</span><br><span class="line"></span><br><span class="line">        r1.start();</span><br><span class="line">        r2.start();</span><br><span class="line">        w2.start();</span><br><span class="line">        w1.start();</span><br><span class="line">        Thread.sleep(<span class="number">3</span>);<span class="comment">//等待3ms</span></span><br><span class="line">        w1.interrupt(); <span class="comment">//尝试中断writer1的阻塞</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取资源</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        readWriteLock.readLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">": "</span> +resource);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readWriteLock.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写入资源</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        readWriteLock.writeLock().lockInterruptibly();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            resource.add(Thread.currentThread().getName());</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">": add resource"</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readWriteLock.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**输出：</span></span><br><span class="line"><span class="comment"> * reader2: [main]</span></span><br><span class="line"><span class="comment"> * reader1: [main]</span></span><br><span class="line"><span class="comment"> * writer2: add resource</span></span><br><span class="line"><span class="comment"> * writer1被中断</span></span><br><span class="line"><span class="comment"> * reader2: [main, writer2]</span></span><br><span class="line"><span class="comment"> * reader1: [main, writer2]</span></span><br><span class="line"><span class="comment"> * reader1: [main, writer2]</span></span><br><span class="line"><span class="comment"> * reader2: [main, writer2]</span></span><br><span class="line"><span class="comment"> * reader1: [main, writer2]</span></span><br><span class="line"><span class="comment"> * reader2: [main, writer2]</span></span><br><span class="line"><span class="comment"> * reader1: [main, writer2]</span></span><br><span class="line"><span class="comment"> * reader2: [main, writer2]</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>上面演示了并发环境下ReadWriteLock的使用，这里需要注意的是最终的输出不是一个固定结果，如果writer1在3ms内获取到锁就不会输出<code>writer1被中断</code>（<code>w1.interrupt();</code>将会中断writer1里面的sleep），这个结果完全是随机的。虽然ReentrantReadWriteLock没实现Lock接口，但其内部类<code>ReentrantReadWriteLock.WriteLock</code>和<code>ReentrantReadWriteLock.ReadLock</code>实现了Lock接口，因此读写锁也具有Lock的全部特性。</p></li></ol><h3 id="四、相关概念"><a href="#四、相关概念" class="headerlink" title="四、相关概念"></a>四、相关概念</h3><ul><li><p>乐观锁/悲观锁</p><p>乐观锁和悲观锁不是一种具体的锁，而是对待并发的一种态度。<strong>悲观锁</strong>认为对于同一资源的并发访问一定会发生修改操作，不加锁的并发访问一定会出问题，因此一定要加锁。<strong>乐观锁</strong>则认为并发访问很少发生资源修改操作，即使发生也会采用不断尝试的方式更新资源，不加锁的并发访问是不会出问题的。悲观锁适合写操作多的场景，乐观锁适合读操作多的场景。Java中各种加锁编程就属于悲观锁范围，而使用concurrent包下的AtomicXXX实现原子操作就属于乐观锁范围，因为Atomic类型是使用<a href="https://segmentfault.com/a/1190000017943658" target="_blank" rel="noopener">CAS算法</a>实现原子操作的，并没有使用锁，属于无锁编程，一般来说乐观锁的性能好于悲观锁。</p></li><li><p>可重入锁</p><p>可重入是只可重复递归调用的锁，在加锁的方法类可递归调用该方法，并不会发生死锁。<code>ReentrantLock</code>和<code>synchronized</code>都是可重入锁。</p></li><li><p>独占锁（排它锁）/共享锁</p><p>独占锁即一个锁只能一个线程占有，如<code>ReentrantLock</code>、<code>ReentrantReadWriteLock.WriteLock</code>就是独占锁。共享锁可被多个线程共享，如<code>ReentrantReadWriteLock.ReadLock</code></p></li><li><p>公平锁/非公平锁</p><p>公平锁是指获取锁的顺序跟申请锁的顺序一致，反之亦然。</p></li><li><p>分段锁</p><p>分段锁是一种锁的设计，它的核心思想是减小加锁粒度。比如在<code>ConcurrentHashMap</code>中就采用分段锁的思想，ConcurrentHashMap中有16个锁，每个散列桶由第N%16个锁来保护，所以一次加锁理论上（与数据分布均匀程度有关）只锁定整个Map的1/16的数据，其他部分的数据访问不受限制，ConcurrentHashMap最多可支持16个线程的并发写入。同样在MySQL中也有类似的设计出现，比如行锁就是一种分段锁，更新数据时只需要锁定特定行，其他行可供正常访问。</p></li><li><p>偏向锁/轻量级锁/重量级锁</p><p>这3种分类非Java语言提供的特性，因此不做深入研究，可参考：<a href="https://www.cnblogs.com/wzj4858/p/8215369.html" target="_blank" rel="noopener">偏向锁/轻量级锁/重量级锁</a></p></li><li><p>自旋锁</p><p>自旋锁关注的是在获取锁的过程中线程处所处状态，当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将<strong>循环等待</strong>（不进入阻塞状态），然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环。注意，自旋锁的设计是为了减少线程状态切换带来的开销（用户态-&gt;内核态，active-&gt;blocked）,当加锁区域的代码执行的非常快时，该设计能大大提高性能。而加锁区域执行缓慢时则相反，自旋锁不会释放CPU资源，如果长时间处于自旋状态将严重拖累系统性能，所以是否采用自旋锁需要根据需求而定。</p></li></ul><h3 id="五、参考资料"><a href="#五、参考资料" class="headerlink" title="五、参考资料"></a>五、参考资料</h3><p>[1]. <a href="https://blog.csdn.net/justloveyou_/article/details/54972105" target="_blank" rel="noopener">Java 并发：Lock 框架详解</a></p><p>[2]. <a href="http://blog.itpub.net/31545684/viewspace-2375117/" target="_blank" rel="noopener">Java 种15种锁的介绍：公平锁，可重入锁，独享锁，互斥锁等等…</a></p><p>[3]. <a href="https://www.cnblogs.com/wzj4858/p/8215369.html" target="_blank" rel="noopener">javas的四种状态 无锁状态 偏向锁状态 轻量级锁状态 重量级锁状态</a></p><p>[4]. <a href="https://zhuanlan.zhihu.com/p/40729293" target="_blank" rel="noopener">面试必备之深入理解自旋锁</a></p><p>[5]. <a href="http://tool.oschina.net/apidocs/apidoc?api=jdk-zh" target="_blank" rel="noopener">JDK文档</a></p>]]></content>
    
    <summary type="html">
    
      并发编程中，锁是一个永远绕不过的话题，深入认识Java中的同步、互斥机制是Java并发编程的必经之路。本篇文章就Java原生锁机制做一个简单的描述，让自己能全面宏观认识整个框架，在工作学习中能正确、高效使用Java同步、互斥相关工具。
    
    </summary>
    
      <category term="Java" scheme="http://blog.zjee.ml/categories/Java/"/>
    
    
      <category term="多线程" scheme="http://blog.zjee.ml/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="Java锁机制" scheme="http://blog.zjee.ml/tags/Java%E9%94%81%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>MAC下 Hive on Spark 环境搭建</title>
    <link href="http://blog.zjee.ml/2018/12/02/hive-on-spark/"/>
    <id>http://blog.zjee.ml/2018/12/02/hive-on-spark/</id>
    <published>2018-12-02T13:02:57.000Z</published>
    <updated>2018-12-02T13:02:57.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、准备"><a href="#一、准备" class="headerlink" title="一、准备"></a>一、准备</h3><ol><li>jdk、hadoop、Hive、mysql和spark。为避免兼容问题，本人全部采用cdh版本，对应cdh5.15.0，不过貌似spark版本有点低，不过无所谓，毕竟只是实验。</li><li>由于本人之前搭建过kylin环境，因此hadoop和hive环境已经配置妥当，都是yarn管理下的伪分布式集群。</li><li>安装scala，mac下通过brew安装：<code>brew install scala</code>，网速慢可以使用代理或<a href="https://www.cnblogs.com/jay54520/p/6347729.html" target="_blank" rel="noopener">国内源</a>。</li><li><a href="https://www.cnblogs.com/binarylei/p/8903601.html" target="_blank" rel="noopener">hadoop</a>、<a href="https://www.cnblogs.com/wujiadong2014/p/6058552.html" target="_blank" rel="noopener">hive</a>、<a href="https://www.jianshu.com/p/e41b18a7e202" target="_blank" rel="noopener">spark</a>的基本概念，原理，运行方式可做一个初步了解，方便以后问题排查。</li></ol><h3 id="二、配置SPARK"><a href="#二、配置SPARK" class="headerlink" title="二、配置SPARK"></a>二、配置SPARK</h3><ol><li><p>在/etc/profile或~/.bash_profile（假设你没有使用zsh之类的shell）中加入SPARK_HOME环境变量，并将bin路径添加到PATH中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export SPARK_HOME=/Users/xxx/spark-1.6.0-cdh5.15.0</span><br><span class="line">export PATH=$PATH:$SPARK_HOME/bin</span><br></pre></td></tr></table></figure></li><li><p>在spark下的config目录中找到spark-env.sh和spark-defaults.conf(如果没有就自己创建)，然后添加如下配置:</p><p>spark-env.sh</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> !/usr/bin/env bash</span><br><span class="line">export SCALA_HOME=/usr/local/Cellar/scala/2.12.7 #注意scala版本</span><br><span class="line">export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home</span><br><span class="line">export HADOOP_HOME=/Users/xxx/hadoop-2.6.0-cdh5.15.0</span><br><span class="line">export HADOOP_CONF_DIR=$HADOOP_HOME/etc/hadoop #hadoop配置文件目录</span><br><span class="line">export YARN_CONF_DIR=$HADOOP_HOME/etc/hadoop #yarn配置文件目录(和hadoop配置在一起)</span><br><span class="line">export SPARK_MASTER_IP=localhost #master节点IP，本地搭建使用localhost</span><br><span class="line">export SPARK_MASTER_HOST=localhost #master机器名称，本地搭建可使用localhost代替</span><br><span class="line">export SPARK_EXECUTOR_MEMORY=512m #每个executor可分配的内存，可根据机器实际情况设置为512m到1g</span><br><span class="line">export SPARK_DRIVER_MEMORY=512m #driver可分配的内存，可根据机器实际情况设置为512m到1g</span><br><span class="line">export SPARK_DIST_CLASSPATH=$($&#123;HADOOP_HOME&#125;/bin/hadoop classpath) #saprk运行依赖hadoop的库</span><br></pre></td></tr></table></figure><p>spark-defaults.conf</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">spark<span class="selector-class">.master</span>                     yarn</span><br><span class="line">spark<span class="selector-class">.home</span>                       /Users/xxx/spark-<span class="number">1.6</span>.<span class="number">0</span>-cdh5.<span class="number">15.0</span></span><br><span class="line">spark<span class="selector-class">.eventLog</span><span class="selector-class">.enabled</span>           true</span><br><span class="line">spark<span class="selector-class">.eventLog</span><span class="selector-class">.dir</span>               hdfs:<span class="comment">//localhost:8001/spark_history</span></span><br><span class="line">spark<span class="selector-class">.serializer</span>                 org<span class="selector-class">.apache</span><span class="selector-class">.spark</span><span class="selector-class">.serializer</span><span class="selector-class">.KryoSerializer</span></span><br><span class="line">spark<span class="selector-class">.executor</span><span class="selector-class">.memory</span>            <span class="number">512</span>m</span><br><span class="line">spark<span class="selector-class">.driver</span><span class="selector-class">.memory</span>              <span class="number">512</span>m</span><br><span class="line">spark<span class="selector-class">.executor</span><span class="selector-class">.extraJavaOptions</span>  -XX:+PrintGCDetails -Dkey=value -Dnumbers=<span class="string">"one two three"</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：这里将spark托管到yarn上，所以spark.master配置为yarn，日志目录必须是hdfs路径下的<strong><em>已经存在</em></strong>的目录，如果不存在请手动创建<code>hdfs dfs -mkdir /spark_history</code>，这个目录也是后面的spark history服务依赖的目录。</p></li></ol><h3 id="三、配置Hive"><a href="#三、配置Hive" class="headerlink" title="三、配置Hive"></a>三、配置Hive</h3><ol><li><p>将spark-defaults.conf中的配置同步到hive配置中，在hive下的conf目录下找到hive-site.xml，增加如下内容：<br>hive-site.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 注意：hive.execution.engine在这里设置表示hive默认使用spark引擎，</span></span><br><span class="line"><span class="comment">也可以不在这里设置，进入hive cli或客户端后使用set hive.execution.engine=spark</span></span><br><span class="line"><span class="comment">启用spark引擎，但这种方式只针对当前会话有效。--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>hive.execution.engine<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>spark<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>spark.home<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>/Users/xxx/spark-1.6.0-cdh5.15.0<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>spark.master<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>yarn<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>spark.executor.memory<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>512m<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>spark.driver.memory<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>512m<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>spark.serializer<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>org.apache.spark.serializer.KryoSerializer<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>spark.enentLog.enabled<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>spark.enentLog.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://localhost:8001/spark_history<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>spark.executor.extraJavaOptions<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>-XX:+PrintGCDetails -Dkey=value -Dnumbers="one two three"<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：这里的配置务必和spark-defaults.conf中的一致，尤其是<code>spark.executor.memory</code>和<code>spark.driver.memory</code>，自己配置时填错了这两项，结果一堆莫名其妙的异常。</p></li></ol><h3 id="四、配置yarn"><a href="#四、配置yarn" class="headerlink" title="四、配置yarn"></a>四、配置yarn</h3><ol><li><p>配置yarn，在hadoop的etc/hadoop目录下找到yarn-site.xml，增加（修改）如下内容：<br>yarn-site.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- yarn资源调度器：公平调度 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.scheduler.class<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>org.apache.hadoop.yarn.server.resourcemanager.scheduler.fair.FairScheduler<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- NM的web监控地址，主要是端口设置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.webapp.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>0.0.0.0:8042<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- NM可分派的内存量，单机的话看机器剩余内存量配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.resource.memory-mb<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>8192<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- NM可分配的虚拟CPU数，单机的话配置为CPU核数-2或-1 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.resource.cpu-vcores<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>6<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="五、其他配置"><a href="#五、其他配置" class="headerlink" title="五、其他配置"></a>五、其他配置</h3><ol><li>你以为这就完了？没有，CDH版本的Hive与Spark并没有联系，所以需要我们手动将spark lib中的<code>spark-assembly-1.6.0-cdh5.15.0-hadoop2.6.0-cdh5.15.0.jar</code>拷贝到hive lib下，hive才能与spark建立联系。</li><li>理论上一切OK了，但你可能会发现在hive中使用spark引擎时返回3号错误，总之就是spark运行不正常，这时可以使用spark自带的example进行测试诊断（cd到spark bin目下）：<code>./spark-submit --master yarn --class org.apache.spark.examples.SparkPi ../lib/spark-examples-1.6.0-cdh5.15.0-hadoop2.6.0-cdh5.15.0.jar 10</code>，具体example jar路径及文件名自行查看。运行起来后有一个异常解决一个异常，直到跑出结果为止，没本人测试中发现以下问题：</li></ol><hr><ul><li><p><strong>没有jackson模块</strong>：WTF，官网下载的spark居然包都不带全，随后查了一下cdh版本确实没带jackson的相关包，然后去maven官网下载(三个都要下载)，放到<code>{HADOOP_HOME}/share/hadoop/common/lib</code>下，至于为什么放在这儿而不是spark lib，这是因为我们在前面配置了<code>SPARK_DIST_CLASSPATH</code>（看不明白就在shell中echo一下），它会加入到spark类路径下，这个路径就包含上面的<code>{HADOOP_HOME}/share/hadoop/common/lib</code>，而且它下面还有jackson的其他包，顺理成章就放这儿了。随后再试！</p><hr></li><li><p><strong>jackson版本问题</strong>：WTF，这回找到jackson了，但jackson内部抛异常了，上网查发现是版本问题，于是按热心网友推荐采用2.4.4的版本，这回不抛异常了！</p><hr></li><li><p><strong>无限ACCEPT</strong>：虽然异常是没了，可这个程序一直是ACCEPT（等一个小时了），然后又上网搜索找到部分答案，测试无果，再回头看前面的配置，发现sparkk-env.sh中<code>SPARK_MASTER_IP</code>和<code>SPARK_MASTER_HOST</code>跟那些傻屌网友一样配成了master，可是我的机器不叫master，所以yarn找不到执行机器，也就无法分配内存，遂更改为localhost(本篇文章开头配置已更改)，然后 everything is OK！</p><hr></li><li><p>如果你的机器内存较小，导致分配资源缓慢，可适当调整一下<code>${HADOOP_HOME}/etc/hadoop/capacity-scheduler.xml</code>中的<code>yarn.scheduler.capacity.maximum-am-resource-percent</code>，可以由0.1调整为0.5，它表示yarn所管理的资源中，最多可以有多少资源可以用来运行application master，即控制当前激活状态的应用，默认是10%，在我们自己机器上来说太小了，因此可适当调大比例。</p></li></ul><hr><ol start="3"><li>终极测试：<img src="/2018/12/02/hive-on-spark/001.png" title="Hive on Spark 测试结果"></li></ol>]]></content>
    
    <summary type="html">
    
      作为大数据开发人员，一直将精力放在业务上，很久没有关注大数据工具hive了。最近在写一个UDF函数时发现在hive(mr)引擎能通过，在spark引擎下却报错，于是就借此机会粗略研究一下hive on mr、hive on spark和spark sql等内容。本篇为整个系列开篇，介绍了MAC下Hive on spark的环境搭建，及遇到的坑。
    
    </summary>
    
      <category term="大数据" scheme="http://blog.zjee.ml/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="hive" scheme="http://blog.zjee.ml/tags/hive/"/>
    
      <category term="spark" scheme="http://blog.zjee.ml/tags/spark/"/>
    
      <category term="hadoop" scheme="http://blog.zjee.ml/tags/hadoop/"/>
    
      <category term="大数据" scheme="http://blog.zjee.ml/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>thrift基础语法</title>
    <link href="http://blog.zjee.ml/2018/11/29/thrift-grama/"/>
    <id>http://blog.zjee.ml/2018/11/29/thrift-grama/</id>
    <published>2018-11-29T05:37:11.000Z</published>
    <updated>2019-08-26T14:00:38.469Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h3><p>​        Thrift 接口定义语言 Thrift 接口定义语言(IDL, Interface Definition Language)中允许使用的是 thrift types。每个 thrift 文件主要有 hearder，类型定义，异常及服务组成，每个 thrift 文档包含 0 个或多个 headers 以及 0 个或多个 definitions。</p><h4 id="1、thrift-文件的组成"><a href="#1、thrift-文件的组成" class="headerlink" title="1、thrift 文件的组成"></a>1、thrift 文件的组成</h4><ul><li>Header ：header 可以是 thrift include，C++ include，或者是 namespace 声明。 </li><li><p>Thrift include 的目的是使得其他 thrift 文件中的所有定义都能够通过 include 声明添加到该 thrift 文档产生的代码中。 语法：<code>include &quot;../../***.thrift&quot;</code> ，被引用的 thrift 文件产生的代码中的头文件即可包含在 thrift 产生的代码的头部，使得其能够使用、访问。 </p></li><li><p>C++ include 能够将 C++定义的头文件添加到该 thrift 文件产生的 C++代码中。 语法：<code>cpp_include &quot;../../***.h&quot;</code> ，被引用的.h 文件将包含到 thrift 产生的代码的头部。 </p></li><li><p>namespace 的声明方式采用为 namespaces/package/module/etc。namespace scope 表示该 namespace 应用于哪种编程语言，若 scope 的取值为“*”，则表示该 namespace 适用于所有的目标语言。 语法： <code>namespace namespaceScope 名称</code>，其中namespaceScope 的取值有<code>*| cpp | java | py | perl | rb | cocoa | csharp</code>。 </p></li></ul><h4 id="2、Definition"><a href="#2、Definition" class="headerlink" title="2、Definition"></a>2、Definition</h4><p> thrift 中可以定义的类型有 const | typedef | enum | struct | exception | service </p><ul><li>const 语法： <code>const 字段类型 标识符 = 值</code></li><li>typedef 语法： <code>typedef 为一个类型创建一个别名</code></li><li>enum 语法： <code>enum 标识符 {***，***，…}</code>。其中，第一个值的取值默认为 0。 </li><li>struct 语法： <code>struct 标识符 { Field* }</code>。其中，每个 Field 的定义语法为： <code>FieldId: (required | optional) FieldType Identifier ( = value)</code>。 </li><li>exception： Exceptions 的定义与 struts 的定义相似，exception 中每个 field 的定义必须唯一 语法： <code>exception 标识符 { Field* }</code></li><li>service： Service 定义了 server 端提供的功能集合的接口。一个 service 可以继承另一个 service。 语法： <code>service 标识符 (extends otherService) { Function* }</code></li></ul><h3 id="二、类型详解"><a href="#二、类型详解" class="headerlink" title="二、类型详解"></a>二、类型详解</h3><p>Thrift类型系统包括<strong>预定义基本类型</strong>，<strong>用户自定义结构体</strong>，<strong>容器类型</strong>，<strong>异常</strong>和<strong>服务</strong>定义。</p><h4 id="1、基本类型"><a href="#1、基本类型" class="headerlink" title="1、基本类型"></a>1、基本类型</h4><ul><li>bool: 布尔类型，占一个字节</li><li>byte: 有符号字节 </li><li>i16：16位有符号整型 </li><li>i32：32位有符号整型 </li><li>i64：64位有符号整型 </li><li>double：64位浮点数 </li><li>string：未知编码或者二进制的字符串 </li><li>注意：<strong><em>thrift不支持无符号整形，因为很多目标语言不存在无符号整形（比如java）</em></strong> </li></ul><h4 id="2、容器类型"><a href="#2、容器类型" class="headerlink" title="2、容器类型"></a>2、容器类型</h4><ul><li>List<t1>：一系列t1类型的元素组成的有序列表，元素可以重复，映射到Java的ArrayList，c++的vector，脚本语言的Arrays等。 </t1></li><li>Set<t1>：一些t1类型的元素组成的无序集合，元素唯一不重复，映射到Java的HashSet，c++的STL中的set。 </t1></li><li>Map&lt;t1,t2&gt;：key/value对，key唯一，映射到Java的HashMap， c++的STL中的map。 </li><li>容器中的元素类型可以是除service以外的任何合法的thrift类型，包括结构体和异常类型 。</li></ul><h4 id="3、结构体和异常"><a href="#3、结构体和异常" class="headerlink" title="3、结构体和异常"></a>3、结构体和异常</h4><ul><li>Thrift结构体在概念上同c语言的<strong>结构体</strong>类似，在面向对象语言中，thrift结构体将被转化为<strong>类</strong>。 </li><li>thrift 结构体之间<strong><em>不能继承</em></strong>，每个结构体都有一组类型定义的字段，每个 field 都有一个唯一的命名标识符。 </li><li>异常在语法和功能上类似于结构体，只是异常使用关键字<code>exception</code>而不是struct关键字来声明。但它在语义上不同于结构体，当定义一个RPC服务时，开发者可能需要声明一个远程方法抛出一个异常。 </li><li>异常可以继承目标编程语言的异常类，目的是与给定编程语言的异常处理功能无缝的结合。 </li></ul><h4 id="4、服务"><a href="#4、服务" class="headerlink" title="4、服务"></a>4、服务</h4><ul><li>Thrift中服务定义的方式和语法等同于面向对象语言中定义<strong>接口</strong>。Thrift编译器会产生实现接口的client和server stubs。 </li><li>一个服务包括一个命名的 functions 集合，每个 function 有一个<strong>参数列表</strong>，一个<strong>返回值</strong>以及抛出或产生的一个<strong>异常列表</strong>。这些异常是 thrift 本身的<code>exception</code>类型。 </li><li>注意： void 是一种确定的 function 返回值类型，<strong><em>oneway 关键词（加在 void 之前）等同于 <u>async</u></em></strong>，这种方法产生的客户端代码无需等待 server 端的响应（异步调用）。 </li><li>单纯的 void 函数将会为 client 返回一个确认，用于表示操作在 server 端已经执行完毕。 </li><li><strong><em>当调用 oneway 方法时，client 端只保证 request 已成功发送至 transport 层，不能保证 server 端看到过这个 message，单个 client connection 的 oneway/async 方法可以在 server 端并行执行。</em></strong>  </li></ul><p>####5、类型重定义</p><ul><li>Thrift支持C/C++风格的typedef: <code>typedef i32 MyInteger /*a typedef Tweet ReTweet*/</code></li><li>说明：末尾没有逗号、分号，struct可以使用typedef </li></ul><h3 id="三、数据结构定义"><a href="#三、数据结构定义" class="headerlink" title="三、数据结构定义"></a>三、数据结构定义</h3><h4 id="1、常量"><a href="#1、常量" class="headerlink" title="1、常量"></a>1、常量</h4><p>​    Thrift允许用户定义常量，复杂的类型和结构体可以使用JSON形式表示： </p><ul><li><code>const i32 INT_CONST = 1234;</code>  </li><li><code>const map&lt;string,string&gt; MAP_CONST = {&quot;hello&quot;: &quot;world&quot;, &quot;goodnight&quot;: &quot;moon&quot;}</code></li><li>说明：<strong>分号是可选的</strong>，支持十六进制赋值 </li></ul><h4 id="2、枚举类型"><a href="#2、枚举类型" class="headerlink" title="2、枚举类型"></a>2、枚举类型</h4><p>可以像C/C++那样定义枚举类型，如： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> TweetType</span><br><span class="line">&#123;</span><br><span class="line">TWEET,</span><br><span class="line">RETWEET = <span class="number">2</span>,</span><br><span class="line">DM = <span class="number">0xa</span>,</span><br><span class="line">REPLY</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>编译器默认从0开始赋值 </li><li>可以赋予某个常量 </li><li>允许常量是十六进制整数 </li><li>给常量赋缺省值时，使用常量的全称 </li><li>不同于protocol buffer，<strong>thrift不支持枚举类嵌套，枚举常量必须是32位正整数</strong> </li></ul><h4 id="3、定义结构体"><a href="#3、定义结构体" class="headerlink" title="3、定义结构体"></a>3、定义结构体</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tweet</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="number">1</span>: required i32 userId;                  <span class="comment">// a</span></span><br><span class="line">    <span class="number">2</span>: required <span class="built_in">string</span> userName;             <span class="comment">// b</span></span><br><span class="line">    <span class="number">3</span>: required <span class="built_in">string</span> text;</span><br><span class="line">    <span class="number">4</span>: optional Location loc;                <span class="comment">// c</span></span><br><span class="line">    <span class="number">16</span>: optional <span class="built_in">string</span> language = <span class="string">"english"</span> <span class="comment">// d</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct Location</span><br><span class="line">&#123;</span><br><span class="line">    <span class="number">1</span>: required <span class="keyword">double</span> latitude;</span><br><span class="line">    <span class="number">2</span>: required <span class="keyword">double</span> longitude;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>每一个域都有一个唯一的正整数标识符（如示例中冒号前的数字），称为数字标签，这些数字标签在传输时用来确定序列化顺序，一旦使用消息类型，标签不可改变。（随着项目的进展，可以变更Thrift文件，最好不要改变原有的数字标签） </li><li>每个域可以标识为<code>required（必选的）</code>或者<code>optional(可选的)</code>（也可以不注明） </li><li>结构体可以包含其他结构体 </li><li>域可以有缺省值 </li><li>一个thrift中可以定义多个结构体，并存在引用关系 </li><li>规范的struct定义中的每个域均会使用required或者optional关键字进行标识。如果required标识的域没有赋值，thrift将给予提示。<strong>如果optional标识的域没有赋值，该域将不会被序列化传输</strong>。如果某个optional标识域有缺省值而用户没有重新赋值，则该域的值一直为缺省值。 </li><li>与service不同，<strong><em>结构体不支持继承</em></strong>，即一个结构体不能继承另一个结构体。 </li></ul><h4 id="4、定义服务"><a href="#4、定义服务" class="headerlink" title="4、定义服务"></a>4、定义服务</h4><p>​        在流行的序列化/反序列化框架（如protocol buffer）中，thrift是少有的提供多语言间RPC服务的框架。Thrift编译器会根据选择的目标语言为server产生服务接口代码，为client产生桩代码。 </p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//“Twitter”与“&#123;”之间需要有空格！！！</span></span><br><span class="line"><span class="comment">//方法定义方式类似于C语言中的方式，它有一个返回值，一系列参数和可选的异常</span></span><br><span class="line"><span class="comment">//注意，参数列表和异常列表定义方式与结构体中域定义方式一致</span></span><br><span class="line"><span class="comment">//”oneway”标识符表示client发出请求后不必等待回复（非阻塞）直接进行下面的操作，”oneway”方法的返回值必须是void</span></span><br><span class="line">service Twitter &#123;</span><br><span class="line">void ping(),                                    // a</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">postTweet</span><span class="params">(<span class="number">1</span>:Tweet tweet)</span></span>;                  <span class="comment">// b</span></span><br><span class="line"><span class="function">TweetSearchResult <span class="title">searchTweets</span><span class="params">(<span class="number">1</span>:<span class="built_in">string</span> query)</span></span>; <span class="comment">// c</span></span><br><span class="line"><span class="function">oneway <span class="keyword">void</span> <span class="title">zip</span><span class="params">()</span>                               <span class="comment">// d</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>函数定义可以使用<strong>逗号</strong>或<strong>分号</strong>标识结束 </li><li>参数可以是基本类型或者结构体，参数只能是只读的（const），不可以作为返回值（参数不可携带数据返回） </li><li>返回值可以是基本类型或者结构体 </li><li>返回值可以是void </li><li>Service支持继承，一个service可使用extends关键字继承另一个service </li></ul><h3 id="四、注释、命名空间、文件包含"><a href="#四、注释、命名空间、文件包含" class="headerlink" title="四、注释、命名空间、文件包含"></a>四、注释、命名空间、文件包含</h3><h4 id="1、注释"><a href="#1、注释" class="headerlink" title="1、注释"></a>1、注释</h4><p>Thrift支持shell注释风格、C/C++语言中的单行或多行注释风格</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># This is a valid comment.  shell风格注释</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* This is a multi-line comment.</span></span><br><span class="line"><span class="comment">* Just like in C.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// C++/Java style single-line comments work just as well.</span></span><br></pre></td></tr></table></figure><h4 id="2、命名空间"><a href="#2、命名空间" class="headerlink" title="2、命名空间"></a>2、命名空间</h4><p>​       Thrift中的命名空间同C++中的namespace和java中的package类似，它们均提供了一种组织（隔离）代码的方式。因为每种语言均有自己的命名空间定义方式（如python中有module），thrift允许开发者针对特定语言定义namespace： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> cpp com.example.project  <span class="comment">// a</span></span><br><span class="line"><span class="keyword">namespace</span> java com.example.project <span class="comment">// b</span></span><br></pre></td></tr></table></figure><h4 id="3、文件包含"><a href="#3、文件包含" class="headerlink" title="3、文件包含"></a>3、文件包含</h4><p>Thrift允许文件包含，需要使用thrift文件名作为前缀访问被包含的对象，如： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">include <span class="string">"tweet.thrift"</span>           <span class="comment">// a</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TweetSearchResult</span> &#123;</span></span><br><span class="line"><span class="number">1</span>: <span class="built_in">list</span>&lt;tweet.Tweet&gt; tweets; <span class="comment">// b</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>thrift文件名需要双引号包含，末尾没有逗号或者分号 </li><li>注意tweet前缀 ，前缀为引入的thrift文件名（不含后缀）</li></ul>]]></content>
    
    <summary type="html">
    
      Thrift is an interface definition language and binary communication protocol used for defining and creating services for numerous languages. It forms a remote procedure call (RPC) framework and was developed at Facebook for &quot;scalable cross-language services development&quot;.
    
    </summary>
    
      <category term="后端开发基础" scheme="http://blog.zjee.ml/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="thrift" scheme="http://blog.zjee.ml/tags/thrift/"/>
    
      <category term="rpc" scheme="http://blog.zjee.ml/tags/rpc/"/>
    
  </entry>
  
  <entry>
    <title>git基础教程</title>
    <link href="http://blog.zjee.ml/2018/11/29/learn-git/"/>
    <id>http://blog.zjee.ml/2018/11/29/learn-git/</id>
    <published>2018-11-29T05:20:32.000Z</published>
    <updated>2019-08-26T14:00:38.469Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、创建本地仓库的两种途径："><a href="#1、创建本地仓库的两种途径：" class="headerlink" title="1、创建本地仓库的两种途径："></a>1、创建本地仓库的两种途径：</h4><ol><li><p>从远程仓库克隆一份：<code>git clone [remote git url]</code></p></li><li><p>创建一个目录：<code>mkdir git</code>, 然后用 <code>git init</code> 去初始化这个目录，使之成为一个git仓库。</p></li></ol><h4 id="2、git-config文件配置："><a href="#2、git-config文件配置：" class="headerlink" title="2、git config文件配置："></a>2、git config文件配置：</h4><ol><li>配置全局用户名：<code>git config --global user.name &quot;xxxxxx&quot;</code></li><li>配置全局E-mail：<code>git config --global user.email &quot;xxxxxx@xx.com&quot;</code>, 如果需要在项目中配置不同的用户名和邮件，则只需要在项目目录下执行上面的命令，不带 <code>--global</code> 即可。</li><li>查看配置文件: <code>git config --list</code></li></ol><h4 id="3、将本地仓库和远程仓库关联（适用于git-init创建的仓库）："><a href="#3、将本地仓库和远程仓库关联（适用于git-init创建的仓库）：" class="headerlink" title="3、将本地仓库和远程仓库关联（适用于git init创建的仓库）："></a>3、将本地仓库和远程仓库关联（适用于git init创建的仓库）：</h4><ol><li>添加远程仓库：<code>git remote add [host-name] [git-url]</code>, 一般host-name取<code>origin</code>, 这也是git默认主机名。</li><li>拉取本地还没有的远程仓库的信息：<code>git fetch [host-name] [branch-name]</code>,从远程仓库下载制定分支的信息到本地，但不会与本地的仓库合并，需手动合并<code>git merge [host-name] [branch-name]</code>，如：<code>git fetch origin dev; git merge origin dev;</code></li><li>拉取远程信息，并尝试与本地合并(相当于fetch和merge的合体)：<code>git pull [host-name] [branch-name]</code>, 有冲突需手动解决再手动合并。</li><li>查看远程仓库信息：<code>git remote -v</code>。</li></ol><h4 id="4、将本地信息推送到远程"><a href="#4、将本地信息推送到远程" class="headerlink" title="4、将本地信息推送到远程"></a>4、将本地信息推送到远程</h4><ol><li><code>git push [host] [branch]</code>，如果远程没有对应分支，则需要带上 <code>-u</code> 参数创建相应分支。</li><li>如果本地分支没有与远程分支关联，则需要：<code>git branch --set-upstream [remote-branch]</code>建立关联。</li><li>如果远程分支有其他人提交过，则必须先<code>git pull</code>,尝试与本地合并合并（有冲突解决冲突）后才可以push。</li></ol><h4 id="5、添加文件，修改，提交修改"><a href="#5、添加文件，修改，提交修改" class="headerlink" title="5、添加文件，修改，提交修改"></a>5、添加文件，修改，提交修改</h4><ol><li>添加文件到暂存区：<code>git add [file-name or directory-name]</code>,可以使用通配符。</li><li>所有做的修改都需要使用<code>git add</code>后在进行<code>git commit</code>操作。</li><li>提交修改到本地仓库：<code>git commit -m &#39;说明信息&#39;</code>。</li><li>撤销修改/恢复删除文件：<code>git check --[file-name]</code>，注意两个’-‘。</li><li>查看git状态：<code>git status</code>。</li><li>查看commit日志：<code>git log</code>，单行显示：<code>git log --pretty=oneline</code>。</li><li>查看上次的修改：<code>git diff file-name</code>。</li><li>从暂存区删除一个文件：<code>git rm file-name</code>。</li></ol><h4 id="6、创建、切换分支"><a href="#6、创建、切换分支" class="headerlink" title="6、创建、切换分支"></a>6、创建、切换分支</h4><ol><li>创建并切换分支：<code>git checkout -b [branch-name]</code>，他相当于<code>git branch [branch-name]; git checkout [branch-name];</code>。</li><li>切换分支：<code>git checkout [branch-name]</code>。</li><li>删除分支：<code>git branch -d &lt;name&gt;</code>，使用<code>-D</code>强行删除。</li><li>查看分支合并情况：<code>git log --graph --pretty=oneline --abbrev-commit</code></li></ol><h4 id="7、版本回退"><a href="#7、版本回退" class="headerlink" title="7、版本回退"></a>7、版本回退</h4><ol><li>本地仓库回退：<code>git reset --hard HEAD^</code>，一个<code>^</code>表示回退一个版本，两个<code>^^</code>表示回退两个版本，一次类推，回退100个版本可以这样写<code>HEAD~100</code>，也可以指定回退到具体某个版本<code>git reset --hard 1094adb</code>。</li><li>重返未来：使用<code>git reflog</code>查看操作历史，找到要回去的版本号，使用1中命令即可回到未来。</li></ol><h4 id="8、保存工作现场"><a href="#8、保存工作现场" class="headerlink" title="8、保存工作现场"></a>8、保存工作现场</h4><ol><li><code>git stash</code>，保存工作现场后，working dir就是干净的，这时就可以创建别的分支，进行别的工作，比如紧急修复bug场景。PS：如果当前工作区不干净git不允许创建新的分支。</li><li>恢复工作区：<code>git stash pop</code>，它相当于<code>git stash apply; git stash drop;</code>，恢复并删除stash内容。</li></ol><h4 id="9、标签管理"><a href="#9、标签管理" class="headerlink" title="9、标签管理"></a>9、标签管理</h4><ol><li>commit打标签：<code>$ git tag v0.9 [-m &#39;说明文字&#39;] f52c633</code>，可以省略commit号，默认打在最新commit上。</li><li>使用<code>git show tag-name</code>查看说明文字。</li><li>使用<code>git tag</code>查看所有标签。</li><li>使用<code>git tag -d v0.1</code>删除标签。</li><li>将标签推送到远程：<code>git push origin &lt;tagname&gt;</code>，使用<code>git push origin --tags</code>推送全部tag。</li><li>使用<code>git push origin :refs/tags/&lt;tagname&gt;</code>可以删除一个远程标签，需要先删除本地对应标签。</li></ol>]]></content>
    
    <summary type="html">
    
      Git是目前世界上最先进的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。因此Git也是程序猿入门的必备技能之一，有了它我们就可以在代码的世界里穿越古今，自由翱翔！
    
    </summary>
    
      <category term="后端开发基础" scheme="http://blog.zjee.ml/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="git" scheme="http://blog.zjee.ml/tags/git/"/>
    
  </entry>
  
</feed>
