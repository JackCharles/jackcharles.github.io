<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>江影不沉浮</title>
  
  <subtitle>You can, just if you want!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.zjee.ml/"/>
  <updated>2020-05-16T15:24:46.000Z</updated>
  <id>https://blog.zjee.ml/</id>
  
  <author>
    <name>jackcharles</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2020-05-16随笔</title>
    <link href="https://blog.zjee.ml/2020/05/16/informal-essay-01/"/>
    <id>https://blog.zjee.ml/2020/05/16/informal-essay-01/</id>
    <published>2020-05-16T15:24:46.000Z</published>
    <updated>2020-05-16T15:24:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5月16日，又浪费了半个周末，为什么说是浪费呢？大概是与往常过的不一样吧。今天整理物品的时候，翻出了几本大学课本，里面还夹杂着几张习题纸，就是这样简单的场景，我便看了一下午。说起来也真有意思，我一直都有个习惯，偶尔翻到很多年前的东西，比如一本作业，一张试卷、亦或者一件衣物……，我都会在那端详许久，慢慢地忘记了原本的工作。是怀念？是感慨？是回忆？嗯，好像有那么一点回忆，怀念、感慨倒是谈不上，大概是在思考，那个时候的我在解这道题、写这篇文章的时候到底什么样子的呢？怀着一种怎样的心态呢？周围是什么样的环境呢？有没有想过有一天我会变成现在这个样子，安静的想着从前的我？</p><img src="01.jpg" alt="01"><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;是的，很多时候我便迷失在这种漫无边际的思考中，思考从前、思考现在以及未来，如果再给我一次机会，我还能不能原样复制我的人生？随后便是一阵电话铃声、窗外鸟叫声，或者楼下婴儿的啼哭声将我带回现实，依依不舍地放下旧时光，脑袋中闪过一句话：“这就是时间”！终究，我也说不清楚。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;时间过的太快，我在为生活奔波的同时，也逐渐忘记了自我。我记得老板的要求、记得父母的电话、记得朋友的生日……，却总想不起来自己是如何从过去走到现在。也许我会反驳：“我记得很清楚啊，我是14年上的大学，18年参加的工作……，然后便是现在”，没错，是这样，可这漫长的岁月仅用这几个字去描述未免也太空洞了。认识自我是一件不容易的事，我可以从生理学、心理学、经济学、社会学等很多方面来度量自己，即使这样，也仅仅是测算出一些冰冷的指标，或者是帮别人了解了自己。更深层次的自我感知是一种模糊的、真实的、祥和的感觉，就像时隔多年，拿起儿时的玩具一点也不陌生一样。老实说，很多东西若不是放在家里，或者写着我的名字，我都不敢相信它是我的，即使是我亲手采办的。</p><img src="02.jpg" alt="02"><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;兴许是我太忙，或者有更重要的事，总是在很多事情上挂个标号，说“这是xxx的”，然后就匆匆离去，以至于很长时间对周围的人或物，都难以在脑海中清晰的刻画出来。这就好比我能随口说出好几个同事的名字、性格，却想不起来他们的模样。身体为了存活在不停的奔波，灵魂早已不堪重负，被远远甩在身后，这个城市中，有太多的追求与失落。我在想，是不是应该再多花一些时间，仔细端详一下身边的事物，就像新买的衣服上花纹样式、楼下花坛有几株百合、窗外的小鸟喜欢站在哪根树枝上，诸如此类的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我已经这样做了，也许很多年后，当我再次跨越时空的时候，窗外的树便会帮我想起一切：“那年夏天，一个北漂的年轻人，手里拿着泛黄的书本，斜靠在椅子上，想着另一个夏天的故事。夕阳透过窗户，屋内阴影交错，他把手伸进阳光中，盯着手背的寒毛，嘴角露出久违的微笑。窗外传来几声鸟叫，他回过神来，决定记录下这一切。”</p><img src="03.jpg" alt="03"><p style="text-align:right; color: #858585;">庚子年四月廿四（1589620889）&#151; 北京</p><blockquote><p>插图来自如下网站：<br>[1] <a href="https://www.pexels.com/zh-cn/" target="_blank" rel="noopener">https://www.pexels.com/zh-cn/</a><br>[2] <a href="https://pixabay.com/" target="_blank" rel="noopener">https://pixabay.com/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      身体为了存活在不停的奔波，灵魂早已不堪重负，被远远甩在身后
    
    </summary>
    
      <category term="杂谈随笔" scheme="https://blog.zjee.ml/categories/%E6%9D%82%E8%B0%88%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="杂谈随笔" scheme="https://blog.zjee.ml/tags/%E6%9D%82%E8%B0%88%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>MySQL面试汇总</title>
    <link href="https://blog.zjee.ml/2020/05/04/mysql-interview/"/>
    <id>https://blog.zjee.ml/2020/05/04/mysql-interview/</id>
    <published>2020-05-04T03:40:41.000Z</published>
    <updated>2020-05-04T03:40:41.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、存储引擎"><a href="#一、存储引擎" class="headerlink" title="一、存储引擎"></a>一、存储引擎</h1><p>MySQL常见引擎对比：</p><table><thead><tr><th>引擎</th><th>索引</th><th>事务</th><th>锁</th><th>外键</th><th>缓存</th><th>存储限制</th><th>关注点</th></tr></thead><tbody><tr><td><strong>MylSAM</strong></td><td>全文、B Tree</td><td>N</td><td>表锁</td><td>N</td><td>缓存索引</td><td>256T</td><td>性能</td></tr><tr><td><strong>InnoDB</strong></td><td>B Tree、聚集</td><td>Y</td><td>行锁</td><td>Y</td><td>缓存索引和数据</td><td>64T</td><td>事务</td></tr><tr><td><strong>MEMORY</strong></td><td>Hash、BTree</td><td>N</td><td>表锁</td><td>N</td><td>-</td><td>RAM</td><td>性能</td></tr><tr><td><strong>Archive</strong></td><td>B Tree(限制自增ID)</td><td>N</td><td>-</td><td>N</td><td>-</td><td>-</td><td>归档</td></tr></tbody></table><p>MyISAM适用于只读取不写入的场景，比如ETL同步。</p><p>InnoDB是MySQL默认引擎，也是后端开发首选。</p><h1 id="二、-索引"><a href="#二、-索引" class="headerlink" title="二、 索引"></a>二、 索引</h1><ol><li><p><strong>什么是索引？</strong><br>答：索引是一种数据结构，用于帮助我们更快的进行数据查找。</p></li><li><p>MySQL的索引分类。<br>答：MySQL索引按不同的有不同的分类标准，大致如下(MECE)。  </p><ul><li>按索引字段数量：单列索引、联合索引（最走匹配原则）</li><li>按索引类型（逻辑上）：主键索引（未定义主键，找非空唯一索引或rowid）、唯一索引、全文索引、普通索引、空间索引（只能建立在空间数据类型，比如GEO、POINT等）。</li><li>按索引实现方法（数据结构）：Hash索引、B Tree索引</li><li>按存物理储结构分类：聚集（聚簇）索引、非聚集索引（二级索引、辅助索引）</li></ul></li><li><p><strong>索引都使用什么样的数据结构？</strong><br>答：索引的实现与具体引擎有关，MySQL中常见的有Hash（Memory显示支持）、B树、R树等，InnoDB默认使用B+树。</p></li><li><p><strong>各种索引数据结构的优劣势?</strong><br>答：Hash索引只有Memory引擎显示支持，InnoDB使用伪hash，即在B+树上使用key的hash值进行索引查找，需要自己维护hash方法。原生Hash索引中存储的是key的hash值和指向记录的指针，它的特性如下：</p><ul><li>Hash索引非常紧凑，且与索引key的数据类型和长度无关。</li><li>Hash索引不能通过索引拿到数据，必须访问表，但访问Memory表是很快的。</li><li>Hash索引的顺序与原数据存储顺序无法保持一致，所以不能使用hash索引排序（不是不能排序）。</li><li>Hash索引只能使用精确的等值查找，不支持IN，&gt;=，&gt;，like和联合索引的最左匹配（只能精确限定每个字段的值），这与hash本身特性有关。</li><li>Hash冲突多的话，查询代价较大。</li><li>一般当索引key较长，且只使用等值查询的话可以使用hash索引，比如为URL字段建立Hash索引。</li></ul><p><strong>B+树</strong> 是一个平衡多叉树，每一层节点按关键字从小到大排序， 数据只存在于叶子节点，并组织成双向链表形式。各key检索效率相当，很方便的支持范围查找。</p><p><img src="b+tree.png" alt="B+树"></p></li><li><p><strong>为什么用B+树而不用其他树？</strong><br>答：所有二叉树都有一个问题，就是随着数据量增大高度变大（logn），IO次数增加，B树层数较低，一般3-4层。如果是非平衡二叉树，还可能有退化成链表的问题。</p><p><strong><em>B树 VS B+树：</em></strong></p><ul><li>B+树非叶子节点不存实际数据，占用空间更小，一次IO能读取到内存的关键字也就越多，相对磁盘IO次数降低了。</li><li>B+树查询效率很稳定，每个关键字走的路径长度一致。</li><li>B+树所有数据存叶子节点，并且叶子节点以双向组织，非常适合扫库和范围查找，而B树需要按中根遍历之类的。</li></ul></li><li><p><strong>聚集索引和非聚集索引</strong><br>答：聚集索引（clustered index）：</p><ul><li>叶子节点存储的就是整行数据，直接通过索引可以拿到数据，对于InnoDB表，聚集索引就是整个表，整个表就是一个聚集索引。</li><li>数据的物理存放顺序与索引顺序是一致的，只要索引是相邻的，那么数据也一定是相邻的。</li><li>一个表只有一种物理存储顺序，因此只能有一个聚集索引。默认情况下InnoDB将主键设为聚集索引，没有主键时找第一个非空唯一索引作为聚集索引，否则以6字节的rowid生成聚集索引。</li></ul><p>非聚集索引（secondary index）：</p><ul><li>叶子节点存储的是主键列的值，再根据这个主键去聚集索引查找到某行，因此非聚集索引又被称为二级索引或辅助索引（索引的索引）。</li><li>MyISAM不支持聚集索引。</li></ul></li><li><p><strong>覆盖索引：</strong> SQL只需要通过索引就可以返回需要的数据，而不需要通过二级索引查到主键后再去查询数据，一般覆盖索引都是联合索引，通过限制其中一个值去查另外一个值。Extra中有’Using Index’表示使用了覆盖索引，覆盖索引是提升性能的重要手段之一。</p><p><img src="cover-index.png" alt="cover-index"></p></li><li><p><strong>非聚簇索引一定会回表查询吗?</strong><br>答：不一定，如果查询的字段全部命中索引就不需要查表。</p></li><li><p><strong>全文索引：</strong> 全文索引就像一个搜索引擎，对文本分词后进行统计索引，全文索引分为自然语言全文索引和布尔全文索引，后者可以在查询是使用一些修饰符号限定取什么或不取什么。MySQL对全文索引支持很有限，一般需要配置第三方插件比如Sphinx、Lucene使用，建议直接上ES。</p></li><li><p><strong>空间索引：</strong> 空间索引只针对于空间数据类型，比如GEOMETRY、POINT 、LINESTRING 等，很少使用。</p></li><li><p><strong>建立索引需要考虑那些因素？</strong><br>答：字段的使用频率（频率高的字段设置索引）、区分度（越高越靠前）、字段长度（索引大小）、查询方式等。联合索引需要考虑字段顺序，查询时需要满足最左匹配原则。如果一个索引是(a,b,c)，则有如下规则：</p><ul><li>索引块先按a排序，如果a是一样的在按b排序，最后按c排序，这很重要，理解B+树的结构就能推断出一个查询是否走索引。</li><li><strong>最左匹配原则：</strong>最左优先，以最左边的为起点任何连续的索引都能匹配上。同时遇到范围查询(&gt;、&lt;、between、like)就会停止匹配。注意，这与字段在SQL中写的顺序无关，MySQL会自动按索引顺序重排，我们判断是否走索引时也可先重排再判断。</li><li>字符串的like操作只有前缀匹配时才能走索引。</li><li>示例参考：<a href="https://blog.csdn.net/sinat_41917109/article/details/88944290" target="_blank" rel="noopener">https://blog.csdn.net/sinat_41917109/article/details/88944290</a></li></ul></li><li><p><strong>没有使用到索引的情况</strong></p><ul><li>使用!=, !&gt;, not in, not like等负向查询</li><li>where或order by中使用了数学运算或函数</li><li>字符串like时，左边是通配符，如like “%aa”</li><li>当MySQL任务全表扫描比走索引快的时候</li><li>where条件中有Or，且其中一个无索引，则另一个也不会走索引（必须要全表扫描，就没必要走索引）</li><li>当使用联合索引时，不满足最左匹配原则的字段无法使用索引，或部分使用索引。</li></ul></li><li><p><strong>索引下推（index condition pushdown）</strong></p><ul><li>索引下推时=是MySQL5.6及以后推出的一个优化功能，默认开启。</li><li>InnoDB引擎下，如果一个二级联合索引被部分命中（不完全符合最左原则），此时MySQL不会根据命中条件去MySQL取回全部数据，然后交给Server再次过滤。而是筛选出的index中（叶子节点）继续过滤后续条件，直到完全符合筛选条件，最后拿着这些主键去查询数据。</li><li>InnoDB下ICP只在二级索引中有效，聚集索引叶子节点本来就是数据行，回表次数不会减少。</li><li>参考：<a href="https://blog.csdn.net/mccand1234/article/details/95799942" target="_blank" rel="noopener">https://blog.csdn.net/mccand1234/article/details/95799942</a></li><li>参考：<a href="https://www.cnblogs.com/lonelyxmas/p/12630085.html" target="_blank" rel="noopener">https://www.cnblogs.com/lonelyxmas/p/12630085.html</a></li></ul><p><img src="icp.png" alt="icp"></p></li><li><p><strong>组合索引与单索引的区别</strong><br>答：组合索引从左至右成级联关系，只要满足最左匹配原则，每个字段都能走索引。同样的单字段索引最多只能使用一个MySQL认为最好的索引。建立组合索引(a, b, c)，相当于建立了(a), (a,b), (a,b,c)，而单列索引是(a), (b), (c)这样的。</p></li><li><p><strong>慢SQL排查</strong> ：参考：<a href="https://www.cnblogs.com/tufujie/p/9413852.html" target="_blank" rel="noopener">https://www.cnblogs.com/tufujie/p/9413852.html</a></p></li></ol><h1 id="三、锁与事务"><a href="#三、锁与事务" class="headerlink" title="三、锁与事务"></a>三、锁与事务</h1><ol><li><p><strong>什么是事务？</strong><br>答：事务是一系列对系统中数据的访问操作所组成的执行单元，它们满足ACID特性。</p></li><li><p><strong>事务的特性（ACID）?</strong><br>答：ACID具体解释如下：</p><ul><li>A(Atomicity，原子性)：一个事务中的操作，要么全部成功执行，要么全部不执行。</li><li>C(Consistency，一致性)：一个事务在执行前和执行后，数据库都必须处于一致状态。也就是说事务的执行只会导致数据库从一个一致状态转换到另一个一致状态。</li><li>I(Isolation，隔离性)：事务之间的执行是相互独立的，一个事务的执行不能被其他事务干扰。</li><li>D(Durability，持久性)：一旦事务提交，它对数据库的变更就是永久性的，即使宕机也能恢复到事务提交成功后的状态。</li></ul></li><li><p><strong>多个事务并发执行会有什么问题？</strong><br>答：事务并发存在的问题如下：</p><ul><li>脏读：A事务读取了B事务未提交的内容，然后B事务进行了回滚。（读取未提交数据）</li><li>不可重读读：事务A开启了一个事务，第一次读取数据m，然后事务B对数据进行了修改，事务A再次读m，发现两次m的值不一致。（多次读值不一致）</li><li>幻读：事务A开启事务，第一次读到m条数据，然后事务B插入一条数据，事务A再次读，发现读到了m+1条数据。（多次读数量不一致）</li></ul></li><li><p><strong>MySQL事务隔离级别？</strong><br>答：MySQL四种事务隔离级别：</p><ul><li>READ UNCOMMITTED（未提交读）：其他事务可以读取到本事务未提交的数据。这个隔离级别解决不了任何问题，且性能提升不大，因此很少使用。</li><li>READ COMMITTED（已提交读）：其他事务只能读取本事务提交的部分。这个隔离级别解决了脏读的问题，但还存在不可重复读和幻读的问题。</li><li>REPEATABLE READ（可重复读）：解决了脏读和不可重读读的问题，<code>InnoDB通过MVCC+ Next-Key Locks 也能解决幻读的问题</code>。这是MySQL InnoDB引擎默认的隔离级别。</li><li>SERIALIZABLE（可串行化）：最高隔离级别，解决所有问题，性能最差，也很少使用。</li></ul></li><li><p><strong>事务ACID与事务隔离级别的关系？</strong><br>答：MySQL通过不同程度的隔离级别，来不同程度解决并发事务带来的问题，最大程度保证事务的隔离（Isolation，ACID中的I）特性。</p></li><li><p><strong>MySQL锁分类</strong><br>答：为保证事务的正确执行，MySQL再进行各种操作时会对数据上锁，锁可以按不同标准分类如下：</p><ul><li>按排他性分：排他锁（x锁/写锁）、共享锁（s锁/读锁）,共享锁上锁后可再次加共享锁，但不能加排他锁，排他锁上锁后不能加任何锁。</li><li>按上锁策略分：悲观锁、乐观锁。</li><li>按锁的粒度分：表锁、行锁、页锁等。</li></ul></li><li><p><strong>InnoDB中的锁</strong></p><ul><li>行锁（Record Lock）:行锁直接加在<code>唯一索引</code>上面，锁住的是key，如果没有唯一索引或未命中索引，则锁住整个表。</li><li>间隙锁（Gap Lock）:锁定索引记录间隙，确保索引记录的间隙不变。间隙锁是针对事务隔离级别为可重复读或以上级别的，间隙锁锁定的是某段间隙，开区间（不包含检索key本身），主要功能是防止Insert操作，以解决幻读问题。</li><li>Next-Key Lock ：它不是一种具体的锁，更像一种算法，行锁和间隙锁组合起来就叫Next-Key Lock。一般加Next-Key Lock可以看作两步，对所有命中的索引加行锁，然后<code>除唯一索引唯一查找</code>外，都会在扫描区间内加上间隙锁（包括最边缘两侧）。</li><li>在更新操作中如果没有用到索引，则间隙锁会锁定整个表，即整个表都无法插入。</li></ul></li><li><p><strong>InnoDB是如何实现各种隔离级别的？（大坑，有难度）</strong><br>答：为优化数据库性能，InnoDB引入了MVCC（多版本并发控制）机制，在回答问题之前，先来了解以下MVCC相关内容。</p><p>🔴 <strong>​MySQL中几种重要的日志</strong></p><blockquote><ol><li><p><code>Undo log</code>：它记录了每一次操作<strong>之前</strong>的数据版本，用于事务回滚和MVCC的数据可见性控制，Undo log分为Insert和Update两种，它属于引擎层逻辑（记录具体数据行）日志。简单来说，Undo log就是后悔药。</p></li><li><p><code>Redo log</code>：事务操作中，对数据的更新并不是立刻写到磁盘的，而是将对<strong>数据页</strong>的物理修改记录到redo log中，在事务提交时，将redo log刷到磁盘。此时对数据而言，很可能只是在内存做了修改，与磁盘的数据页并不一致，称为脏页，InnoDB后台有一个线程专门用于刷脏。如果此时Server宕机，重启后也能从redo log逐步恢复已提交的事务。</p><p>采用Redo log而不是直接将数据刷盘的主要原因是性能问题，数据页刷盘是随机IO操作，写redo/undo log是顺序IO操作，一般顺序IO比随机IO快，在HDD中尤为显著。Redo log属于引擎层物理日志。</p></li><li><p><code>binlog</code>：binlog是MySQL服务层维护的，跟引擎无关。它记录的是事务操作的内容，一般用于主从同步，或导入数据到其他存储引擎，如ES、Hive等。</p></li></ol></blockquote><p>🔴 <strong>MVCC</strong></p><blockquote><p>InnoDB在每行数据末尾记录了trx_id、db_roll_ptr两个字段，其中trx_id表示最后一个事务的ID，这个id在事务开启的时候就记录了。db_roll_ptr是一个指针，指向本次更新操作（删除实际是将删除标记置位，也是更新操作）对应的undo log位置（即操作前原始数据位置，<code>MVCC中insert undo log在事务提交后就会删除，因此单靠MVCC不能解决幻读问题，需要加锁辅助完成</code>）。因此，一条数据的多次更新操作会形成一条undo log链（也称为版本链）。</p></blockquote><blockquote><p>Innodb中存在purge线程，它会查询那些比现在<code>最老的活动事务</code>还早的undo log，并删除它们，从而保证undo log文件不至于无限增长。</p></blockquote><blockquote><p>MVCC有一个ReadView的概念，从字面意思来讲就是“读视图”，的确，它就是我们常说的快照。ReadView中维护着以下数据结构：</p><ul><li>up_limit_id ：低水位，当前活跃事务中最小的事务ID</li><li>low_limit_id ：高水位，当前活跃事务中最大的事务ID</li><li>trx_ids ：当前活跃事务列表</li></ul><p><strong>注意：当前事务ID（trx_id）不在活跃事务表中，也不会在高、低水位出现，因为当前事务的修改对自己总是可见的</strong>。</p></blockquote><blockquote><p>ReadView按以下规则确定数据是否可见：</p><ul><li>trx_id &gt;= low_limit_id(高水位)：不可见，这种情况表示在<code>ReadView创建后</code>新开的事务。</li><li>trx_id &lt; up_limit_id (低水位)：可见，如果事务ID小于<code>ReadView创建时刻</code>最小的活跃事务ID，那么它在<code>ReadView创建前</code>一定提交了。</li><li>up_limit_id  &lt;= trx_id &lt; low_limit_id：如果trx_id在trx_ids中则不可见，否则可见。这是因为事务的提交时间是无序的，它可能在最小活跃事务之后创建，但在<code>ReadView创建前</code>提交，这种情况应该也是可见的。</li></ul></blockquote><blockquote><p>总结一下：在<code>ReadView创建时刻</code>还未提交的事务，当前事务除外，以及之后新开的事务，对数据做的更新操作不可见，其他情况均可见。请注意文中高亮部分，ReadView建立就是快照的建立。</p></blockquote><ul><li>READ UNCOMMITTED：读采用当前读，不加任何锁，写加X行锁。</li><li>READ COMMITTED：数据的读取不加锁，采用快照读（MVCC），<code>快照（ReadView）在每个Select操作时新建一个</code>。数据的写入、修改、删除需要加X行锁（外键约束检查及唯一性检查时会封锁区间）。</li><li>REPEATABLE READ：数据读取时不加锁，采用快照读，<code>快照（ReadView）在事务中第一次Select时创建，随后在整个事务中都使用这个快照</code>。数据的写入、修改、删除需要加X行锁（外键约束检查及唯一性检查时会封锁区间）。*  REPEATABLE READ级别解决幻读：MVCC + 乐观next-key lock实现。 *</li><li>SERIALIZABLE：一个事务中读加S锁，写加X锁（NEXT-KEY LOCK），事务之间多个操作采用两段锁协议（加S1，加S2，加X1，释放X1，释放S2，释放S1）。保证串行化调度，可能存在死锁。</li></ul></li><li><p><strong>如何显示加锁</strong><br>答：<code>select...from lock in share mode</code>加共享锁，<code>select..from for update</code>加排他锁，这种读也称为当前读。</p></li><li><p><strong>AUTO_INCREMENT原理</strong><br>答：InnoDB中auto_increment的运行机制与<code>innodb_autoinc_lock_mode</code>的配置有关：</p><ul><li><code>innodb_autoinc_lock_mode=0</code>：该模式称为traditional lock mode，其行为与5.1版本之前一致。该模式下，所有INSERT语句都会加上AUTO-INC表级锁，此锁保持到INSERT语句结束（不是事务结束），它能保证所有插入的数据AUTO-INC列是单调递增的，并且同一个语句AUTO-INC列是连续的。这种模式实际就是INSERT语句串行执行，它能保证3种主从复制（基于语句、基于行、混合模式）方式下数据的一致性。</li><li><code>innodb_autoinc_lock_mode=0</code>：该模式称为consecutive lock mode。该模式在无法确定插入数据量的情况下使用AUTO-INC表级锁，确保同一个SQL插入的数据连续递增。如果能确定插入的数据量，则不使用AUTO-INC表锁，而是使用一个轻量级锁mutex来维护自增分配过程，而不必持有到语句执行完成。该模式在“Simple Insert（能预知插入数据量）”下并发度有所提升，并能保证主从复制中数据一致性，它也是MySQL默认设置。</li><li><code>innodb_autoinc_lock_mode=2</code>：该模式称为interleaved lock mode。该模式在所有情况下都不使用AUTO-INC锁，只是用mutex来保证全局的单调递增特性。如果一个INSERT操作无法确定数据量的话，很可能同一SQL插入的数据自增不连续，而对于Simple Insert则无影响。因此该模式对于基于语句的主从同步会有数据不一致的问题，而基于行和混合模式能安全同步。</li><li>MySQL自增列一般需要包含在某个索引的第一个字段，MySQL启动后第一次插入数据，INNODB会去获取当前最大自增列的数值，相当于执行<code>SELECT MAX(id) FROM t FOR UPDATE</code>。</li><li>InnoDB下auto_increment的表现：<ol><li>在所有模式下，如果插入操作被事务回滚，auto_increment不会回滚。</li><li>在所有模式下，delete数据，auto_increment不减小/回退。</li><li>在所有模式下，显示指定auto_increment列为0或NULL，InnoDB将认为该列未指定值，并自动为其生成新值。显示指定auto_increment列为大于当前auto_increment的值，则下一次将以此值为基准递增。</li><li>在所有模式下，显示插入负值或超过该列类型的最大值，则是未定义行为。实测，插入负值就是负值；插入超限值报错：<code>ERROR: Out of range value for column &#39;id&#39; at row 1</code>；自增超限将停留在数据类型的最大值，<strong>此时auto_increment失效，无法修改</strong>，如果自增字段是主键则报错：<code>ERROR: Duplicate entry &#39;2147483647&#39; for key &#39;PRIMARY&#39;</code>。</li><li>在所有模式下，truncate table将会清空auto_increment，然后从1开始。</li></ol></li><li>auto_increment操作：<ol><li>修改：<code>ALTER TABLE USER AUTO_INCREMENT = 100;</code>，如果修改值小于等于当前自增ID，修改无效。</li><li>从0开始：<code>SET sql_mode = &#39;NO_AUTO_VALUE_ON_ZERO&#39;;</code>。</li><li>创建表时指定：<code>...) engine=innodb auto_increment=100</code>。</li></ol></li><li><strong>注意：在MySQL5.7及以前，auto_increment仅维护到内存中，宕机或重启后使用<code>SELECT MAX(id) FROM t FOR UPDATE</code>初始化，这可能导致auto_increment回退或显示指定的值丢失。而从8.0开始auto_increment写入了redo log，无论是事务回滚、delete、显示指定等操作，只要写入redo log，服务器重启后还会正常初始化，auto_increment一般不会回滚（没写入redo log另说）。</strong></li></ul></li><li><p><strong>MVCC有什么缺陷，怎样解决？</strong></p></li><li><p><strong>死锁的定位与解决?</strong><br>答：<code>SHOW ENGINE INNODB STATUS</code>，查看LATEST DETECTED DEADLOCK，这里列出了死锁的事务、执行的SQL、来源IP等信息，可查看到事务当前持有的锁以及等待的锁，然后结合业务进行判定。</p></li></ol><h1 id="四、零散问题"><a href="#四、零散问题" class="headerlink" title="四、零散问题"></a>四、零散问题</h1><ol><li><p><strong>为什么要尽量设定一个主键?</strong><br>答：确保数据行在整张数据表中的唯一性，推荐使用自增ID作为主键，原因如下：</p><ul><li>自增Id能保证主键索引的高效性，使用业务字段做主键，如果字段长度无法保证，可能存在索引过大的问题。另外业务字段无法保证插入的顺序，因此索引可能需要频繁调整移动，造成内存碎片，降低插入性能。</li><li>业务字段存在被更新的可能性，如果更新的是主键的话，不仅操作繁琐，还可能违反唯一性约束，导致更新失败。另外，主键的更新意味着索引的变化（破坏了有序性），带来无意义的性能开销。</li></ul></li><li><p><strong>为什么mysql尽量要用Not NULL？</strong><br>答：NULL值在业务流程中很可能带来不必要的麻烦，比如常见的NPE。另外NULL值在MySQL中占用1字节空间，而空字符串则不占用空间。</p></li><li><p><strong>char和varchar的区别</strong><br>答：char是定长的，无论是否存满申请的长度，char都会占用那么多字符的空间。varchar申请的只是最大长度，实际占用为填充的字符串长度+1，最后一个字符存储使用的空间。在检索效率上char&gt;varchar，需要注意任何超出声明长度的字符串均无法插入char和varchar字段，如果长度无法确定，请考虑使用text，但该字段尽量不要用于索引、筛选条件之类的，会有性能问题。</p></li><li><p><strong>int和int(11)并没有区别，都是4字节。</strong></p></li><li><p><strong>超大分页怎么处理优化</strong><br>答：需要注意，MySQL的limit是先load offset+N行，然后放弃前offset行，这样效率很低。一种可行办法是先定位Id，再关联数据：<code>select a.* from t1 a, (select id from t1 where xxx limit 100000, 20) b where a.id = b.id</code>，上面这条SQL先limit查id，由于覆盖索引，这条SQL执行速度会很快。如果id连续性较好，还可以直接使用<code>where id&gt;100000 limit 20</code>，效果更好。</p></li><li><p><strong>MySQL分库分表</strong><br>答：一般按水平和垂直两个方向分割：</p><ul><li>垂直分表：即将一部分不常用、数据较大的字段分出去单独成立为扩展表。</li><li>垂直分库：一般需要结合实际业务，按业务进行库的拆分，如用户、订单、商品拆为3个库，单独放在3个服务器上，防止单机性能瓶颈。</li><li>水平分表：一般按某些规则，比如订单号取模，将数据分到不同的表中，但这些表还在一个库中，还是存在单机瓶颈问题，一般不采用。</li><li>水平分库分表：将单表数据切分到多个机器上，每个机器有相同的库和表。水平分库分表切分规则一般有如下几种：<ol><li>区间划分（RANGE）：比如流水号0-10000在一个表，10001-20000在另一个表。</li><li>HASH取模：比如按订单号取模分配到到对应机器，可能存在扩容的麻烦，考虑一致性hash（还是存在少量数据迁移）。</li><li>地理区域</li><li>时间：按数据冷热程度划分</li></ol></li></ul></li><li><p><strong>存储过程</strong>：互联网行业用的少，主要是需求变动太频繁，不好维护。银行用多（银行核心业务不用MySQL，外围产品可能使用），主要考虑数据安全性。</p></li><li><p><strong>关系型数据库范式建模</strong></p><ul><li>第一范式：每个属性都是原子的，不可再分。（存在数据冗余、插入异常、删除异常、更新异常等问题）</li><li>第二范式：非主属性完全依赖<code>码</code>，消除部分函数依赖。即消除(x, y) =&gt; z 且 (x) =&gt; z的情况。</li><li>第三范式：没有非主属性对码的<code>传递依赖</code>。即消除(x) =&gt; y，(y) =&gt; z的情况。</li><li>BC范式：不存在主属性对码的部分依赖和传递依赖。</li></ul></li><li><p><strong>SQL语句的执行顺序（select， where ，join ，limit， order by， group by， having等）</strong><br>答：from -&gt; join -&gt; on -&gt; where -&gt; group by -&gt; having -&gt; distinct -&gt; order by -&gt; select -&gt; limit </p></li><li><p><strong>MySQL drop、 delete、 truncate的区别（InnoDB）</strong><br>答：</p><ul><li>drop DDL，删除表结构和数据，释放表空间，不会记录到日志中，无法rollback，可通过其他方式恢复。</li><li>delete DML，删除指定筛选条件的数据，每次从表中删除一条，删除操作记录到undo和redo log中，表空间得不到及时释放，需要执行<code>optimize table table_name</code>释放空间，未释放的空间下次insert可重复说使用，保留表和索引结构，计数器不变。</li><li>truncate DDL，清空表数据，计数器清零，不记录日志，无法rollback，可通过其他方式恢复，立即释放表空间。类似(drop + create)。</li></ul></li><li><p><strong>MySQL临时表</strong><br>答：使用<code>TEMPORARY</code>关键字创建MySQL临时表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TEMPORARY</span> <span class="keyword">TABLE</span> tmp_table (   </span><br><span class="line"><span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="keyword">value</span> <span class="built_in">INTEGER</span> <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line">) <span class="keyword">TYPE</span> = <span class="keyword">HEAP</span></span><br></pre></td></tr></table></figure><p>如果正式表和临时表重名，临时表将屏蔽正式表。临时表在连接断开时自动删除，也可以手动DROP。</p></li><li><p><strong>关系型数据库和非关系型数据库的优缺点</strong><br>答：关系型数据库是指采用了关系模型来组织数据的数据库，数据建模一般采用E-R模型。</p><ul><li>关系型数据库能保证事务的一致性。</li><li>可以使用单个SQL在多个表之间做复杂查询。<br>非关系型数据库：</li><li>NoSQL一般基于键值存储，不需要经过SQL层解析，配合Hash策略，读写性能很好。</li><li>同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      MySQL面试之从准备到放弃
    
    </summary>
    
      <category term="面试" scheme="https://blog.zjee.ml/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="MySQL" scheme="https://blog.zjee.ml/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>傅里叶级数可视化</title>
    <link href="https://blog.zjee.ml/2020/05/02/fourier-seriers-1/"/>
    <id>https://blog.zjee.ml/2020/05/02/fourier-seriers-1/</id>
    <published>2020-05-02T09:39:58.000Z</published>
    <updated>2020-05-02T09:39:58.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="傅里叶级数"><a href="#傅里叶级数" class="headerlink" title="傅里叶级数"></a>傅里叶级数</h2><p>法国数学家傅里叶发现，任何周期函数都可以用正弦函数和余弦函数构成的无穷级数来表示，即：</p><p>$<br>f(t)=A_{0}+\sum_{n=1}^{\infty}A_{n}\sin(n\omega t+\varphi_{n}) \<br>=A_{0}+\sum_{n=1}^{\infty}a_{n}\cos n\omega t+ b_{n}\sin n\omega t<br>$</p><p>示例：方波函数的傅里叶展开式为 $ f(t)=\frac{2E}{\Pi}\sum_{n=1}^{\infty}\frac{1}{2n-1}\sin (2n-1)\omega t$<br>我们取前5项进行叠加，就能得到如下绘制效果。</p><iframe src="fourier.html" width="100%" height="600px" frameborder="0">浏览器不支持iframe标签</iframe>]]></content>
    
    <summary type="html">
    
      使用H5画布实现的傅里叶级数可视化
    
    </summary>
    
      <category term="其他" scheme="https://blog.zjee.ml/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="傅里叶级数" scheme="https://blog.zjee.ml/tags/%E5%82%85%E9%87%8C%E5%8F%B6%E7%BA%A7%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal源码阅读</title>
    <link href="https://blog.zjee.ml/2020/04/19/thread-local/"/>
    <id>https://blog.zjee.ml/2020/04/19/thread-local/</id>
    <published>2020-04-19T10:08:55.000Z</published>
    <updated>2020-04-19T10:08:55.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、ThreadLocal概述"><a href="#一、ThreadLocal概述" class="headerlink" title="一、ThreadLocal概述"></a>一、ThreadLocal概述</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在Java开发中，多线程是一个永远绕不开的话题。Java服务器中通常使用一组线程处理一个会话或一个连接，这一组线程一般具有父子关系，它们往往需要客户端传递的用户信息来完成业务逻辑，这些信息仅针对本次连接或会话有效。当然我们可以以参数的形式传递这些数据，但当参数异常复杂的时候，层间传递就变得很枯燥，有没有一种方法可以简化这种场景？当然有，他就是ThreadLocal技术，ThreadLocal是一种线程局部变量共享机制，它独立于语言，但本次仅讨论Java语言范畴。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用<code>ThreadLocal</code>维护的变量在每个线程内部维护一个副本，对该变量的修改仅对该线程可见（指ThreadLocal.set(obj)，对象成员修改除外），同样可以在线程内部的任意位置使用它。这样，既满足了线程之间的隔离要求，又减少了参数的传递工作，何乐而不为之！另外，我们上面提到，如果是一组线程（这一组线程具有父子关系）需要变量共享呢？没问题，Java给我们提供了<code>InheritableThreadLocal</code>，只要我们在父线程中设置了相关变量，子线程会自动继承这些变量的值，但本质上是子线程初始化自己的副本时使用了父线程的值，此后对各自副本的修改（指ThreadLocal.set(obj)，对象成员修改除外）<strong>也仅在当前线程生效</strong>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意，网上很多博客写着ThreadLocal是用来解决多线程并发问题的，这种理解在我看来是错误的。多线程并发指的是多个线程对同一个临界区操作的互斥问题，或多个线程之间的同步问题，而ThreadLocal在每个线程都有一个副本，不存在互斥，也不存在同步，因此跟多线程并发问题无关。</p><h1 id="二、ThreadLocal运用"><a href="#二、ThreadLocal运用" class="headerlink" title="二、ThreadLocal运用"></a>二、ThreadLocal运用</h1><p>上面简单介绍了ThreadLocal的性质，下面来看一下具体的运用场景：</p><ol><li><p><strong>Session管理</strong>：正如我们开篇提到的用户信息传递问题，本质上就是一个Session管理，它在一次会话开始的时候创建ThreadLocal变量保存所有全局信息，会话结束的时候释放ThreadLocal。如果线程的生命周期与会话的生命周期一致，则可以不用手动释放ThreadLocal变量，如果使用了线程池就必须在提交任务时手动初始化ThreadLocal，结束任务时手动清理ThreadLocal保存的数据，否则就可能使用的前一个会话遗留的脏数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;UserInfo&gt; USER_INFO = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Executor EXECUTOR = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/user"</span>) </span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">login</span><span class="params">(UserInfo userInfo)</span> </span>&#123;</span><br><span class="line">        USER_INFO.set(userInfo);</span><br><span class="line">        User user = userService.login();</span><br><span class="line">        EXECUTOR.execute(()-&gt;&#123;</span><br><span class="line">            <span class="comment">//注意线程池需要手动管理ThreadLocal</span></span><br><span class="line">            USER_INFO.set(userInfo);</span><br><span class="line">            userService.doSomething();</span><br><span class="line">            USER_INFO.remove();</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>连接管理</strong>：当我们有一个线程池用来处理一些远程任务，每个任务都需要与远程主机建立连接，那么为了减少频繁建立连接带来的性能开销，我们可以使用ThreadLocal来保存这些连接，使之与线程的生命周期一致，这样就避免了频繁建立远程连接带来的开销。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;UserInfo&gt; USER_INFO = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;RemoteConnection&gt; REMOTE_CONNECTION = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Executor EXECUTOR = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">login</span><span class="params">(UserInfo userInfo)</span> </span>&#123;</span><br><span class="line">        USER_INFO.set(userInfo);</span><br><span class="line">        User user = userService.login();</span><br><span class="line">        EXECUTOR.execute(()-&gt;&#123;</span><br><span class="line">            <span class="comment">//注意线程池需要手动管理ThreadLocal</span></span><br><span class="line">            USER_INFO.set(userInfo);</span><br><span class="line">            <span class="comment">//仅需要第一个任务初始化connection</span></span><br><span class="line">            RemoteConnection connection = REMOTE_CONNECTION.get();</span><br><span class="line">            <span class="keyword">if</span>(connection == <span class="keyword">null</span>) &#123;</span><br><span class="line">                connection = RemoteUtil.getConnection();</span><br><span class="line">                REMOTE_CONNECTION.set(connection);</span><br><span class="line">            &#125;</span><br><span class="line">            userService.doSomething(connection);</span><br><span class="line">            USER_INFO.remove();</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://www.cnblogs.com/fishisnow/p/6396989.html" target="_blank" rel="noopener">ThreadLocal在Spring事务管理中的应用</a></p></li></ol><h1 id="三、ThreadLocal原理"><a href="#三、ThreadLocal原理" class="headerlink" title="三、ThreadLocal原理"></a>三、ThreadLocal原理</h1><h2 id="3-1-ThreadLocal原理"><a href="#3-1-ThreadLocal原理" class="headerlink" title="3.1 ThreadLocal原理"></a>3.1 ThreadLocal原理</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;事实上ThreadLocal本身并不存储数据，它只是数据的 <em>管家</em> 。在Thread内部有<code>threadLocals</code>（对应<code>ThreadLocal</code>）和<code>inheritableThreadLocals</code>（对应<code>InheritableThreadLocal</code>）两个Map（它们也是hash map，但有自己的实现），它们维护者ThreadLocal/InheritableThreadLocal的副本。下面以threadLocals为例，threadLocals类型是<code>ThreadLocal.ThreadLocalMap</code>，它定义在ThreadLocal类中，其key是ThreadLocal变量的<strong>弱引用</strong>，value是对应副本值。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于同一个ThreadLocal在不同Thread中，threadLocals中的key是同一个对象，这确保了同一个threadLocal变量能检索到 <em>同一个类型</em> 的value，但value在不同线程之间是独立的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于不同ThreadLocal在同一个线程中来说，不同的Thread Local对应 <em>不同类型</em> 的值，也就是threadLocals中的多个entry。</p><img src="02.png" alt="ThreadLocal与多线程之间的关系" style="zoom: 50%;"><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ThreadLocalMap中的key继承了<code>WeakReference</code>，因为ThreadLocal对于用户而言就是一个普通变量，它的生命周期应当符合一般变量行为。如果这里是强引用，那么即便用户将其引用置为null(或者方法返回、对象回收等等)，该ThreadLocal对象可能依然无法被回收，因为还有其他线程的threadLocalMap中的entry对其有强引用。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将Entry中的key设为弱引用即可解决ThreadLocal GC回收的问题，但对应value又会带来内存泄露，对于value而言依然有<code>thread -&gt; threadLocalMap -&gt; entry -&gt; value</code>这样的引用链存在，且该value永远无法被访问，直到线程结束。为解决这一问题，该Map中新增了部分对”stale entry”的回收逻辑。</p><img src="01.jpg" alt="ThreadLocal弱引用" style="zoom:80%;"><h2 id="3-2-ThreadLocal源码"><a href="#3-2-ThreadLocal源码" class="headerlink" title="3.2 ThreadLocal源码"></a>3.2 ThreadLocal源码</h2><details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个变量对应一个ThreadLocal，该变量在不同线程之间有不同的副本</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//每个线程都有一个threadLocalMap变量，其key为一个ThreadLocal变量，value为我们设置的值</span></span><br><span class="line">    <span class="comment">//这里的threadLocalHashCode就充当了key的hashCode，它就是threadLocalMap中用于计算hash地址的依据</span></span><br><span class="line">    <span class="comment">//ThreadLocal中计算hashCode的方法很简单，就是从0开始不断累加HASH_INCREMENT</span></span><br><span class="line">    <span class="comment">//为保证不同ThreadLocal对象之间HashCode不同，其不断累加的临时变量nextHashCode是static的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threadLocalHashCode = nextHashCode();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用于计算threadLocalHashCode的【静态】临时变量，它保存的是下一个ThreadLocal变量的Hash地址</span></span><br><span class="line">    <span class="comment">//并每创建一个ThreadLocal对象更新一次</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger nextHashCode = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//不断累加的HashCode差值，这个值可以保证在2^N范围类hashcode均匀分布，保证检索效率。</span></span><br><span class="line">    <span class="comment">//该值与黄金分割和斐波那契散列算法有关，参考：https://zhuanlan.zhihu.com/p/40515974</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_INCREMENT = <span class="number">0x61c88647</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//计算nextHashCode并返回当前对象的hashCode</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextHashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//当某个线程下对应的ThreadLocal变量未设置时（threadLocalMap对应的k-v不存在）</span></span><br><span class="line">    <span class="comment">//就会调用该方法返回一个初始值，默认返回null，可以继承重写该方法</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//返回一个具有指定初始化supplier的ThreadLocal对象</span></span><br><span class="line">    <span class="comment">//它会使用supplier获取(在initialValue方法中调用)初始值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; <span class="function">ThreadLocal&lt;S&gt; <span class="title">withInitial</span><span class="params">(Supplier&lt;? extends S&gt; supplier)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SuppliedThreadLocal&lt;&gt;(supplier);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//默认无参构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadLocal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//返回该ThreadLocal变量对应于当前线程的副本值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取当前线程</span></span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        <span class="comment">//获取当前线程的ThreadLocalMap</span></span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//获取当前threadLocal对应的entry</span></span><br><span class="line">            ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                <span class="comment">//当前threadLocal对应的value</span></span><br><span class="line">                T result = (T)e.value;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//当前threadLocal对应值不存在就初始化，并返回初始化的值</span></span><br><span class="line">        <span class="keyword">return</span> setInitialValue();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果当前线程的ThreadLocalMap为null或者当前ThreadLocal值不存在，</span></span><br><span class="line">    <span class="comment">//就初始化map(如果需要的话)和当前threadLocal对应的k-v，并返回初始值</span></span><br><span class="line">    <span class="comment">//注意ThreadLocalMap虽然在Thread中，但Thread并不初始化，全部交由ThreadLocal管理</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        T value = initialValue();</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="comment">//map存在就设置初始值</span></span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">            map.set(<span class="keyword">this</span>, value);</span><br><span class="line">        <span class="comment">//map不存在就创建map并初始化</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置当前线程对应ThreadLocal的值</span></span><br><span class="line">    <span class="comment">//过程与setInitialValue一致</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">            map.set(<span class="keyword">this</span>, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//移除当前线程对应于该ThreadLocal的副本（建议不使用threadLocal的时候手动释放）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">        <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">            m.remove(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取线程关联的threadLocalMap</span></span><br><span class="line">    <span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建一个ThreadLocalMap并使用给定初始化参数(this-&gt;firstValue)初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">        t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建一个从父线程继承下来的ThreadLocalMap，该Map包含父线程ThreadLocalMap的全部值</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> ThreadLocalMap <span class="title">createInheritedMap</span><span class="params">(ThreadLocalMap parentMap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadLocalMap(parentMap);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//InheritableThreadLocal中使用</span></span><br><span class="line">    <span class="function">T <span class="title">childValue</span><span class="params">(T parentValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//用supplier作为初始化器的ThreadLocal实现类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SuppliedThreadLocal</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//用户提供的初始化器</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Supplier&lt;? extends T&gt; supplier;</span><br><span class="line">    </span><br><span class="line">        SuppliedThreadLocal(Supplier&lt;? extends T&gt; supplier) &#123;</span><br><span class="line">            <span class="keyword">this</span>.supplier = Objects.requireNonNull(supplier);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//通过supplier获取初始值</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> supplier.get();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//ThreadLocalMap的实现，仅用于保存ThreadLocal变量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//Entry定义，注意key的弱引用</span></span><br><span class="line">        <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">            <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">            Object value;</span><br><span class="line">    </span><br><span class="line">            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">                <span class="keyword">super</span>(k);</span><br><span class="line">                value = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//初始容量</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//hash桶</span></span><br><span class="line">        <span class="keyword">private</span> Entry[] table;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//存储的entity个数</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//扩容阈值</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> threshold; <span class="comment">// Default to 0</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment">//设置扩容阈值为2/3</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setThreshold</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">            threshold = len * <span class="number">2</span> / <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//使用线性探查法寻找下一个地址</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> ((i + <span class="number">1</span> &lt; len) ? i + <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//使用线性探查法寻找上一个地址（回收脏entry的时候使用）</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">prevIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> ((i - <span class="number">1</span> &gt;= <span class="number">0</span>) ? i - <span class="number">1</span> : len - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//根据给定的初始值，初始化ThreadLocalMap（至少有一个值才会初始化）</span></span><br><span class="line">        ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">            table = <span class="keyword">new</span> Entry[INITIAL_CAPACITY];</span><br><span class="line">            <span class="keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">            table[i] = <span class="keyword">new</span> Entry(firstKey, firstValue);</span><br><span class="line">            size = <span class="number">1</span>;</span><br><span class="line">            setThreshold(INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//拷贝构造</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">ThreadLocalMap</span><span class="params">(ThreadLocalMap parentMap)</span> </span>&#123;</span><br><span class="line">            Entry[] parentTable = parentMap.table;</span><br><span class="line">            <span class="keyword">int</span> len = parentTable.length;</span><br><span class="line">            setThreshold(len);</span><br><span class="line">            table = <span class="keyword">new</span> Entry[len];</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">                Entry e = parentTable[j];</span><br><span class="line">                <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                    ThreadLocal&lt;Object&gt; key = (ThreadLocal&lt;Object&gt;) e.get();</span><br><span class="line">                    <span class="keyword">if</span> (key != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        Object value = key.childValue(e.value);</span><br><span class="line">                        Entry c = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">                        <span class="keyword">int</span> h = key.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">                        <span class="keyword">while</span> (table[h] != <span class="keyword">null</span>)</span><br><span class="line">                            <span class="comment">//使用线性探查法解决冲突，和hashMap不一样</span></span><br><span class="line">                            h = nextIndex(h, len);</span><br><span class="line">                        table[h] = c;</span><br><span class="line">                        size++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//根据key获取entry</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">            Entry e = table[i];</span><br><span class="line">            <span class="comment">//注意这里key的比较是==，不是equals，因为不同线程存的threadLocal就是同一个对象的引用</span></span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">                <span class="keyword">return</span> e;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">//线性探查寻找entry</span></span><br><span class="line">                <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//线性探查寻找entry</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> Entry <span class="title">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="keyword">int</span> i, Entry e)</span> </span>&#123;</span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">                <span class="comment">//找到了</span></span><br><span class="line">                <span class="keyword">if</span> (k == key)</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">                <span class="comment">//key==null表示该value是一个泄露值（永远无法被使用），需要进行回收</span></span><br><span class="line">                <span class="keyword">if</span> (k == <span class="keyword">null</span>)</span><br><span class="line">                    expungeStaleEntry(i);</span><br><span class="line">                <span class="keyword">else</span><span class="comment">//继续探查下一个位置</span></span><br><span class="line">                    i = nextIndex(i, len);</span><br><span class="line">                e = tab[i];</span><br><span class="line">            &#125;<span class="comment">//没有找到返回null</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//添加一个键值对</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            <span class="keyword">int</span> len = tab.length;</span><br><span class="line">            <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">                 e != <span class="keyword">null</span>;</span><br><span class="line">                 e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">                ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">    </span><br><span class="line">                <span class="comment">//key存在直接替换值</span></span><br><span class="line">                <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">                    e.value = value;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">    </span><br><span class="line">                <span class="comment">//如果当前选定位置是一个“stale entry”，则按照一定的算法插入entry</span></span><br><span class="line">                <span class="comment">//并清理一定范围内的“stale entry”</span></span><br><span class="line">                <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    replaceStaleEntry(key, value, i);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果冲突了就再次返回调用nextIndex探查下一个地址</span></span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">            <span class="keyword">int</span> sz = ++size;</span><br><span class="line">            <span class="comment">//如果？？？</span></span><br><span class="line">            <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">                rehash();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//移除一个元素（不会导致"stale entry"）</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            <span class="keyword">int</span> len = tab.length;</span><br><span class="line">            <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">                 e != <span class="keyword">null</span>;</span><br><span class="line">                 e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.get() == key) &#123;</span><br><span class="line">                    e.clear(); <span class="comment">//清除value</span></span><br><span class="line">                    <span class="comment">//清理脏entry</span></span><br><span class="line">                    expungeStaleEntry(i);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 插入新entry并清理周围"stale entry"</span></span><br><span class="line">        <span class="comment">// 新的entry一定在staleSlot位置</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">replaceStaleEntry</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            <span class="keyword">int</span> len = tab.length;</span><br><span class="line">            Entry e;</span><br><span class="line">    </span><br><span class="line">            <span class="comment">//回溯查找泄露entry的最小位置，直到遇见一个未占用的hash桶为止</span></span><br><span class="line">            <span class="comment">//中途记录下泄露entry的最小位置，作为清理的起始点</span></span><br><span class="line">            <span class="keyword">int</span> slotToExpunge = staleSlot;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = prevIndex(staleSlot, len); (e = tab[i]) != <span class="keyword">null</span>; </span><br><span class="line">                 i = prevIndex(i, len)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.get() == <span class="keyword">null</span>)</span><br><span class="line">                    slotToExpunge = i;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            <span class="comment">//向后查找泄露entry的最大位置，直到遇见一个未占用的hash桶或找到一个可替换的entry为止</span></span><br><span class="line">            <span class="comment">//并在合适的时机插入新entry</span></span><br><span class="line">            <span class="comment">//注意：从i到下一个未占用的hash桶之间是必须要遍历的，这样可以检查我们要插入的key先前</span></span><br><span class="line">            <span class="comment">//是否出现过，如果出现过就必须替换value，这样才能保证key的唯一性</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = nextIndex(staleSlot, len);</span><br><span class="line">                 (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">                 i = nextIndex(i, len)) &#123;</span><br><span class="line">                ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果发现有可替换的entry</span></span><br><span class="line">                <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">                    e.value = value; <span class="comment">//替换value</span></span><br><span class="line">                    <span class="comment">//把当前entry换到staleSlot处，注意staleSlot是该key第一个可用位置</span></span><br><span class="line">                    <span class="comment">//交换既满足了key的唯一性，又尽可能保证key的检索效率</span></span><br><span class="line">                    tab[i] = tab[staleSlot];</span><br><span class="line">                    tab[staleSlot] = e;</span><br><span class="line">    </span><br><span class="line">                    <span class="comment">//如果一直没有找到脏entry，就以当前位置为起点清理</span></span><br><span class="line">                    <span class="comment">//注意，当前位置是和staleSlot交换过的，所以当前位置一定是一个脏entry</span></span><br><span class="line">                    <span class="keyword">if</span> (slotToExpunge == staleSlot)</span><br><span class="line">                        slotToExpunge = i;</span><br><span class="line">    <span class="comment">//清理脏entry</span></span><br><span class="line">                    cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">    </span><br><span class="line">                <span class="comment">//如果前向搜索没有发现脏enyrt，并且当前节点是脏entry，就以当前位置为清理的起始点</span></span><br><span class="line">                <span class="keyword">if</span> (k == <span class="keyword">null</span> &amp;&amp; slotToExpunge == staleSlot)</span><br><span class="line">                    slotToExpunge = i;</span><br><span class="line">            &#125;<span class="comment">// end for</span></span><br><span class="line">    </span><br><span class="line">            <span class="comment">//如果没有找到可替换的entry，将staleSlot位置释放，并重新填充一个新entry</span></span><br><span class="line">            tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">            tab[staleSlot] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">    </span><br><span class="line">            <span class="comment">//如果遍历过程中发现了其他脏entry，则清理之</span></span><br><span class="line">            <span class="comment">//slotToExpunge一直是清理的起始点，起始点尽可能小，清理范围尽可能大</span></span><br><span class="line">            <span class="keyword">if</span> (slotToExpunge != staleSlot)</span><br><span class="line">                <span class="comment">//两次清理</span></span><br><span class="line">                <span class="comment">//第一次：清理slotToExpunge到下一个null slot之间的脏entry</span></span><br><span class="line">                <span class="comment">//第二次：从下一个null的下一个位置开始，最少扫描log2(len)次</span></span><br><span class="line">                cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//清理stale entry</span></span><br><span class="line">        <span class="comment">//参数：staleSlot 当前stale entry的位置</span></span><br><span class="line">        <span class="comment">//返回：下一个空hash桶(slot)的位置，这个区间内所有的脏entry都会被清理掉</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expungeStaleEntry</span><span class="params">(<span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    </span><br><span class="line">            <span class="comment">// 清理当前指定位置staleSlot上的stale entry</span></span><br><span class="line">            tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">            tab[staleSlot] = <span class="keyword">null</span>;</span><br><span class="line">            size--;</span><br><span class="line">    </span><br><span class="line">            <span class="comment">//向后遍历直到下一个空桶位置</span></span><br><span class="line">            Entry e;</span><br><span class="line">            <span class="keyword">int</span> i;</span><br><span class="line">            <span class="keyword">for</span> (i = nextIndex(staleSlot, len);</span><br><span class="line">                 (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">                 i = nextIndex(i, len)) &#123;</span><br><span class="line">                ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">                <span class="comment">//遇见stale entry则清理之</span></span><br><span class="line">                <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    e.value = <span class="keyword">null</span>;</span><br><span class="line">                    tab[i] = <span class="keyword">null</span>;</span><br><span class="line">                    size--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//如果遇见正常的entry就重新计算地址</span></span><br><span class="line">                    <span class="comment">//因为前面释放了stale entry，当前entry很大可能有更优的存储位置</span></span><br><span class="line">                    <span class="comment">//减少e的线性探查次数，提升访问效率</span></span><br><span class="line">                    <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">                    <span class="comment">//e的hash地址不在当前位置，证明e一定是因为hash地址冲突而放到了这里</span></span><br><span class="line">                    <span class="comment">//现在释放了之前部分stale entry，e很可能有更优秀的位置</span></span><br><span class="line">                    <span class="comment">//如果h==i，则当前位置就是e的最佳位置，不做任何操作</span></span><br><span class="line">                    <span class="keyword">if</span> (h != i) &#123;</span><br><span class="line">                        <span class="comment">//释放当前位置</span></span><br><span class="line">                        tab[i] = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="comment">//从h向后重新给e找位置</span></span><br><span class="line">                        <span class="keyword">while</span> (tab[h] != <span class="keyword">null</span>)</span><br><span class="line">                            h = nextIndex(h, len);</span><br><span class="line">                        tab[h] = e;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//返回下一个空slot的位置</span></span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//从i的下一个位置开始清理</span></span><br><span class="line">        <span class="comment">//n控制扫描次数，扫描log2(n)轮，每一轮根据情况扫描一段或一个，整体时间复杂度为nlog2(n)</span></span><br><span class="line">        <span class="comment">//兼顾扫描效率和清理效果</span></span><br><span class="line">        <span class="comment">//如果有stale entry被删除则返回true</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">cleanSomeSlots</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">boolean</span> removed = <span class="keyword">false</span>;</span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            <span class="keyword">int</span> len = tab.length;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                i = nextIndex(i, len);</span><br><span class="line">                Entry e = tab[i];</span><br><span class="line">                <span class="comment">//如果发现stale entry</span></span><br><span class="line">                <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    n = len;</span><br><span class="line">                    removed = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="comment">//移除[i, next null slot]之间的脏entry，i为next null slot位置</span></span><br><span class="line">                    i = expungeStaleEntry(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">while</span> ( (n &gt;&gt;&gt;= <span class="number">1</span>) != <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> removed;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//rehash</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            expungeStaleEntries(); </span><br><span class="line">            <span class="comment">// size &gt;= 5 / 12(len) ?</span></span><br><span class="line">            <span class="keyword">if</span> (size &gt;= threshold - threshold / <span class="number">4</span>)</span><br><span class="line">                resize();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//扩容，新容量为旧容量的两倍</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Entry[] oldTab = table;</span><br><span class="line">            <span class="keyword">int</span> oldLen = oldTab.length;</span><br><span class="line">            <span class="keyword">int</span> newLen = oldLen * <span class="number">2</span>;</span><br><span class="line">            Entry[] newTab = <span class="keyword">new</span> Entry[newLen];</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">            <span class="comment">//遍历旧table（将旧table中的内容移动到新table）</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldLen; ++j) &#123;</span><br><span class="line">                Entry e = oldTab[j];</span><br><span class="line">                <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">                    <span class="comment">//如果还遇到stale entry，直接unlink</span></span><br><span class="line">                    <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        e.value = <span class="keyword">null</span>; <span class="comment">// Help the GC</span></span><br><span class="line">                    &#125; </span><br><span class="line">                    <span class="comment">//计算e在新表中的位置，并放入其中</span></span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (newLen - <span class="number">1</span>);</span><br><span class="line">                        <span class="keyword">while</span> (newTab[h] != <span class="keyword">null</span>)</span><br><span class="line">                            h = nextIndex(h, newLen);</span><br><span class="line">                        newTab[h] = e;</span><br><span class="line">                        count++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            <span class="comment">//更新threshold</span></span><br><span class="line">            setThreshold(newLen);</span><br><span class="line">            size = count;</span><br><span class="line">            table = newTab;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 清理所有脏entry，并重新计算每一个有效元素的最佳位置</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">expungeStaleEntries</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            <span class="keyword">int</span> len = tab.length;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">                Entry e = tab[j];</span><br><span class="line">                <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == <span class="keyword">null</span>)</span><br><span class="line">                    expungeStaleEntry(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>  </details>]]></content>
    
    <summary type="html">
    
      在Java开发中，多线程是一个永远绕不开的话题，与之相关的ThreadLocal也备受关注。了解ThreadLocal源码会让我们在实际运用时更得心应手，避免很多不必要的麻烦。本文就从ThreadLocal源码入手，带大家深入理解其底层原理和注意事项。
    
    </summary>
    
      <category term="java" scheme="https://blog.zjee.ml/categories/java/"/>
    
    
      <category term="java 多线程" scheme="https://blog.zjee.ml/tags/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Firewall防火墙软件常用操作</title>
    <link href="https://blog.zjee.ml/2020/03/27/firewall-cmds/"/>
    <id>https://blog.zjee.ml/2020/03/27/firewall-cmds/</id>
    <published>2020-03-27T08:39:58.000Z</published>
    <updated>2020-03-27T08:39:58.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>开启端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=&lt;port&gt;/&lt;protocol&gt; --permanent </span><br><span class="line"><span class="meta">#</span>&lt;port&gt; 要开启的端口 </span><br><span class="line"><span class="meta">#</span>&lt;protocol&gt; 协议：tcp、udp</span><br></pre></td></tr></table></figure></li><li><p>关闭端口</p><p><code>firewall-cmd --zone=public --remove-port=&lt;port&gt;/&lt;protocol&gt; --permanent</code> </p></li><li><p>批量开启区间端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=&lt;start&gt;-&lt;end&gt;/&lt;protocol&gt; --permanent</span><br><span class="line"><span class="meta">#</span>&lt;start&gt;、&lt;end&gt;：要开启的区间[start, end]</span><br></pre></td></tr></table></figure></li><li><p>开启、关闭、重启防火墙命令： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl start/stop/restart firewalld.service </span><br><span class="line"><span class="meta">#</span> 或者 </span><br><span class="line">service firewalld start/stop/restart</span><br></pre></td></tr></table></figure></li><li><p>重新载入防火墙配置（更新配置后需要执行此命令）：</p><p><code>firewall-cmd --reload</code></p></li><li><p>查看开放的端口：</p><p><code>firewall-cmd --permanent --list-port</code></p></li><li><p>禁用防火墙 </p><p><code>systemctl stop firewalld</code></p></li><li><p>设置开机启动 </p><p><code>systemctl enable firewalld</code></p></li><li><p>停止防火墙并禁用开机启动 </p><p><code>systemctl disable firewalld</code></p></li><li><p>查看状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl status firewalld </span><br><span class="line"><span class="meta">#</span> 或者 </span><br><span class="line">firewall-cmd --state</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      防火墙是Linux运维中常见操作之一，本文记录了firewall防火墙软件(CentOS7、8)的常见操作。
    
    </summary>
    
      <category term="linux" scheme="https://blog.zjee.ml/categories/linux/"/>
    
    
      <category term="linux firewall" scheme="https://blog.zjee.ml/tags/linux-firewall/"/>
    
  </entry>
  
  <entry>
    <title>JDK动态代理</title>
    <link href="https://blog.zjee.ml/2020/01/05/jdk-proxy/"/>
    <id>https://blog.zjee.ml/2020/01/05/jdk-proxy/</id>
    <published>2020-01-05T07:58:32.000Z</published>
    <updated>2020-01-05T07:58:32.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>代理</strong>是一种结构型设计模式， 让你能提供真实服务对象的替代品给客户端使用。 代理接收客户端的请求并进行一些处理 （访问控制和缓存等）， 然后再将请求传递给服务对象。</p><p>代理对象拥有和服务对象相同的接口， 这使得当其被传递给客户端时可与真实对象互换。 </p><p style="text-align:right">——Copy From <a href="https://refactoring.guru/design-patterns/proxy/java/example" target="_blank">refactoring.guru</a></p>                                                                                                                       </blockquote><h1 id="一、静态代理"><a href="#一、静态代理" class="headerlink" title="一、静态代理"></a>一、静态代理</h1><p>静态代理代码很简单，但其设计思想很重要。示例如下：</p><details><summary style="color:blue">点击查看代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//UserService.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"><span class="function">User <span class="title">getUser</span><span class="params">(<span class="keyword">int</span> userId)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//UserServiceImpl.java UserService的实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(<span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> User(userId, xxx, xxx);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//UserServiceProxy.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceProxy</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> UserService delegate;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">UserServiceProxy</span><span class="params">(UserService target)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.delegate = target; <span class="comment">//被代理对象</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(<span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//前置增强</span></span><br><span class="line">    System.out.println(<span class="string">"before get user"</span>);</span><br><span class="line">  User user = <span class="keyword">this</span>.delegate.getUser(userId);</span><br><span class="line">    <span class="comment">//后置增强</span></span><br><span class="line">    System.out.println(<span class="string">"after get user"</span>);</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Test.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  UserService target = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">    UserService proxy = <span class="keyword">new</span> UserServiceProxy(target);</span><br><span class="line">    User user = proxy.getUser(<span class="number">1001</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h1 id="二、JDK动态代理"><a href="#二、JDK动态代理" class="headerlink" title="二、JDK动态代理"></a>二、JDK动态代理</h1><p>JDK动态代理可以看成一个“万能中介”，它最终实现方法粒度的增强，它的<code>InvocationHandler</code>是“万能的”，根据我们传入的target以及调用不同的方法实现不同的增强效果。需要注意的是JDK动态代理只能代理接口，这与它背后的实现逻辑有关系。</p><h2 id="2-1、为什么需要动态代理"><a href="#2-1、为什么需要动态代理" class="headerlink" title="2.1、为什么需要动态代理"></a>2.1、为什么需要动态代理</h2><p>静态代理虽然能够实现大多数功能，但每个目标对象都需要生成一个代理类，当被代理类太多时，开发和维护代理类将是一件很可怕的事情，同时静态代理还不具备处理动态生成的class的能力。基于上诉痛点，各种动态代理技术应运而生，JDK动态代理便是其中之一。</p><h2 id="2-2、JDK动态代理示例"><a href="#2-2、JDK动态代理示例" class="headerlink" title="2.2、JDK动态代理示例"></a>2.2、JDK动态代理示例</h2><details><summary style="color:blue">点击查看代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口&amp;实现类参考上面静态代理的例子</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//DynamicProxy.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//真正的实现类,或者说被代理对象（不是必须的）</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DynamicProxy</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//前置增强</span></span><br><span class="line">        System.out.println(<span class="string">"before invoke"</span>);</span><br><span class="line">        Object res = method.invoke(target, args);</span><br><span class="line">        <span class="comment">//后置增强</span></span><br><span class="line">        System.out.println(<span class="string">"after invoke"</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Test.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//代理类对象，注意它不是我们的目标代理对象，可以理解为它只是个中介</span></span><br><span class="line">        InvocationHandler handler = <span class="keyword">new</span> DynamicProxy(<span class="keyword">new</span> UserServiceImpl());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//动态生成最终目标代理对象</span></span><br><span class="line">        UserService proxy = (UserService) Proxy.newProxyInstance(</span><br><span class="line">                UserServiceImpl.class.getClassLoader(),</span><br><span class="line">                UserServiceImpl.class.getInterfaces(),</span><br><span class="line">                handler</span><br><span class="line">        );</span><br><span class="line">        proxy.getUser(<span class="number">123</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>我们可以看到，JDK动态代理核心就在于实现<code>InvocationHandler</code>，重写<code>invoke</code>方法。</p><h2 id="2-3、InvocationHandler接口"><a href="#2-3、InvocationHandler接口" class="headerlink" title="2.3、InvocationHandler接口"></a>2.3、InvocationHandler接口</h2><ol><li><p><code>InvocationHandler</code>可以理解为一个”执行器“，每个被代理的对象中的所有方法都要经过它，由它决定下一步怎么处理，所以实现<code>InvocationHandler</code>是整个JDK动态代理的核心，不同的功能可以使用不同的<code>InvocationHandler</code>来实现。</p></li><li><p><code>InvocationHandler</code>中的核心方法<code>invoke</code>：</p><p>2.1、<strong>Object proxy：</strong> 该参数是<strong><em>最终的</em>目标代理对象</strong>，一般代理用不到它，在具有链式操作的代理对象中可以直接返回该对象，使得最终代理对象也可以使用链式操作。</p><p>2.2 、<strong>Method method：</strong>该参数是我们要调用的<strong>目标方法</strong>，一般会使用<code>method.invoke(target, args)</code>继续调用被代理对象的具体实现。</p><p>2.3、<strong>Object[] args</strong>: 该参数是目标方法参数。</p><p>2.4、<strong>返回值</strong>：由于该方法是“万能的”，因此我们可以根据传入的参数、调用的方法、目标对象不同而返回不同的结果。</p></li><li><p>注意事项</p><p>3.1、在调用目标方法时，传入的实例对象<strong>不可以</strong>是第一个参数proxy，该参数是最终生成的代理对象，如果继续在它上面调用方法的话就又会回到该方法，从而形成死循环。</p><p>3.2、JDK动态代理只能代理java接口（interface）。</p></li></ol><h2 id="2-4、JDK动态代理在MyBatis中的运用"><a href="#2-4、JDK动态代理在MyBatis中的运用" class="headerlink" title="2.4、JDK动态代理在MyBatis中的运用"></a>2.4、JDK动态代理在MyBatis中的运用</h2><p>我们都知道Mybatis只要一个接口和一个XML Mapper（或注解），就能完成增删改查操作，其实Mybatis也是利用JDK动态代理生成的Mapper实例进行调用，下面直接看源码：</p><img src="/2020/01/05/jdk-proxy/mybatis-1.png" title="mybatis源码-1"><p>这就是生成Mapper实例的代码，其中的<code>mapperInterface</code>就是我们写的Mapper接口，但有一个<code>mapperProxy</code>比较重要，它就是我们说的“万能中介”，看看它是怎么实现的：</p><img src="/2020/01/05/jdk-proxy/mybatis-2.png" title="mybatis源码-2"><p>这个<code>MapperProxy</code>也实现了<code>nvocationHandler</code>接口，但与上面介绍的些许不同，之前的动态代理需要一个接口的实现类，但这里并没有实现类。其实<strong>JDK动态代理并不要求实现类</strong>，在invoke方法内部我们完全可以根据三个参数去“创造”结果，然后返回即可。</p><p>可以看到，Mybatis根据传入的方法“创造”了另一个“方法”<code>MapperMethod</code>，然后去执行这个新“方法”，最终返回结果。这个创造方法的过程就是根据我们之前的Mapper.xml或注解获得SQL语句，然后根据传入的参数构造statement，最后就直接执行了，具体参考Mybatis源码。</p><h2 id="2-5、JDK动态代理底层原理"><a href="#2-5、JDK动态代理底层原理" class="headerlink" title="2.5、JDK动态代理底层原理"></a>2.5、JDK动态代理底层原理</h2><ol><li><p>先看生成的代理类</p><p>1.1、保存代理类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法1</span></span><br><span class="line"><span class="keyword">byte</span>[] bytes = ProxyGenerator.generateProxyClass(<span class="string">"stuMapperProxy"</span>, stuMapper.getClass().getInterfaces());<span class="comment">//获取代理类bytes数组</span></span><br><span class="line">com.google.common.io.Files.write(bytes, <span class="keyword">new</span> File(<span class="string">"proxy$0.class"</span>));<span class="comment">//保存bytes数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//方法2：代码中加入下面一条属性，默认保存的class文件在项目根目录下com/sun/proxy下面</span></span><br><span class="line">System.getProperties().put(<span class="string">"sun.misc.ProxyGenerator.saveGeneratedFiles"</span>, <span class="string">"true"</span>);</span><br></pre></td></tr></table></figure><p>1.2、反编译代理类（以下代码精简掉无关逻辑及异常处理部分）</p><details><summary style="color:blue">点击查看代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">stuMapperProxy</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">StuMapper</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0; <span class="comment">//hashCode</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1; <span class="comment">//equals</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2; <span class="comment">//toString</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3; <span class="comment">//业务方法selectAll</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m4; <span class="comment">//业务方法addStudent</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 代理类继承自Proxy，Proxy中有一个InvocationHandler成员，它就是我们需要实现的那一部分。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">stuMapperProxy</span><span class="params">(InvocationHandler var1)</span> <span class="keyword">throws</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(var1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//equals方法，通过InvocationHandler调用我们的目标对像的equals范方法</span></span><br><span class="line">    <span class="comment">//下面的其他方法同理。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object var1)</span> <span class="keyword">throws</span> </span>&#123;</span><br><span class="line">        <span class="comment">//super.h就是InvocationHandler实例，其中的invoke方法被我们增强过</span></span><br><span class="line">        <span class="comment">//this: 当前代理对象</span></span><br><span class="line">        <span class="comment">//m1: 当前方法</span></span><br><span class="line">        <span class="comment">//m2: 方法参数</span></span><br><span class="line">        <span class="keyword">return</span> (Boolean) <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m1, <span class="keyword">new</span> Object[]&#123;var1&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> <span class="keyword">throws</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (String) <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m2, (Object[]) <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//代理的业务方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> List <span class="title">selectAll</span><span class="params">()</span> <span class="keyword">throws</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (List) <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m3, (Object[]) <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//代理的业务方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addStudent</span><span class="params">(<span class="keyword">int</span> var1, String var2, <span class="keyword">int</span> var3, String var4)</span> <span class="keyword">throws</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m4, <span class="keyword">new</span> Object[]&#123;var1, var2, var3, var4&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> <span class="keyword">throws</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Integer) <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m0, (Object[]) <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//前3个方法&#123;m0,m1,m2&#125;固定为hashCode, equals, toString</span></span><br><span class="line">    <span class="comment">//从后面开始就是我们定义的业务方法</span></span><br><span class="line">    <span class="comment">//这些方法都是通过反射的方式获取到的</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        m0 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"hashCode"</span>);</span><br><span class="line">        m1 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"equals"</span>, Class.forName(<span class="string">"java.lang.Object"</span>));</span><br><span class="line">        m2 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"toString"</span>);</span><br><span class="line">        m3 = Class.forName(<span class="string">"com.sptest.mapper.StuMapper"</span>).getMethod(<span class="string">"selectAll"</span>);</span><br><span class="line">        m4 = Class.forName(<span class="string">"com.sptest.mapper.StuMapper"</span>).getMethod(<span class="string">"addStudent"</span>, Integer.TYPE, Class.forName(<span class="string">"java.lang.String"</span>), Integer.TYPE, Class.forName(<span class="string">"java.lang.String"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>这里注意：生成的代理类已经继承了<code>Proxy</code>类,无法再继承其他类，所以只能实现业务接口，这也就是为什么JDK只能代理接口的原因。</p><p>1.3、代理类调用流程</p><img src="/2020/01/05/jdk-proxy/proxy-call.png" title="代理类调用流程"></li><li><p>代理对象生成过程（省略安全检查及异常处理代码）</p><p>2.1、从<code>newProxyInstance</code>入手</p><details><summary style="color:blue">点击查看代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Class&lt;?&gt;[] intfs = interfaces.clone();</span><br><span class="line">  <span class="comment">//获取代理类[重要]</span></span><br><span class="line">  Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</span><br><span class="line">  <span class="comment">//获取代理类构造方法</span></span><br><span class="line">  <span class="keyword">final</span> Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</span><br><span class="line">  <span class="comment">//通过构造方法创建代理对象并返回</span></span><br><span class="line">  <span class="keyword">return</span> cons.newInstance(<span class="keyword">new</span> Object[]&#123;h&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>2.2、生成代理类</p><details><summary style="color:blue">点击查看代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Class&lt;?&gt; getProxyClass0(ClassLoader loader, Class&lt;?&gt;... interfaces) &#123;</span><br><span class="line">  <span class="keyword">if</span> (interfaces.length &gt; <span class="number">65535</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"interface limit exceeded"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If the proxy class defined by the given loader implementing 如果代理类已经被给定的类加载器加载了</span></span><br><span class="line">  <span class="comment">// the given interfaces exists, this will simply return the cached copy; 并且给定的接口也存在，则直接从缓存中拷贝一份返回即可</span></span><br><span class="line">  <span class="comment">// otherwise, it will create the proxy class via the ProxyClassFactory 否则，就通过ProxyClassFactory创造一个代理类</span></span><br><span class="line">  <span class="keyword">return</span> proxyClassCache.get(loader, interfaces);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个proxyClassCache是通过如下方式初始化的，proxyClassCache仅仅是一个k-v缓存,获取值时如果不存在就从给定的factory创造一个</span></span><br><span class="line"><span class="comment">//给定的factory有KeyFactory，用于获取生成key, ProxyClassFactory用于生成value，也就是代理类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> WeakCache&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt; proxyClassCache = <span class="keyword">new</span> WeakCache&lt;&gt;(<span class="keyword">new</span> KeyFactory(), <span class="keyword">new</span> ProxyClassFactory());</span><br></pre></td></tr></table></figure></details><p>2.3、来到<code>ProxyClassFactory</code></p><details><summary style="color:blue">点击查看代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">private static final class ProxyClassFactory implements BiFunction&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt; &#123;</span><br><span class="line">    <span class="comment">// 生成的代理类名前缀</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String proxyClassNamePrefix = <span class="string">"$Proxy"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 代理类名后缀生成器，其实就是一个递增数字，用AtomicLong实现</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicLong nextUniqueNumber = <span class="keyword">new</span> AtomicLong();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123;</span><br><span class="line">        <span class="comment">//需要代理的接口</span></span><br><span class="line">        Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = <span class="keyword">new</span> IdentityHashMap&lt;&gt;(interfaces.length);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//代理类包名</span></span><br><span class="line">        String proxyPkg = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> accessFlags = Modifier.PUBLIC | Modifier.FINAL;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//省略其他包名生成，策略...</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (proxyPkg == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//使用默认包名 com.sun.proxy package</span></span><br><span class="line">            proxyPkg = ReflectUtil.PROXY_PACKAGE + <span class="string">"."</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//生成类名后缀(数字)，最终就像$Proxy0这样</span></span><br><span class="line">        <span class="keyword">long</span> num = nextUniqueNumber.getAndIncrement();</span><br><span class="line">        String proxyName = proxyPkg + proxyClassNamePrefix + num;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//生成代理类字节码【核心】</span></span><br><span class="line">        <span class="keyword">byte</span>[] proxyClassFile = ProxyGenerator.generateProxyClass(</span><br><span class="line">                proxyName, interfaces, accessFlags);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//装载代理类，返回class对象</span></span><br><span class="line">        <span class="keyword">return</span> defineClass0(loader, proxyName, proxyClassFile, <span class="number">0</span>, proxyClassFile.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><p>2.4、继续探索<code>ProxyGenerator.generateProxyClass</code></p><details><summary style="color:blue">点击查看代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先看看ProxyGenerator都有些什么</span></span><br><span class="line"><span class="comment">//定义了一堆常量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CLASSFILE_MAJOR_VERSION = <span class="number">49</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CLASSFILE_MINOR_VERSION = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONSTANT_UTF8 = <span class="number">1</span>;</span><br><span class="line">...</span><br><span class="line"><span class="comment">//定义了一堆指令</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> opc_iload = <span class="number">21</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> opc_lload = <span class="number">22</span>;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String superclassName = <span class="string">"java/lang/reflect/Proxy"</span>; <span class="comment">//生成的代理类的父类名称</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String handlerFieldName = <span class="string">"h"</span>; <span class="comment">//生成的代理类的父类(Proxy)中InvocationHandler成员的名字(代理类需要使用)</span></span><br><span class="line"><span class="comment">//是否需要保存生成的文件，系统变量设置了 sun.misc.ProxyGenerator.saveGeneratedFiles 为 true 就保存代理类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> saveGeneratedFiles = (Boolean)AccessController.doPrivileged(<span class="keyword">new</span> GetBooleanAction(<span class="string">"sun.misc.ProxyGenerator.saveGeneratedFiles"</span>));</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Method hashCodeMethod; <span class="comment">//生成的代理类的hashCode方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Method equalsMethod; <span class="comment">//生成的代理类的equals方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Method toStringMethod; <span class="comment">//生成的代理类的toString方法</span></span><br><span class="line"><span class="keyword">private</span> String className; <span class="comment">//生成的代理类全类名 如：com.sun.proxy.$Proxy0</span></span><br><span class="line"><span class="keyword">private</span> Class&lt;?&gt;[] interfaces; <span class="comment">//生成的代理类需要实现的接口，就是我们代理的接口</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> accessFlags;<span class="comment">//生成的代理类的访问标志(Modifiers)，一般是17（1+16），1:public, 16:final</span></span><br><span class="line"><span class="keyword">private</span> ProxyGenerator.ConstantPool cp = <span class="keyword">new</span> ProxyGenerator.ConstantPool();<span class="comment">//代理类常量池，一些符号引用等</span></span><br><span class="line"><span class="keyword">private</span> List&lt;ProxyGenerator.FieldInfo&gt; fields = <span class="keyword">new</span> ArrayList();<span class="comment">//生成的代理类的成员变量</span></span><br><span class="line"><span class="keyword">private</span> List&lt;ProxyGenerator.MethodInfo&gt; methods = <span class="keyword">new</span> ArrayList();<span class="comment">//生成的代理类的方法列表（这是新生成的方法）</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, List&lt;ProxyGenerator.ProxyMethod&gt;&gt; proxyMethods = <span class="keyword">new</span> HashMap();<span class="comment">//被代理的方法，方法签名与方法之间的映射（这是目标方法，最终用成员变量表示）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> proxyMethodCount = <span class="number">0</span>;<span class="comment">//代理方法数量（一般是3+业务方法数）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//核心方法：generateProxyClass，注意这个方法是public static 的，我们在其他地方也可以直接使用 </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] generateProxyClass(<span class="keyword">final</span> String className, Class&lt;?&gt;[] interfaces, <span class="keyword">int</span> accessFlags) &#123;</span><br><span class="line">  ProxyGenerator generator = <span class="keyword">new</span> ProxyGenerator(className, interfaces, accessFlags); </span><br><span class="line">  <span class="comment">//生成代理类class文件【核心】</span></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">byte</span>[] classFile = generator.generateClassFile();</span><br><span class="line">  <span class="keyword">if</span> (saveGeneratedFiles) &#123;</span><br><span class="line">   <span class="comment">//保存文件</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> classFile;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//核心方法：generateClassFile</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">byte</span>[] generateClassFile() &#123;</span><br><span class="line">  <span class="comment">//生成proxy代理类的hashcode，equals，toString方法</span></span><br><span class="line">  addProxyMethod(hashCodeMethod, Object.class);</span><br><span class="line">  addProxyMethod(equalsMethod, Object.class);</span><br><span class="line">  addProxyMethod(toStringMethod, Object.class);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//添加各个接口的方法</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; interfaces.length; i++) &#123;</span><br><span class="line">    Method[] methods = interfaces[i].getMethods();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; methods.length; j++) &#123;</span><br><span class="line">      addProxyMethod(methods[j], interfaces[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//检查返回类型</span></span><br><span class="line">  <span class="keyword">for</span> (List&lt;ProxyMethod&gt; sigmethods : proxyMethods.values()) &#123;</span><br><span class="line">    checkReturnTypes(sigmethods);</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//添加生成的构造方法</span></span><br><span class="line">  methods.add(generateConstructor());</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">for</span> (List&lt;ProxyMethod&gt; sigmethods : proxyMethods.values()) &#123;</span><br><span class="line">    <span class="keyword">for</span> (ProxyMethod pm : sigmethods) &#123;</span><br><span class="line">      <span class="comment">//将目标方法放到成员变量中</span></span><br><span class="line">      fields.add(<span class="keyword">new</span> FieldInfo(pm.methodFieldName, <span class="string">"Ljava/lang/reflect/Method;"</span>, ACC_PRIVATE | ACC_STATIC));</span><br><span class="line">      <span class="comment">//新增一个与之对应的方法（签名一致），然后在该方法中调用目标方法</span></span><br><span class="line">      methods.add(pm.generateMethod());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//添加静态初始化块，就是生成代理类中的静态块</span></span><br><span class="line">  methods.add(generateStaticInitializer());</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//构造常量池（cp=constant pool）</span></span><br><span class="line">  cp.getClass(dotToSlash(className));<span class="comment">//dotToSlash点转换为斜线</span></span><br><span class="line">  cp.getClass(superclassName);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; interfaces.length; i++) &#123;</span><br><span class="line">    cp.getClass(dotToSlash(interfaces[i].getName()));</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//常量池设置为只读模式</span></span><br><span class="line">  cp.setReadOnly();</span><br><span class="line">    </span><br><span class="line">  ByteArrayOutputStream bout = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">  DataOutputStream dout = <span class="keyword">new</span> DataOutputStream(bout);</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//以下是class文件的结构，想深入了解的话可以看深入Java虚拟机</span></span><br><span class="line">  <span class="comment">// u4 magic number;</span></span><br><span class="line">  dout.writeInt(<span class="number">0xCAFEBABE</span>);</span><br><span class="line">  <span class="comment">// u2 minor_version;</span></span><br><span class="line">  dout.writeShort(CLASSFILE_MINOR_VERSION);</span><br><span class="line">  <span class="comment">// u2 major_version;</span></span><br><span class="line">  dout.writeShort(CLASSFILE_MAJOR_VERSION);</span><br><span class="line"><span class="comment">// write constant pool</span></span><br><span class="line">  cp.write(dout); </span><br><span class="line">  <span class="comment">// u2 access_flags;</span></span><br><span class="line">  dout.writeShort(ACC_PUBLIC | ACC_FINAL | ACC_SUPER);</span><br><span class="line">  <span class="comment">// u2 this_class;</span></span><br><span class="line">  dout.writeShort(cp.getClass(dotToSlash(className)));</span><br><span class="line">  <span class="comment">// u2 super_class;</span></span><br><span class="line">  dout.writeShort(cp.getClass(superclassName));</span><br><span class="line">  <span class="comment">// u2 interfaces_count;</span></span><br><span class="line">  dout.writeShort(interfaces.length);</span><br><span class="line">  <span class="comment">// u2 interfaces[interfaces_count];</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; interfaces.length; i++) &#123;</span><br><span class="line">    dout.writeShort(cp.getClass(dotToSlash(interfaces[i].getName())));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// u2 fields_count;</span></span><br><span class="line">  dout.writeShort(fields.size());</span><br><span class="line">  <span class="comment">// field_info fields[fields_count];</span></span><br><span class="line">  <span class="keyword">for</span> (FieldInfo f : fields) &#123;</span><br><span class="line">    f.write(dout);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// u2 methods_count;</span></span><br><span class="line">  dout.writeShort(methods.size());</span><br><span class="line">  <span class="comment">// method_info methods[methods_count];</span></span><br><span class="line">  <span class="keyword">for</span> (MethodInfo m : methods) &#123;</span><br><span class="line">    m.write(dout);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// u2 attributes_count;</span></span><br><span class="line">  dout.writeShort(<span class="number">0</span>); <span class="comment">// (no ClassFile attributes for proxy classes)</span></span><br><span class="line">  <span class="keyword">return</span> bout.toByteArray();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></li></ol><p>   ```</p>]]></content>
    
    <summary type="html">
    
      Proxy is a structural design pattern that provides an object that acts as a substitute for a real service object used by a client. A proxy receives client requests, does some work (access control, caching, etc.) and then passes the request to a service object.
    
    </summary>
    
      <category term="Java" scheme="https://blog.zjee.ml/categories/Java/"/>
    
    
      <category term="Java" scheme="https://blog.zjee.ml/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java日志体系</title>
    <link href="https://blog.zjee.ml/2020/01/05/java-log-system/"/>
    <id>https://blog.zjee.ml/2020/01/05/java-log-system/</id>
    <published>2020-01-05T03:38:44.000Z</published>
    <updated>2020-01-05T03:38:44.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、相关概念、"><a href="#一、相关概念、" class="headerlink" title="一、相关概念、"></a>一、相关概念、</h1><h3 id="1-1、-日志门面"><a href="#1-1、-日志门面" class="headerlink" title="1.1、 日志门面"></a>1.1、 日志门面</h3><p><strong>日志门面</strong>是一个对外的、统一的日志”接口“，它不是具体的日志实现，它需要和log4j、logback这样的实现框架配合使用。现在最流行的日志门面是slf4j，按照官方的说法，slf4j是一个用于日志系统的简单Facade，允许最终用户在部署其应用时使用其所希望的日志系统。</p><p><strong>问：</strong>为什么要使用日志门面？直接调用log4j等实现框架的API不行吗？</p><p><strong>答：</strong>直接调用实现框架的API当然可以，但如果未来某一天有比log4j性能更好的实现框架，那升级替换可就是个大工程了。另外，如果现有工程依赖了两个模块，两个模块分别用不同的日志实现方案，那现有工程就需要维护两套日志配置。但有了<strong>日志门面</strong>后一切都变了，我们仅需要引入一种实现，也只需要维护这一种实现的配置文件，其他的实现全部<strong>桥接</strong>到门面即可，往后如果需要升级日志实现，也只需要升级一个jar包、一个配置文件即可。</p><h3 id="1-2、桥接器"><a href="#1-2、桥接器" class="headerlink" title="1.2、桥接器"></a>1.2、桥接器</h3><p>我们在开发中当然可以只使用一种日志实现方案，但引用的第三方依赖可就不一定了，为了统一日志配置，我们需要将第三方依赖的日志实现”引流”到我们自己的日志框架上，这个”引流“的功能就叫做桥接器。</p><h3 id="1-3、日志实现"><a href="#1-3、日志实现" class="headerlink" title="1.3、日志实现"></a>1.3、日志实现</h3><p>日志实现就是真正打日志干活的部分，Java中日志实现太多了，常见的有log4j、log4j2、jcl、logback等。</p><h1 id="二、各种Jar包及功能一览"><a href="#二、各种Jar包及功能一览" class="headerlink" title="二、各种Jar包及功能一览"></a>二、各种Jar包及功能一览</h1><table><thead><tr><th align="left"><strong>jar包</strong></th><th align="center"><strong>类型</strong></th><th align="center"><strong>转换方向</strong></th><th align="left"><strong>描述</strong></th><th><strong>注意事项</strong></th></tr></thead><tbody><tr><td align="left">jcl-over-slf4j</td><td align="center">桥接包</td><td align="center">jcl -&gt; slf4j</td><td align="left">将Jakarta Commons Logging日志框架桥接到slf4j</td><td></td></tr><tr><td align="left">jul-to-slf4j</td><td align="center">桥接包</td><td align="center">juc -&gt; slf4j</td><td align="left">将java.util.logging的日志桥接到slf4j</td><td></td></tr><tr><td align="left">osgi-over-slf4j</td><td align="center">桥接包</td><td align="center">osgi -&gt; slf4j</td><td align="left">将osgi环境下的日志桥接到slf4j</td><td></td></tr><tr><td align="left">slf4j-android</td><td align="center">桥接包</td><td align="center">android -&gt; slf4j</td><td align="left">将android环境下的日志桥接到slf4j</td><td></td></tr><tr><td align="left">log4j-over-slf4j</td><td align="center">桥接包</td><td align="center">log4j -&gt; slf4j</td><td align="left">将log4j的日志桥接到slf4j</td><td>不能和slf4j-log4j12同时用</td></tr><tr><td align="left">log4j-to-slf4j</td><td align="center">桥接包</td><td align="center">log4j2 -&gt; slf4j</td><td align="left">将log4j2的日志桥接到slf4j</td><td>不能和log4j-slf4j-impl同时用</td></tr><tr><td align="left">slf4j-api</td><td align="center">slf4j门面</td><td align="center"></td><td align="left">slf4j的api接口jar包</td><td></td></tr><tr><td align="left">slf4j-ext</td><td align="center">slf4j门面</td><td align="center"></td><td align="left">slf4j扩展功能jar包</td><td></td></tr><tr><td align="left">log4j-api</td><td align="center">实现包</td><td align="center"></td><td align="left">log4j2的api接口jar包</td><td></td></tr><tr><td align="left">log4j-core</td><td align="center">实现包</td><td align="center"></td><td align="left">log4j2的日志输出核心jar包</td><td></td></tr><tr><td align="left">log4j</td><td align="center">实现包</td><td align="center"></td><td align="left">log4j实现包（1.2）</td><td></td></tr><tr><td align="left">slf4j-migrator</td><td align="center">实现包</td><td align="center"></td><td align="left">一个GUI工具，支持将代码中其他日志API转换为slf4j的写法</td><td></td></tr><tr><td align="left">slf4j-jcl</td><td align="center">slf4j+jcl打包</td><td align="center">slf4j -&gt; jcl</td><td align="left">slf4j采用Jakarta Commons Logging日志框架实现</td><td></td></tr><tr><td align="left">slf4j-jdk14</td><td align="center">slf4j+jul打包</td><td align="center">slf4j -&gt; jul</td><td align="left">slf4j采用java.util.logging实现</td><td>不能和jul-to-slf4j同时用</td></tr><tr><td align="left">slf4j-log4j12</td><td align="center">slf4j+log4j12打包</td><td align="center">slf4j -&gt; log4j</td><td align="left">slf4j采用log4j实现（12表示1.2版本）</td><td>不能和log4j-over-slf4j同时用</td></tr><tr><td align="left">log4j-slf4j-impl</td><td align="center">slf4j+log4j2打包</td><td align="center">slf4j -&gt; log4j2</td><td align="left">slf4j采用log4j2实现</td><td>不能和log4j-to-slf4j同时用</td></tr><tr><td align="left">slf4j-nop</td><td align="center">slf4j+无输出打包</td><td align="center">slf4j -&gt; null</td><td align="left">slf4j的空接口输出绑定，丢弃所有日志输出</td><td></td></tr><tr><td align="left">slf4j-simple</td><td align="center">sl4j+简单实现打包</td><td align="center">slf4j -&gt; slf4j-simple</td><td align="left">slf4j的自带的简单日志输出实现</td><td></td></tr><tr><td align="left">logback-classic</td><td align="center">slf4j+logback打包</td><td align="center">slf4j -&gt; logback</td><td align="left">slf4j采用logback实现</td><td></td></tr><tr><td align="left">logback-core</td><td align="center"></td><td align="center"></td><td align="left">logback核心依赖</td><td></td></tr><tr><td align="left">logback-access</td><td align="center"></td><td align="center"></td><td align="left">与servlet容器集成，提供通过http访问日志功能</td><td></td></tr><tr><td align="left">log4j-1.2-api</td><td align="center">log4j桥接到log4j2</td><td align="center">log4j -&gt; log4j2</td><td align="left">将log4j的日志转接到log4j2日志框架</td><td></td></tr></tbody></table><h1 id="三、常见使用搭配"><a href="#三、常见使用搭配" class="headerlink" title="三、常见使用搭配"></a>三、常见使用搭配</h1><ol><li><strong>slf4j + log4j（已过时）</strong>：引入<code>slf4j-log4j12</code>即可，另外可根据需求加入桥接包，不可与<code>log4j-over-slf4j</code>同时使用，会引发<code>StackOverflowError</code>异常。</li><li><strong>slf4j + log4j2（流行）</strong>：引入<code>log4j-slf4j-impl</code>即可，另外可根据需求加入桥接包，不可与<code>log4j-to-slf4j</code>同时使用，会引发<code>StackOverflowError</code>异常。</li><li><strong>slf4j + logback（最优）</strong>：引入 <code>logback-classic</code>即可，另外可根据需求加入桥接包。logback与slf4j是同一人开发，兼容性很好，springboot默认就采用logback方案。</li></ol><p>其他的使用方式有log4j、log4j2、jul等单独使用的，这里强烈不推荐，请按<a href="https://yq.aliyun.com/articles/69327?utm_content=m_10088" target="_blank" rel="noopener">阿里巴巴Java代码规范</a>中【日志规约】编码。</p><h1 id="四、常见问题"><a href="#四、常见问题" class="headerlink" title="四、常见问题"></a>四、常见问题</h1><ol><li><p><strong>找到多个slf4j实现(Class path contains multiple SLF4J bindings.)</strong></p><img src="/2020/01/05/java-log-system/mult-bindings.png" title="mult-bindings"><p>这种情况是上面的<code>slf4j+xxx打包</code>这样的jar包引入了两类导致的，我们根据需要保留一类，排除其他的就可以了。</p></li><li><p><strong>jar包不能共存，或者直接报<code>StackOverflowError</code>异常</strong></p><img src="/2020/01/05/java-log-system/stackOverflow.png" title="stackOverflowError"><p>这种情况大多数原因是实现包与实现包对应的桥接包同时引入了，打印日志的时候就会发生死循环方法调用，一直到栈溢出，实现比较好的包如<code>log4j-slf4j-impl</code>，会在启动时告诉你两者不能共存。总的来说，<strong>实现和桥接只能选一个</strong>。</p></li><li><p><strong>其他异常情况大多数是由版本不兼容导致的，请参考<a href="http://www.slf4j.org/codes.html" target="_blank" rel="noopener">slf4j错误含义及解决方法</a>。</strong></p></li><li><p><strong>log4j(也称log4j12)与log4j2的区别：<a href="https://www.cnblogs.com/WangBoBlog/p/7841217.html" target="_blank" rel="noopener">Log4j与Log4j2的区别</a>。</strong></p></li></ol><h1 id="五、常见日志配置"><a href="#五、常见日志配置" class="headerlink" title="五、常见日志配置"></a>五、常见日志配置</h1><h3 id="5-1-log4j配置"><a href="#5-1-log4j配置" class="headerlink" title="5.1 log4j配置"></a>5.1 log4j配置</h3><ol><li><p>基于XML的配置</p><details><summary style="color:blue">点击展开代码</summary>    <a href="https://blog.csdn.net/manmanxiaohui/article/details/79922546" target="_blank">参考文档</a><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>  </span><br><span class="line"><span class="meta">&lt;!DOCTYPE log4j:configuration SYSTEM "log4j.dtd"&gt;</span>  </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">log4j:configuration</span>  <span class="attr">debug</span>=<span class="string">"true"</span> <span class="attr">xmlns:log4j</span>=<span class="string">'http://jakarta.apache.org/log4j/'</span> &gt;</span>  </span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- ========================== 自定义输出格式说明======================== --&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- %p 输出优先级，即DEBUG，INFO，WARN，ERROR，FATAL --&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- %r 输出自应用启动到输出该log信息耗费的毫秒数  --&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- %c 输出所属的类目，通常就是所在类的全名 --&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- %t 输出产生该日志事件的线程名 --&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- %n 输出一个回车换行符，Windows平台为“/r/n”，Unix平台为“/n” --&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- %d 输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，比如：%d&#123;yyy MMM dd HH:mm:ss,SSS&#125;，输出类似：2002年10月18日 22：10：28，921  --&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- %l 输出日志事件的发生位置，包括类目名、发生的线程，以及在代码中的行数。举例：Testlo4.main(TestLog4.java:10)  --&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- ============================================================== --&gt;</span></span><br><span class="line">     </span><br><span class="line">      <span class="comment">&lt;!-- ========================== 输出方式说明========================= --&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- Log4j提供的appender有以下几种:  --&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- org.apache.log4j.ConsoleAppender(控制台),  --&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- org.apache.log4j.FileAppender(文件),  --&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- org.apache.log4j.DailyRollingFileAppender(每天产生一个日志文件), --&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- org.apache.log4j.RollingFileAppender(文件大小到达指定尺寸的时候产生一个新的文件),  --&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- org.apache.log4j.WriterAppender(将日志信息以流格式发送到任意指定的地方)   --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- ================================================================== --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"CONSOLE"</span> <span class="attr">class</span>=<span class="string">"org.apache.log4j.ConsoleAppender"</span>&gt;</span></span><br><span class="line">         <span class="comment">&lt;!-- &lt;param name="Target" value="System.out"/&gt; --&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">layout</span> <span class="attr">class</span>=<span class="string">"org.apache.log4j.PatternLayout"</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"ConversionPattern"</span> <span class="attr">value</span>=<span class="string">"%d&#123;yyyy-MM-dd HH:mm:ss a&#125; [Thread: %t][ Class:%c  Method: %l ]%n%p:%m%n"</span>/&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--  &lt;filter class="org.apache.log4j.varia.LevelRangeFilter"&gt;</span></span><br><span class="line"><span class="comment">            &lt;param name="LevelMin" value="DEBUG"/&gt;</span></span><br><span class="line"><span class="comment">            &lt;param name="LevelMax" value="DEBUG"/&gt;</span></span><br><span class="line"><span class="comment">        &lt;/filter&gt; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- output the debug   --&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--  &lt;appender name="log4jDebug" class="org.apache.log4j.DailyRollingFileAppender"&gt;</span></span><br><span class="line"><span class="comment">        &lt;param name="File" value="log_"/&gt;    </span></span><br><span class="line"><span class="comment">        &lt;param name="MaxFileSize" value="KB"/&gt; </span></span><br><span class="line"><span class="comment">        &lt;param name="MaxBackupIndex" value="2"/&gt; --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"log4jDebug"</span>  <span class="attr">class</span>=<span class="string">"org.apache.log4j.rolling.RollingFileAppender"</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"Append"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span>  <span class="attr">class</span>=<span class="string">"org.apache.log4j.rolling.TimeBasedRollingPolicy"</span>&gt;</span>  </span><br><span class="line">               <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"FileNamePattern"</span> <span class="attr">value</span>=<span class="string">"./log/log_%d&#123;yyyy-MM-dd&#125;.log"</span> /&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">layout</span> <span class="attr">class</span>=<span class="string">"org.apache.log4j.PatternLayout"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"ConversionPattern"</span> <span class="attr">value</span>=<span class="string">"%d&#123;yyyy-MM-dd HH:mm:ss a&#125; [Thread: %t][ Class:%c Method: %l ]%n%p:%m%n"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"org.apache.log4j.varia.LevelRangeFilter"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"LevelMin"</span> <span class="attr">value</span>=<span class="string">"DEBUG"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"LevelMax"</span> <span class="attr">value</span>=<span class="string">"DEBUG"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--  &lt;appender name="log4jInfo" class="org.apache.log4j.DailyRollingFileAppender"&gt;</span></span><br><span class="line"><span class="comment">        &lt;param name="File" value="log_"/&gt;       </span></span><br><span class="line"><span class="comment">        &lt;param name="DatePattern" value="'.log'yyyy-MM-dd"/&gt;</span></span><br><span class="line"><span class="comment">        &lt;param name="Append" value="true"/&gt;</span></span><br><span class="line"><span class="comment">       &lt;param name="MaxFileSize" value="5KB"/&gt;</span></span><br><span class="line"><span class="comment">        &lt;param name="MaxBackupIndex" value="2"/&gt; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"log4jInfo"</span>  <span class="attr">class</span>=<span class="string">"org.apache.log4j.rolling.RollingFileAppender"</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"Append"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span>  <span class="attr">class</span>=<span class="string">"org.apache.log4j.rolling.TimeBasedRollingPolicy"</span>&gt;</span>  </span><br><span class="line">               <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"FileNamePattern"</span> <span class="attr">value</span>=<span class="string">"./log/log_%d&#123;yyyy-MM-dd&#125;.log"</span> /&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">layout</span> <span class="attr">class</span>=<span class="string">"org.apache.log4j.PatternLayout"</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"ConversionPattern"</span> <span class="attr">value</span>=<span class="string">"%d&#123;yyyy-MM-dd HH:mm:ss a&#125; [Thread: %t][ Class:%c  Method: %l ]%n%p:%m%n"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"org.apache.log4j.varia.LevelRangeFilter"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"LevelMin"</span> <span class="attr">value</span>=<span class="string">"INFO"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"LevelMax"</span> <span class="attr">value</span>=<span class="string">"INFO"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--  &lt;appender name="log4jWarn" class="org.apache.log4j.DailyRollingFileAppender"&gt;</span></span><br><span class="line"><span class="comment">        &lt;param name="File" value="/log_"/&gt;      </span></span><br><span class="line"><span class="comment">        &lt;param name="DatePattern" value="'.log'yyyy-MM-dd"/&gt;</span></span><br><span class="line"><span class="comment">        &lt;param name="Append" value="true"/&gt;</span></span><br><span class="line"><span class="comment">        &lt;param name="MaxFileSize" value="5KB"/&gt;</span></span><br><span class="line"><span class="comment">        &lt;param name="MaxBackupIndex" value="2"/&gt; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"log4jWarn"</span> <span class="attr">class</span>=<span class="string">"org.apache.log4j.rolling.RollingFileAppender"</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"Append"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span>  <span class="attr">class</span>=<span class="string">"org.apache.log4j.rolling.TimeBasedRollingPolicy"</span>&gt;</span>  </span><br><span class="line">               <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"FileNamePattern"</span> <span class="attr">value</span>=<span class="string">"./log/log_%d&#123;yyyy-MM-dd&#125;.log"</span> /&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">layout</span> <span class="attr">class</span>=<span class="string">"org.apache.log4j.PatternLayout"</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"ConversionPattern"</span> <span class="attr">value</span>=<span class="string">"%d&#123;yyyy-MM-dd HH:mm:ss a&#125; [Thread: %t][ Class:%c Method: %l ]%n%p:%m%n"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"org.apache.log4j.varia.LevelRangeFilter"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"LevelMin"</span> <span class="attr">value</span>=<span class="string">"WARN"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"LevelMax"</span> <span class="attr">value</span>=<span class="string">"WARN"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--  &lt;appender name="log4jError" class="org.apache.log4j.DailyRollingFileAppender"&gt; --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"log4jError"</span>  <span class="attr">class</span>=<span class="string">"org.apache.log4j.rolling.RollingFileAppender"</span>&gt;</span>  </span><br><span class="line">       <span class="comment">&lt;!--  &lt;param name="File" value="/error_"/&gt;    </span></span><br><span class="line"><span class="comment">        &lt;param name="DatePattern" value="'.log'yyyy-MM-dd"/&gt; --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"Append"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span>  <span class="attr">class</span>=<span class="string">"org.apache.log4j.rolling.TimeBasedRollingPolicy"</span>&gt;</span>  </span><br><span class="line">               <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"FileNamePattern"</span> <span class="attr">value</span>=<span class="string">"./log/error_%d&#123;yyyy-MM-dd&#125;.log"</span> /&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span> </span><br><span class="line">        </span><br><span class="line">      <span class="comment">&lt;!--   &lt;param name="MaxFileSize" value="5KB"/&gt; --&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--   &lt;param name="MaxBackupIndex" value="2"/&gt; --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">layout</span> <span class="attr">class</span>=<span class="string">"org.apache.log4j.PatternLayout"</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"ConversionPattern"</span> <span class="attr">value</span>=<span class="string">"%d&#123;yyyy-MM-dd HH:mm:ss a&#125; [Thread: %t][ Class:%c Method: %l ]%n%p:%m%n"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"org.apache.log4j.varia.LevelRangeFilter"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"LevelMin"</span> <span class="attr">value</span>=<span class="string">"ERROR"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"LevelMax"</span> <span class="attr">value</span>=<span class="string">"ERROR"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--通过&lt;category&gt;&lt;/category&gt;的定义可以将各个包中的类日志输出到不同的日志文件中--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--     &lt;category name="com.gzy"&gt;</span></span><br><span class="line"><span class="comment">            &lt;priority value="debug" /&gt;</span></span><br><span class="line"><span class="comment">            &lt;appender-ref ref="log4jTestLogInfo" /&gt;</span></span><br><span class="line"><span class="comment">            &lt;appender-ref ref="log4jTestDebug" /&gt;</span></span><br><span class="line"><span class="comment">        &lt;/category&gt; --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"MAIL"</span>     </span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">"org.apache.log4j.net.SMTPAppender"</span>&gt;</span>     </span><br><span class="line">      <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"threshold"</span> <span class="attr">value</span>=<span class="string">"debug"</span> /&gt;</span>     </span><br><span class="line">      <span class="comment">&lt;!-- 日志的错误级别     </span></span><br><span class="line"><span class="comment">       &lt;param name="threshold" value="error"/&gt;     </span></span><br><span class="line"><span class="comment">      --&gt;</span>     </span><br><span class="line">      <span class="comment">&lt;!-- 缓存文件大小，日志达到512K时发送Email --&gt;</span>     </span><br><span class="line">      <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"BufferSize"</span> <span class="attr">value</span>=<span class="string">"512"</span> /&gt;</span><span class="comment">&lt;!-- 单位K --&gt;</span>     </span><br><span class="line">      <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"From"</span> <span class="attr">value</span>=<span class="string">"test@163.com"</span> /&gt;</span>     </span><br><span class="line">      <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"SMTPHost"</span> <span class="attr">value</span>=<span class="string">"smtp.163.com"</span> /&gt;</span>     </span><br><span class="line">      <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"Subject"</span> <span class="attr">value</span>=<span class="string">"juyee-log4jMessage"</span> /&gt;</span>     </span><br><span class="line">      <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"To"</span> <span class="attr">value</span>=<span class="string">"test@163.com"</span> /&gt;</span>     </span><br><span class="line">      <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"SMTPUsername"</span> <span class="attr">value</span>=<span class="string">"test"</span> /&gt;</span>     </span><br><span class="line">      <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"SMTPPassword"</span> <span class="attr">value</span>=<span class="string">"test"</span> /&gt;</span>     </span><br><span class="line">      <span class="tag">&lt;<span class="name">layout</span> <span class="attr">class</span>=<span class="string">"org.apache.log4j.PatternLayout"</span>&gt;</span>     </span><br><span class="line">       <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"ConversionPattern"</span>     </span></span><br><span class="line"><span class="tag">        <span class="attr">value</span>=<span class="string">"%-d&#123;yyyy-MM-dd HH:mm:ss.SSS a&#125; [%p]-[%c] %m%n"</span> /&gt;</span>     </span><br><span class="line">      <span class="tag">&lt;/<span class="name">layout</span>&gt;</span>     </span><br><span class="line">   <span class="tag">&lt;/<span class="name">appender</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">     <span class="tag">&lt;<span class="name">root</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">priority</span> <span class="attr">value</span>=<span class="string">"debug"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"CONSOLE"</span> /&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"log4jDebug"</span> /&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"log4jInfo"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"log4jWarn"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"log4jError"</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;appender-ref ref="MAIL" /&gt; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">log4j:configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></details></li><li><p>基于properties文件的配置</p><details><summary style="color:blue">点击展开代码</summary><a href="https://blog.csdn.net/manmanxiaohui/article/details/79922546" target="_blank">参考文档</a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"># priority  :debug&lt;info&lt;warn&lt;error</span><br><span class="line">#you cannot specify every priority with different file for log4j </span><br><span class="line">log4j.rootLogger=debug,stdout,info,debug,warn,error </span><br><span class="line"></span><br><span class="line">#console</span><br><span class="line">log4j.appender.stdout=org.apache.log4j.ConsoleAppender </span><br><span class="line">log4j.appender.stdout.layout=org.apache.log4j.PatternLayout </span><br><span class="line">log4j.appender.stdout.layout.ConversionPattern= [%d&#123;yyyy-MM-dd HH:mm:ss a&#125;]:%p %l%m%n</span><br><span class="line">#info log</span><br><span class="line">log4j.logger.info=info</span><br><span class="line">log4j.appender.info=org.apache.log4j.DailyRollingFileAppender </span><br><span class="line">log4j.appender.info.DatePattern=&apos;_&apos;yyyy-MM-dd&apos;.log&apos;</span><br><span class="line">log4j.appender.info.File=./src/com/hp/log/info.log</span><br><span class="line">log4j.appender.info.Append=true</span><br><span class="line">log4j.appender.info.Threshold=INFO</span><br><span class="line">log4j.appender.info.layout=org.apache.log4j.PatternLayout </span><br><span class="line">log4j.appender.info.layout.ConversionPattern=%d&#123;yyyy-MM-dd HH:mm:ss a&#125; [Thread: %t][ Class:%c &gt;&gt; Method: %l ]%n%p:%m%n</span><br><span class="line">#debug log</span><br><span class="line">log4j.logger.debug=debug</span><br><span class="line">log4j.appender.debug=org.apache.log4j.DailyRollingFileAppender </span><br><span class="line">log4j.appender.debug.DatePattern=&apos;_&apos;yyyy-MM-dd&apos;.log&apos;</span><br><span class="line">log4j.appender.debug.File=./src/com/hp/log/debug.log</span><br><span class="line">log4j.appender.debug.Append=true</span><br><span class="line">log4j.appender.debug.Threshold=DEBUG</span><br><span class="line">log4j.appender.debug.layout=org.apache.log4j.PatternLayout </span><br><span class="line">log4j.appender.debug.layout.ConversionPattern=%d&#123;yyyy-MM-dd HH:mm:ss a&#125; [Thread: %t][ Class:%c &gt;&gt; Method: %l ]%n%p:%m%n</span><br><span class="line">#warn log</span><br><span class="line">log4j.logger.warn=warn</span><br><span class="line">log4j.appender.warn=org.apache.log4j.DailyRollingFileAppender </span><br><span class="line">log4j.appender.warn.DatePattern=&apos;_&apos;yyyy-MM-dd&apos;.log&apos;</span><br><span class="line">log4j.appender.warn.File=./src/com/hp/log/warn.log</span><br><span class="line">log4j.appender.warn.Append=true</span><br><span class="line">log4j.appender.warn.Threshold=WARN</span><br><span class="line">log4j.appender.warn.layout=org.apache.log4j.PatternLayout </span><br><span class="line">log4j.appender.warn.layout.ConversionPattern=%d&#123;yyyy-MM-dd HH:mm:ss a&#125; [Thread: %t][ Class:%c &gt;&gt; Method: %l ]%n%p:%m%n</span><br><span class="line">#error</span><br><span class="line">log4j.logger.error=error</span><br><span class="line">log4j.appender.error = org.apache.log4j.DailyRollingFileAppender</span><br><span class="line">log4j.appender.error.DatePattern=&apos;_&apos;yyyy-MM-dd&apos;.log&apos;</span><br><span class="line">log4j.appender.error.File = ./src/com/hp/log/error.log </span><br><span class="line">log4j.appender.error.Append = true</span><br><span class="line">log4j.appender.error.Threshold = ERROR </span><br><span class="line">log4j.appender.error.layout = org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.error.layout.ConversionPattern = %d&#123;yyyy-MM-dd HH:mm:ss a&#125; [Thread: %t][ Class:%c &gt;&gt; Method: %l ]%n%p:%m%n</span><br></pre></td></tr></table></figure></details></li></ol><h3 id="5-2-log4j2配置"><a href="#5-2-log4j2配置" class="headerlink" title="5.2 log4j2配置"></a>5.2 log4j2配置</h3><details><summary style="color:blue">点击展开代码</summary><a href="https://www.cnblogs.com/WangBoBlog/p/7841217.html" target="_blank">参考文档</a><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span> <span class="attr">status</span>=<span class="string">"error"</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!--  先定义所有的appender --&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">appenders</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!--   这个输出控制台的配置 --&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">Console</span> <span class="attr">name</span>=<span class="string">"Console"</span> <span class="attr">target</span>=<span class="string">"SYSTEM_OUT"</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!--    控制台只输出level及以上级别的信息（onMatch），其他的直接拒绝（onMismatch） --&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">ThresholdFilter</span> <span class="attr">level</span>=<span class="string">"trace"</span> <span class="attr">onMatch</span>=<span class="string">"ACCEPT"</span> <span class="attr">onMismatch</span>=<span class="string">"DENY"</span>/&gt;</span> </span><br><span class="line"><span class="comment">&lt;!--    这个都知道是输出日志的格式 --&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">"%d&#123;HH:mm:ss.SSS&#125; %-5level %class&#123;36&#125; %L %M - %msg%xEx%n"</span>/&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">Console</span>&gt;</span> </span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!--   文件会打印出所有信息，这个log每次运行程序会自动清空，由append属性决定，这个也挺有用的，适合临时测试用 --&gt;</span> </span><br><span class="line"><span class="comment">&lt;!--   append为TRUE表示消息增加到指定文件中，false表示消息覆盖指定的文件内容，默认值是true --&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">File</span> <span class="attr">name</span>=<span class="string">"log"</span> <span class="attr">fileName</span>=<span class="string">"log/test.log"</span> <span class="attr">append</span>=<span class="string">"false"</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">"%d&#123;HH:mm:ss.SSS&#125; %-5level %class&#123;36&#125; %L %M - %msg%xEx%n"</span>/&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">File</span>&gt;</span> </span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!--   添加过滤器ThresholdFilter,可以有选择的输出某个级别以上的类别 onMatch="ACCEPT" onMismatch="DENY"意思是匹配就接受,否则直接拒绝 --&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">File</span> <span class="attr">name</span>=<span class="string">"ERROR"</span> <span class="attr">fileName</span>=<span class="string">"logs/error.log"</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">ThresholdFilter</span> <span class="attr">level</span>=<span class="string">"error"</span> <span class="attr">onMatch</span>=<span class="string">"ACCEPT"</span> <span class="attr">onMismatch</span>=<span class="string">"DENY"</span>/&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">"%d&#123;yyyy.MM.dd 'at' HH:mm:ss z&#125; %-5level %class&#123;36&#125; %L %M - %msg%xEx%n"</span>/&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">File</span>&gt;</span> </span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!--   这个会打印出所有的信息，每次大小超过size，则这size大小的日志会自动存入按年份-月份建立的文件夹下面并进行压缩，作为存档 --&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">RollingFile</span> <span class="attr">name</span>=<span class="string">"RollingFile"</span> <span class="attr">fileName</span>=<span class="string">"logs/web.log"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">filePattern</span>=<span class="string">"logs/$$&#123;date:yyyy-MM&#125;/web-%d&#123;MM-dd-yyyy&#125;-%i.log.gz"</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">"%d&#123;yyyy-MM-dd 'at' HH:mm:ss z&#125; %-5level %class&#123;36&#125; %L %M - %msg%xEx%n"</span>/&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">SizeBasedTriggeringPolicy</span> <span class="attr">size</span>=<span class="string">"2MB"</span>/&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">RollingFile</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;/<span class="name">appenders</span>&gt;</span> </span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!--  然后定义logger，只有定义了logger并引入的appender，appender才会生效 --&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">loggers</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!--   建立一个默认的root的logger --&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"trace"</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"RollingFile"</span>/&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"Console"</span>/&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"ERROR"</span> /&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"log"</span>/&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">root</span>&gt;</span> </span><br><span class="line"> </span><br><span class="line"> <span class="tag">&lt;/<span class="name">loggers</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></details><h3 id="5-3-logback配置"><a href="#5-3-logback配置" class="headerlink" title="5.3 logback配置"></a>5.3 logback配置</h3><details><summary style="color:blue">点击展开代码</summary><a href="https://www.jianshu.com/p/04065d8cb2a9" target="_blank">参考文档</a><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span> <span class="attr">debug</span>=<span class="string">"true"</span> <span class="attr">scan</span>=<span class="string">"true"</span> <span class="attr">scanPeriod</span>=<span class="string">"1 seconds"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">contextName</span>&gt;</span>logback<span class="tag">&lt;/<span class="name">contextName</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--定义参数,后面可以通过$&#123;app.name&#125;使用--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"app.name"</span> <span class="attr">value</span>=<span class="string">"logback_test"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--ConsoleAppender 用于在屏幕上输出日志--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"stdout"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--定义了一个过滤器,在LEVEL之下的日志输出不会被打印出来--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--这里定义了DEBUG，也就是控制台不会输出比ERROR级别小的日志--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.filter.ThresholdFilter"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">level</span>&gt;</span>DEBUG<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- encoder 默认配置为PatternLayoutEncoder --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--定义控制台输出格式--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d [%thread] %-5level %logger&#123;36&#125; [%file : %line] - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"file"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--定义日志输出的路径--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--这里的scheduler.manager.server.home 没有在上面的配置中设定，所以会使用java启动时配置的值--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--比如通过 java -Dscheduler.manager.server.home=/path/to XXXX 配置该属性--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">file</span>&gt;</span>$&#123;scheduler.manager.server.home&#125;/logs/$&#123;app.name&#125;.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--定义日志滚动的策略--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--定义文件滚动时的文件名的格式--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>$&#123;scheduler.manager.server.home&#125;/logs/$&#123;app.name&#125;.%d&#123;yyyy-MM-dd.HH&#125;.log.gz</span><br><span class="line">            <span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--60天的时间周期，日志量最大20GB--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>60<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 该属性在 1.1.6版本后 才开始支持--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">totalSizeCap</span>&gt;</span>20GB<span class="tag">&lt;/<span class="name">totalSizeCap</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">triggeringPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--每个日志文件最大100MB--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxFileSize</span>&gt;</span>100MB<span class="tag">&lt;/<span class="name">maxFileSize</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">triggeringPolicy</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--定义输出格式--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d [%thread] %-5level %logger&#123;36&#125; [%file : %line] - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--root是默认的logger 这里设定输出级别是debug--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"trace"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--定义了两个appender，日志会通过往这两个appender里面写--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"stdout"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"file"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--对于类路径以 com.example.logback 开头的Logger,输出级别设置为warn,并且只输出到控制台--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--这个logger没有指定appender，它会继承root节点中定义的那些appender--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"com.example.logback"</span> <span class="attr">level</span>=<span class="string">"warn"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--通过 LoggerFactory.getLogger("mytest") 可以获取到这个logger--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--由于这个logger自动继承了root的appender，root中已经有stdout的appender了，自己这边又引入了stdout的appender--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--如果没有设置 additivity="false" ,就会导致一条日志在控制台输出两次的情况--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--additivity表示要不要使用rootLogger配置的appender进行输出--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"mytest"</span> <span class="attr">level</span>=<span class="string">"info"</span> <span class="attr">additivity</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"stdout"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--由于设置了 additivity="false" ，所以输出时不会使用rootLogger的appender--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--但是这个logger本身又没有配置appender，所以使用这个logger输出日志的话就不会输出到任何地方--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"mytest2"</span> <span class="attr">level</span>=<span class="string">"info"</span> <span class="attr">additivity</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></details><p>附录：<a href="/2020/01/05/java-log-system/Alibaba-java-coding-guidelines.pdf">阿里巴巴Java代码规范手册</a></p>]]></content>
    
    <summary type="html">
    
      Java中各种日志层出不穷，都曾想一统天下，最落得个鱼龙混杂，受苦的还是我们这些程序员。这篇文章不讲日志的设计与实现，只说说日常开发中如何使用，如何统一，排除日志冲突，统一日志配置。PS：本文只讨论常规的Java开发场景，不深入讨论J2ME、Android等开发框架。附阿里巴巴Java代码规范手册。
    
    </summary>
    
      <category term="Java" scheme="https://blog.zjee.ml/categories/Java/"/>
    
    
      <category term="Java" scheme="https://blog.zjee.ml/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>HashMap源码完全解读</title>
    <link href="https://blog.zjee.ml/2019/12/29/hashmap-source-learning/"/>
    <id>https://blog.zjee.ml/2019/12/29/hashmap-source-learning/</id>
    <published>2019-12-29T09:31:19.000Z</published>
    <updated>2019-12-29T09:31:19.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、HashMap基础"><a href="#一、HashMap基础" class="headerlink" title="一、HashMap基础"></a>一、HashMap基础</h1><h3 id="1、HashMap成员变量及默认值"><a href="#1、HashMap成员变量及默认值" class="headerlink" title="1、HashMap成员变量及默认值"></a>1、HashMap成员变量及默认值</h3><table><thead><tr><th align="center">名称</th><th align="center">类型</th><th align="center">默认值</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">DEFAULT_INITIAL_CAPACITY</td><td align="center">int</td><td align="center">$2^{4}$</td><td align="center">默认初始化容量 (这里的容量指table的长度而不是size，下同)</td></tr><tr><td align="center">MAXIMUM_CAPACITY</td><td align="center">int</td><td align="center">$2^{30}$</td><td align="center">最大容量（table最大长度）</td></tr><tr><td align="center">DEFAULT_LOAD_FACTOR</td><td align="center">float</td><td align="center">0.75f</td><td align="center">默认加载因子</td></tr><tr><td align="center">TREEIFY_THRESHOLD</td><td align="center">int</td><td align="center">8</td><td align="center">树形化阈值，如果链表长度&gt;=该值就考虑树形化</td></tr><tr><td align="center">UNTREEIFY_THRESHOLD</td><td align="center">int</td><td align="center">6</td><td align="center">链表化阈值，如果树的节点数&lt;=该值就考虑转换为链表</td></tr><tr><td align="center">MIN_TREEIFY_CAPACITY</td><td align="center">int</td><td align="center">64</td><td align="center">树形化需要的最小容量，只有table的长度&gt;=该值才会树形化</td></tr><tr><td align="center">table</td><td align="center">Node[]</td><td align="center">-</td><td align="center">hash桶，映射不同的hash地址</td></tr><tr><td align="center">entrySet</td><td align="center">Set&lt;Map.Entry&gt;</td><td align="center">-</td><td align="center">key-value set缓存</td></tr><tr><td align="center">size</td><td align="center">int</td><td align="center">-</td><td align="center">map包含的k-v节点个数（不是table长度）</td></tr><tr><td align="center">modCount</td><td align="center">int</td><td align="center">-</td><td align="center">Map结构修改次数（用于快速失败）</td></tr><tr><td align="center">threshold</td><td align="center">int</td><td align="center">-</td><td align="center">初始化容量或capacity*loadFactor</td></tr><tr><td align="center">loadFactor</td><td align="center">float</td><td align="center">-</td><td align="center">加载因子,决定什么时候该扩容</td></tr><tr><td align="center">keySet (from AbstrctMap)</td><td align="center">Set</td><td align="center">-</td><td align="center">key set 缓存</td></tr><tr><td align="center">values(from AbstrctMap)</td><td align="center">Collection</td><td align="center">-</td><td align="center">values 缓存</td></tr></tbody></table><h3 id="2、HashMap常用方法及实现原理"><a href="#2、HashMap常用方法及实现原理" class="headerlink" title="2、HashMap常用方法及实现原理"></a>2、HashMap常用方法及实现原理</h3><ol><li><strong>hash值的计算：</strong>HashMap中的hash不是直接使用<code>Object.hashCode()</code>生成的，而是在这基础上将hashCode的高16位与低16位进行了一次异或。这么做的原因与hash地址计算方式有关，HashMap的hash地址计算方式为<code>hash&amp;(table.length-1)</code>，从二进制的角度来看，绝大多数情况下只有hashCode的低几位有效参与了地址计算，这种情况下如果开发人员的hashCode实现不够优良，就会存在数据分布不均的情况，而高16位与低16位的异或将高16位特征带到低16位，可以最大化保证hashCode在低位的均匀分布。<details><summary style="color:blue">点击展开代码</summary> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> h;</span><br><span class="line"><span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);<span class="comment">//null的hash为0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></li></ol><ol start="2"><li><strong>判断传入的key是否可比较大小。</strong><br><strong>🔶</strong> 在红黑树操作中，当key的hash发生碰撞时，就调用这些方法尝试比较key的大小。<details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//是不是可比较，返回null表示不可比较，否则返回x.getClass()</span></span><br><span class="line"><span class="keyword">static</span> Class&lt;?&gt; comparableClassFor(Object x) &#123;</span><br><span class="line">  <span class="keyword">if</span> (x <span class="keyword">instanceof</span> Comparable) &#123;</span><br><span class="line">    Class&lt;?&gt; c; Type[] ts, as; Type t; ParameterizedType p;</span><br><span class="line">    <span class="comment">// String可比较，直接返回（String用的最多，所以这里单独处理，加快程序速度）</span></span><br><span class="line">    <span class="keyword">if</span> ((c = x.getClass()) == String.class) </span><br><span class="line">      <span class="keyword">return</span> c;</span><br><span class="line">    <span class="comment">//获取该类的接口，如果接口中有Comparable.class,就表示x是可比较的，直接返回该class</span></span><br><span class="line">    <span class="keyword">if</span> ((ts = c.getGenericInterfaces()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ts.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (((t = ts[i]) <span class="keyword">instanceof</span> ParameterizedType) &amp;&amp;</span><br><span class="line">            ((p = (ParameterizedType)t).getRawType() ==</span><br><span class="line">             Comparable.class) &amp;&amp;</span><br><span class="line">            (as = p.getActualTypeArguments()) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            as.length == <span class="number">1</span> &amp;&amp; as[<span class="number">0</span>] == c) <span class="comment">// type arg is c</span></span><br><span class="line">          <span class="keyword">return</span> c;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;<span class="comment">//不可比较的对象直接返回null</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//比较两个对象k, x</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;) <span class="comment">// for cast to Comparable</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">compareComparables</span><span class="params">(Class&lt;?&gt; kc, Object k, Object x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (x == <span class="keyword">null</span> || x.getClass() != kc ? <span class="number">0</span> : <span class="comment">//注意对null和class不同时的处理</span></span><br><span class="line">          ((Comparable)k).compareTo(x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></li></ol><ol start="3"><li><p><strong>根据给定的值重新计算tableSize：</strong>这一步是把我们自定义的capacity初始化为离cap最近的$2^{n}$的一个值，保证capacity是$2^{n}$的形式主要为了方便hash地址计算和扩容。</p><p><strong>🔶</strong> 试想一下假如初始化容量是15，根据hash地址的计算公式<code>hash&amp;(n-1)</code>，n-1也就是14，对应的二进制是1110，则<code>hash&amp;1110</code>结果必定是<code>xxx0</code>形式的，也就是说算出的地址最后一位永远是0，转换为10进制就发现奇数位的桶永远分配不到节点，这会导致HashMap严重分布不均。</p><p><strong>🔶</strong>  另一方面：扩容时，新容量是原容量的2倍，对于<code>hash&amp;(n-1)</code>来说，就相当于n-1的二进制向左扩展了1个1，比如(16-1)的二进制是<code>1111</code>，扩容后(32-1)的二进制<code>11111</code>，与原hash地址相比较只有最高位的1带来了差异（如下图所示），而hash中与之对应的位只有1和0两种情况，所以原链表/红黑树最多拆分为两个链表/红黑树就可以了，且拆分后的两个结构，一个留在原地(hash对应位为0)，一个升到高位置(hash对应位为1)，且这个高位是固定的，就是<code>hash&amp;(2n-1)</code>或者<code>hash&amp;(n-1)+n</code>。</p><img src="/2019/12/29/hashmap-source-learning/hash-addr.png" title="HashMap扩容"><p><strong>🔶</strong>  而当容量设置为15时，我们会发现14与29的二进制差异很大，这就给rehash的过程带来很大麻烦和不必要的开销。</p><details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将传入的cap变为相近的2的x次方的形式</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">  n |= n &gt;&gt;&gt; <span class="number">1</span>; <span class="comment">//将最高2位变为1</span></span><br><span class="line">  n |= n &gt;&gt;&gt; <span class="number">2</span>; <span class="comment">//将最高4位变为1</span></span><br><span class="line">  n |= n &gt;&gt;&gt; <span class="number">4</span>; <span class="comment">//将最高8位变为1</span></span><br><span class="line">  n |= n &gt;&gt;&gt; <span class="number">8</span>; <span class="comment">//将最高16位变为1</span></span><br><span class="line">  n |= n &gt;&gt;&gt; <span class="number">16</span>; <span class="comment">//32位全变为1(2^n-1)</span></span><br><span class="line">  <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;<span class="comment">//n+1就是2^n</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></li></ol><ol start="4"><li><strong>HashMap构造方法</strong><details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法：指定初始容量和加载因子</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> + initialCapacity);</span><br><span class="line">  <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">    initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">  <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> + loadFactor);</span><br><span class="line">  <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">  <span class="comment">//注意：用threshold保存初始化容量</span></span><br><span class="line">  <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造方法：指定初始容量，使用默认加载因子0.75</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造方法：无参构造方法，全部使用默认参数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造方法：从一个Map构造另一个Map，采用默认加载因子</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">  putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></li></ol><ol start="5"><li><strong>插入另外一个Map的所有数据（putMapEntries）</strong><details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//批量put元素， 当且仅当构造map并批量put时evict为false</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> s = m.size();<span class="comment">//现有Map元素数量</span></span><br><span class="line">  <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (table == <span class="keyword">null</span>) &#123; <span class="comment">// 如果table还未初始化</span></span><br><span class="line">      <span class="keyword">float</span> ft = ((<span class="keyword">float</span>)s / loadFactor) + <span class="number">1.0F</span>; <span class="comment">//计算需要的容量</span></span><br><span class="line">      <span class="keyword">int</span> t = ((ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">               (<span class="keyword">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class="line">      <span class="keyword">if</span> (t &gt; threshold) <span class="comment">//如果需要的容量大于之前设置的初始化容量</span></span><br><span class="line">        threshold = tableSizeFor(t);<span class="comment">//就重新确定一个比较大的初始化容量</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果table已经初始化了，且要加入的元素数量大于threshold就直接扩容</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; threshold) </span><br><span class="line">      resize();</span><br><span class="line">    <span class="comment">//放入新元素</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;</span><br><span class="line">      K key = e.getKey();</span><br><span class="line">      V value = e.getValue();</span><br><span class="line">      putVal(hash(key), key, value, <span class="keyword">false</span>, evict);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></li></ol><ol start="6"><li><strong>公共常用方法：</strong><details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取元素个数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Map是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据key获取元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">  Node&lt;K,V&gt; e;</span><br><span class="line">  <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//检查是否包含某个key，与get方法实现一致</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getNode(hash(key), key) != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新加入一个kay-value对，如果key已经存在就返回之前的value，否则返回null</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加入另外一个Map的所有元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    putMapEntries(m, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除key关联的元素，返回删除的元素，如果key不存在则返回null</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</span><br><span class="line">        <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除所有节点（注意：table.length没变）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//全部与table解挂就行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i)</span><br><span class="line">            tab[i] = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找是否存在给定的value（不建议使用）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; V v;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//遍历table</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">            <span class="comment">//遍历链表/树（这里可以看出树也有一条类似链表访问的路径）</span></span><br><span class="line">            <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((v = e.value) == value ||</span><br><span class="line">                    (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></li></ol><ol start="7"><li><strong>根据指定的key查找对应Node节点，找不到对应key就返回<code>null</code>。</strong><details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据给定的key获取节点</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="comment">//如果table不为空且对应hash地址的第首节点不为空</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//如果首节点的hash和key都与查询key匹配的话就直接返回首节点</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="comment">//否则检查首节点下面是否还有节点，有其他节点就继续查询</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果首节点是树状节点，就去红黑树中查询</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">//否则就遍历链表</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="comment">//如果找到某个key与给定key一致就返回该节点</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></li></ol><ol start="8"><li><strong>插入一个新节点，并返回旧节点的值，旧节点不存在返回<code>null</code>。</strong><details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//onlyIfAbsent表示是否仅当key不存在时才插入，evict为false表示在初始化(创建)模式</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">//table为空或长度为0时，重新扩容table</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">//如果插入的key对应的hash地址上没有值，则直接在该位置新增一个节点即可</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">//如果插入的key对应的hash地址上已经存在其他节点</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">//如果首节点就是key对应节点，就用一个临时变量e记录下来</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">//否则，如果首节点是树状节点，就去红黑树插入（找到）一个节点，并记录</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">//否则遍历链表</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//binCount记录链表长度</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">//如果整个链表都没找到key，则在末尾新创建一个节点</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">//如果链表长度达到树形化阈值，就将链表进行树形化或扩容操作</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果在链表中找到key就记录下来</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果插入的key已经存在就按要求替换值，并返回旧值</span></span><br><span class="line">        <span class="comment">//如果新插入节点e就是null，跳过这一步</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            <span class="comment">//更新节点完成后一些其他操作，HashMap这里什么也不做</span></span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="comment">//返回旧节点的值</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//统计Map结构修改次数,用于迭代器快速失败</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">//检查是否需要扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">//插入新节点后的一些额外操作，HashMap这里什么也不做</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></li></ol><ol start="9"><li><strong>移除一个节点</strong><details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除元素的实现，如果matchValue为true则还要匹配value</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</span><br><span class="line">    <span class="comment">//一顿空值检查</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;</span><br><span class="line">        <span class="comment">//第一个元素就是要删除的，用临时变量node记录</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            node = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//从树中找到要删除的元素node</span></span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//遍历链表</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                         (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e;<span class="comment">//p是e的前驱节点</span></span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果node不为空且value检查也符合条件</span></span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                             (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            <span class="comment">//从树中删除node</span></span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">            <span class="comment">//node就是首节点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">//删除node</span></span><br><span class="line">                p.next = node.next;</span><br><span class="line">            ++modCount;<span class="comment">//记录本次修改</span></span><br><span class="line">            --size;<span class="comment">//size-1</span></span><br><span class="line">            afterNodeRemoval(node);<span class="comment">//删除节点后的其他工作，HashMap什么也不做</span></span><br><span class="line">            <span class="keyword">return</span> node;<span class="comment">//返回删除的节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></li></ol><h3 id="3、HashMap扩容、Rehash和树形化"><a href="#3、HashMap扩容、Rehash和树形化" class="headerlink" title="3、HashMap扩容、Rehash和树形化"></a>3、HashMap扩容、Rehash和树形化</h3><ol><li><p><strong>HashMap扩容方法</strong></p><p>🔶 HashMap扩容的条件：1、初始化。2、HashMap中节点总数大于capacity*loadfactor。3、capacity小于<code>MIN_TREEIFY_CAPACITY</code>(64)，且单链表长度大于等于<code>TREEIFY_THRESHOLD</code>(8)。</p><p>🔶 达到扩容条件后并不是一定扩容成功，如果当前容量大于等于<code>MAXIMUM_CAPACITY</code>($2^{30}$)就不再扩容，threshold设置为<code>Integer.MAX_VALUE</code>。这里一定不会出现扩容后的容量大于<code>MAXIMUM_CAPACITY</code>的情况，因为capacity都是2的整数次方形式，一次扩容只扩大一倍，因此无限扩容时一定会命中<code>MAXIMUM_CAPACITY</code>，此后不再扩容。</p><details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//HashMap扩容操作，先扩容再重新分布（如果需要的话）</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//如果旧table长度大于0（非初始化）</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//如果旧table长度达最大值，就直接调整阈值到最大值</span></span><br><span class="line">        <span class="comment">//此后阈值失效，不再扩容，并直接返回旧table</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果新table长度小于MAXIMUM_CAPACITY，阈值x2</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            <span class="comment">//oldCap*2后可能&gt;=MAXIMUM_CAPACITY，此时newThr赋值操作跳过，就还是0</span></span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果初始化容量大于0，新容量就是这个值（注意这里没有设置newThr,newThr还是0）</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="comment">//根据默认情况初始化table</span></span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果非默认初始化时，新容量等于MAXIMUM_CAPACITY时，newThr为0，需要重新计算</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//rehash过程，重新分布元素</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//遍历旧table</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="comment">//如果j位置有元素就用临时变量e标记</span></span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//释放旧table[j]</span></span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">//如果e只有一个元素（不构成链表、树），就直接重新计算地址，然后放过去</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">//如果e是红黑树，就按红黑树的方式rehash</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="comment">//如果e是链表，就拆分为两个链表，一个在原位置一个在新位置</span></span><br><span class="line">                <span class="comment">//只需要拆分为两个链表的原因与其地址计算方式有关:hash&amp;(n-1)</span></span><br><span class="line">                <span class="comment">//扩容2倍，对于n-1的二进制来说就是左边多了一个1，这对于原来在该链表的key</span></span><br><span class="line">                <span class="comment">//来说，也只需要关注hash对应位置是0还是1，0则留在原地，1则搬到新住所</span></span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order（保留相对顺序）</span></span><br><span class="line">                    <span class="comment">//留在原地的链表头&amp;尾（新table地址低位，这里的高低就是数字大小）</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="comment">//乔迁新居的链表头&amp;尾（新table地址高位）</span></span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="comment">//遍历旧链表</span></span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">//是否留在原地，(e.hash &amp; oldCap)==0表示新增的那一位为0，</span></span><br><span class="line">                        <span class="comment">//不影响新地址计算，否则就要搬家</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)<span class="comment">//链表初始化</span></span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span> <span class="comment">//追加到尾部</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 乔迁新居</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">//如果拆分出来的链表不为空就把它放到对应位置上</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="comment">//新地址的计算方式：$oldAddr + oldCap</span></span><br><span class="line">                        <span class="comment">//hash&amp;(oldCap-1)+oldCap = hash&amp;(oldCap*2-1)</span></span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></li></ol><ol start="2"><li><strong>树形化操作</strong><details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//树形化，如果table长度(！！！不是size！！！)小于MIN_TREEIFY_CAPACITY(64)则进行扩容</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">//如果table为空或table长度小于MIN_TREEIFY_CAPACITY则进行扩容，why???</span></span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">//如果给定的hash对应位置不为空</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//先把节点类型全部换成TreeNode</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">                hd = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p.prev = tl;</span><br><span class="line">                tl.next = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tl = p;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//树形化，index就是地址: index = (n - 1) &amp; hash</span></span><br><span class="line">        <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">            hd.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></li></ol><h3 id="4、Node定义及与TreeNode转换操作"><a href="#4、Node定义及与TreeNode转换操作" class="headerlink" title="4、Node定义及与TreeNode转换操作"></a>4、Node定义及与TreeNode转换操作</h3><ol><li><strong>Node定义</strong><details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Node数据结构</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;<span class="comment">//key的hash</span></span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + value; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">        V oldValue = value;</span><br><span class="line">        value = newValue;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">            <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                Objects.equals(value, e.getValue()))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></li></ol><ol start="2"><li><strong>Node、TreeNode构造及转换操作</strong><details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a regular (non-tree) node</span></span><br><span class="line"><span class="function">Node&lt;K,V&gt; <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Node&lt;&gt;(hash, key, value, next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// For conversion from TreeNodes to plain nodes</span></span><br><span class="line"><span class="function">Node&lt;K,V&gt; <span class="title">replacementNode</span><span class="params">(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Node&lt;&gt;(p.hash, p.key, p.value, next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a tree bin node</span></span><br><span class="line"><span class="function">TreeNode&lt;K,V&gt; <span class="title">newTreeNode</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TreeNode&lt;&gt;(hash, key, value, next);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// For treeifyBin</span></span><br><span class="line"><span class="function">TreeNode&lt;K,V&gt; <span class="title">replacementTreeNode</span><span class="params">(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TreeNode&lt;&gt;(p.hash, p.key, p.value, next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></li></ol><h3 id="5、-Set视图、迭代器-Iterator-与分割器-Spliterator"><a href="#5、-Set视图、迭代器-Iterator-与分割器-Spliterator" class="headerlink" title="5、 Set视图、迭代器(Iterator)与分割器(Spliterator)"></a>5、 Set视图、迭代器(Iterator)与分割器(Spliterator)</h3><ol><li><p>keySet</p><ul><li><strong>KeySet定义</strong><details><summary style="color:blue">点击展开代码</summary> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//HashMap御用KeySet</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KeySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>                 </span>&#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span>               </span>&#123; HashMap.<span class="keyword">this</span>.clear(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;K&gt; <span class="title">iterator</span><span class="params">()</span>     </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> KeyIterator(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123; <span class="keyword">return</span> containsKey(o); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>) != <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Spliterator&lt;K&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> KeySpliterator&lt;&gt;(HashMap.<span class="keyword">this</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> K&gt; action)</span> </span>&#123;</span><br><span class="line">      Node&lt;K,V&gt;[] tab;</span><br><span class="line">      <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">      <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; (tab = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">int</span> mc = modCount;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">              <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next)</span><br><span class="line">                  action.accept(e.key);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//迭代前后修改次数不一致则快速失败</span></span><br><span class="line">          <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></li></ul><ul><li><strong>keySet方法</strong><details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回key的集合【视图】,它并不是真正的Set，它仅仅提供了Set化的操作接口。</span></span><br><span class="line"><span class="comment">//Set与Map的任何修改都会相互体现出来。</span></span><br><span class="line"><span class="comment">//在Set迭代过程中修改了Map则迭代结果未定义。</span></span><br><span class="line"><span class="comment">//可以通过Set自带的方法修改Map，但不能添加key。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Set&lt;K&gt; ks = keySet;</span><br><span class="line">    <span class="keyword">if</span> (ks == <span class="keyword">null</span>) &#123;</span><br><span class="line">        ks = <span class="keyword">new</span> KeySet();</span><br><span class="line">        keySet = ks;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></li></ul></li></ol><ol start="2"><li><p>values</p><ul><li><strong>Values定义</strong><details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Values</span> <span class="keyword">extends</span> <span class="title">AbstractCollection</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>                 </span>&#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span>               </span>&#123; HashMap.<span class="keyword">this</span>.clear(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;V&gt; <span class="title">iterator</span><span class="params">()</span>     </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> ValueIterator(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123; <span class="keyword">return</span> containsValue(o); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Spliterator&lt;V&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ValueSpliterator&lt;&gt;(HashMap.<span class="keyword">this</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> V&gt; action)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab;</span><br><span class="line">        <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; (tab = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> mc = modCount;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next)</span><br><span class="line">                    action.accept(e.value);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//同样快速失败</span></span><br><span class="line">            <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></li></ul><ul><li><strong>values方法</strong><details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//values：类似KeySet</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Collection&lt;V&gt; <span class="title">values</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Collection&lt;V&gt; vs = values;</span><br><span class="line">    <span class="keyword">if</span> (vs == <span class="keyword">null</span>) &#123;</span><br><span class="line">        vs = <span class="keyword">new</span> Values();</span><br><span class="line">        values = vs;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></li></ul></li></ol><ol start="3"><li><p>entrySet</p><ul><li><strong>EntrySet定义</strong><details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EntrySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>                 </span>&#123; <span class="keyword">return</span> size; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span>               </span>&#123; HashMap.<span class="keyword">this</span>.clear(); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EntryIterator();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;</span><br><span class="line">        Object key = e.getKey();</span><br><span class="line">        Node&lt;K,V&gt; candidate = getNode(hash(key), key);</span><br><span class="line">        <span class="keyword">return</span> candidate != <span class="keyword">null</span> &amp;&amp; candidate.equals(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;</span><br><span class="line">            Object key = e.getKey();</span><br><span class="line">            Object value = e.getValue();</span><br><span class="line">            <span class="keyword">return</span> removeNode(hash(key), key, value, <span class="keyword">true</span>, <span class="keyword">true</span>) != <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Spliterator&lt;Map.Entry&lt;K,V&gt;&gt; spliterator() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EntrySpliterator&lt;&gt;(HashMap.<span class="keyword">this</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> Map.Entry&lt;K,V&gt;&gt; action)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab;</span><br><span class="line">        <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; (tab = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> mc = modCount;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next)</span><br><span class="line">                    action.accept(e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></li></ul><ul><li><strong>entrySet方法</strong><details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//EntrySet: same as keySet and values</span></span><br><span class="line"><span class="keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123;</span><br><span class="line">    Set&lt;Map.Entry&lt;K,V&gt;&gt; es;</span><br><span class="line">    <span class="keyword">return</span> (es = entrySet) == <span class="keyword">null</span> ? (entrySet = <span class="keyword">new</span> EntrySet()) : es;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></li></ul></li></ol><ol start="4"><li><p>迭代器(Itetator)</p><ul><li><strong>HashIterator核心功能（抽象类）</strong><details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//迭代器，注意是abstract</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HashIterator</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; next;        <span class="comment">// next entry to return</span></span><br><span class="line">    Node&lt;K,V&gt; current;     <span class="comment">// current entry</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount;  <span class="comment">// for fast-fail</span></span><br><span class="line">    <span class="keyword">int</span> index;             <span class="comment">// current slot</span></span><br><span class="line"></span><br><span class="line">    HashIterator() &#123;</span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">        Node&lt;K,V&gt;[] t = table;</span><br><span class="line">        current = next = <span class="keyword">null</span>;</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//找到第一个不为null的node，用next标记</span></span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123; <span class="comment">// advance to first entry</span></span><br><span class="line">            <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> next != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">nextNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] t;</span><br><span class="line">        Node&lt;K,V&gt; e = next;</span><br><span class="line">        <span class="comment">//迭代中途发生结构修改，直接快速失败</span></span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        <span class="comment">//如果当前链表/树遍历完了，就在table中寻找下一个不为null的节点</span></span><br><span class="line">        <span class="keyword">if</span> ((next = (current = e).next) == <span class="keyword">null</span> &amp;&amp; (t = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; p = current;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>)<span class="comment">//如果当前节点被删除了</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        current = <span class="keyword">null</span>;</span><br><span class="line">        K key = p.key;、</span><br><span class="line">            <span class="comment">//删除节点</span></span><br><span class="line">            removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//更新【期望修改次数】，很重要！！！</span></span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></li></ul><ul><li><strong>遍历keySet使用的KeyIterator</strong><details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//三种迭代器，都以abstract HashIterator为基础</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextNode().key; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></li></ul><ul><li><strong>遍历values使用的ValueIterator</strong><details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextNode().value; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></li></ul><ul><li><strong>遍历entrySet使用的EntryIterator</strong><details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EntryIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Map.<span class="function">Entry&lt;K,V&gt; <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextNode(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></li></ul></li></ol><ol start="5"><li><p>分割器(Spliterator)，Java8新引入的功能</p><ul><li><strong>HashMapSpliterator核心功能（抽象类）</strong><details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分割器，</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapSpliterator</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> HashMap&lt;K,V&gt; map;</span><br><span class="line">    Node&lt;K,V&gt; current;          <span class="comment">// current node</span></span><br><span class="line">    <span class="keyword">int</span> index;                  <span class="comment">// current index, modified on advance/split</span></span><br><span class="line">    <span class="keyword">int</span> fence;                  <span class="comment">// one past last index</span></span><br><span class="line">    <span class="keyword">int</span> est;                    <span class="comment">// size estimate</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount;       <span class="comment">// for comodification checks</span></span><br><span class="line"></span><br><span class="line">    HashMapSpliterator(HashMap&lt;K,V&gt; m, <span class="keyword">int</span> origin,</span><br><span class="line">                       <span class="keyword">int</span> fence, <span class="keyword">int</span> est,</span><br><span class="line">                       <span class="keyword">int</span> expectedModCount) &#123;</span><br><span class="line">        <span class="keyword">this</span>.map = m;</span><br><span class="line">        <span class="keyword">this</span>.index = origin;</span><br><span class="line">        <span class="keyword">this</span>.fence = fence;</span><br><span class="line">        <span class="keyword">this</span>.est = est;</span><br><span class="line">        <span class="keyword">this</span>.expectedModCount = expectedModCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getFence</span><span class="params">()</span> </span>&#123; <span class="comment">// initialize fence and size on first use</span></span><br><span class="line">        <span class="keyword">int</span> hi;</span><br><span class="line">        <span class="keyword">if</span> ((hi = fence) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            HashMap&lt;K,V&gt; m = map;</span><br><span class="line">            est = m.size;</span><br><span class="line">            expectedModCount = m.modCount;</span><br><span class="line">            Node&lt;K,V&gt;[] tab = m.table;</span><br><span class="line">            hi = fence = (tab == <span class="keyword">null</span>) ? <span class="number">0</span> : tab.length;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hi;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">estimateSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        getFence(); <span class="comment">// force init</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">long</span>) est;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></li></ul><ul><li><strong>KeySpliterator</strong><details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KeySpliterator</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMapSpliterator</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Spliterator</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">    KeySpliterator(HashMap&lt;K,V&gt; m, <span class="keyword">int</span> origin, <span class="keyword">int</span> fence, <span class="keyword">int</span> est,</span><br><span class="line">                   <span class="keyword">int</span> expectedModCount) &#123;</span><br><span class="line">        <span class="keyword">super</span>(m, origin, fence, est, expectedModCount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> KeySpliterator&lt;K,V&gt; <span class="title">trySplit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hi = getFence(), lo = index, mid = (lo + hi) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> (lo &gt;= mid || current != <span class="keyword">null</span>) ? <span class="keyword">null</span> :</span><br><span class="line">        <span class="keyword">new</span> KeySpliterator&lt;&gt;(map, lo, index = mid, est &gt;&gt;&gt;= <span class="number">1</span>,</span><br><span class="line">                             expectedModCount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> K&gt; action)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i, hi, mc;</span><br><span class="line">        <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        HashMap&lt;K,V&gt; m = map;</span><br><span class="line">        Node&lt;K,V&gt;[] tab = m.table;</span><br><span class="line">        <span class="keyword">if</span> ((hi = fence) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            mc = expectedModCount = m.modCount;</span><br><span class="line">            hi = fence = (tab == <span class="keyword">null</span>) ? <span class="number">0</span> : tab.length;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            mc = expectedModCount;</span><br><span class="line">        <span class="keyword">if</span> (tab != <span class="keyword">null</span> &amp;&amp; tab.length &gt;= hi &amp;&amp;</span><br><span class="line">            (i = index) &gt;= <span class="number">0</span> &amp;&amp; (i &lt; (index = hi) || current != <span class="keyword">null</span>)) &#123;</span><br><span class="line">            Node&lt;K,V&gt; p = current;</span><br><span class="line">            current = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">                    p = tab[i++];</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    action.accept(p.key);</span><br><span class="line">                    p = p.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">while</span> (p != <span class="keyword">null</span> || i &lt; hi);</span><br><span class="line">            <span class="keyword">if</span> (m.modCount != mc)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAdvance</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> K&gt; action)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hi;</span><br><span class="line">        <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        Node&lt;K,V&gt;[] tab = map.table;</span><br><span class="line">        <span class="keyword">if</span> (tab != <span class="keyword">null</span> &amp;&amp; tab.length &gt;= (hi = getFence()) &amp;&amp; index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (current != <span class="keyword">null</span> || index &lt; hi) &#123;</span><br><span class="line">                <span class="keyword">if</span> (current == <span class="keyword">null</span>)</span><br><span class="line">                    current = tab[index++];</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    K k = current.key;</span><br><span class="line">                    current = current.next;</span><br><span class="line">                    action.accept(k);</span><br><span class="line">                    <span class="keyword">if</span> (map.modCount != expectedModCount)</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">characteristics</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (fence &lt; <span class="number">0</span> || est == map.size ? Spliterator.SIZED : <span class="number">0</span>) |</span><br><span class="line">            Spliterator.DISTINCT;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></li></ul><ul><li><strong>ValueSpliterator</strong><details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueSpliterator</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMapSpliterator</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Spliterator</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    ValueSpliterator(HashMap&lt;K,V&gt; m, <span class="keyword">int</span> origin, <span class="keyword">int</span> fence, <span class="keyword">int</span> est,</span><br><span class="line">                     <span class="keyword">int</span> expectedModCount) &#123;</span><br><span class="line">        <span class="keyword">super</span>(m, origin, fence, est, expectedModCount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ValueSpliterator&lt;K,V&gt; <span class="title">trySplit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hi = getFence(), lo = index, mid = (lo + hi) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> (lo &gt;= mid || current != <span class="keyword">null</span>) ? <span class="keyword">null</span> :</span><br><span class="line">        <span class="keyword">new</span> ValueSpliterator&lt;&gt;(map, lo, index = mid, est &gt;&gt;&gt;= <span class="number">1</span>,</span><br><span class="line">                               expectedModCount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> V&gt; action)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i, hi, mc;</span><br><span class="line">        <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        HashMap&lt;K,V&gt; m = map;</span><br><span class="line">        Node&lt;K,V&gt;[] tab = m.table;</span><br><span class="line">        <span class="keyword">if</span> ((hi = fence) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            mc = expectedModCount = m.modCount;</span><br><span class="line">            hi = fence = (tab == <span class="keyword">null</span>) ? <span class="number">0</span> : tab.length;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            mc = expectedModCount;</span><br><span class="line">        <span class="keyword">if</span> (tab != <span class="keyword">null</span> &amp;&amp; tab.length &gt;= hi &amp;&amp;</span><br><span class="line">            (i = index) &gt;= <span class="number">0</span> &amp;&amp; (i &lt; (index = hi) || current != <span class="keyword">null</span>)) &#123;</span><br><span class="line">            Node&lt;K,V&gt; p = current;</span><br><span class="line">            current = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">                    p = tab[i++];</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    action.accept(p.value);</span><br><span class="line">                    p = p.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">while</span> (p != <span class="keyword">null</span> || i &lt; hi);</span><br><span class="line">            <span class="keyword">if</span> (m.modCount != mc)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAdvance</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> V&gt; action)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hi;</span><br><span class="line">        <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        Node&lt;K,V&gt;[] tab = map.table;</span><br><span class="line">        <span class="keyword">if</span> (tab != <span class="keyword">null</span> &amp;&amp; tab.length &gt;= (hi = getFence()) &amp;&amp; index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (current != <span class="keyword">null</span> || index &lt; hi) &#123;</span><br><span class="line">                <span class="keyword">if</span> (current == <span class="keyword">null</span>)</span><br><span class="line">                    current = tab[index++];</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    V v = current.value;</span><br><span class="line">                    current = current.next;</span><br><span class="line">                    action.accept(v);</span><br><span class="line">                    <span class="keyword">if</span> (map.modCount != expectedModCount)</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">characteristics</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (fence &lt; <span class="number">0</span> || est == map.size ? Spliterator.SIZED : <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></li></ul><ul><li><strong>EntrySpliterator</strong><details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EntrySpliterator</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMapSpliterator</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Spliterator</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>&#123;</span><br><span class="line">    EntrySpliterator(HashMap&lt;K,V&gt; m, <span class="keyword">int</span> origin, <span class="keyword">int</span> fence, <span class="keyword">int</span> est,</span><br><span class="line">                     <span class="keyword">int</span> expectedModCount) &#123;</span><br><span class="line">        <span class="keyword">super</span>(m, origin, fence, est, expectedModCount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> EntrySpliterator&lt;K,V&gt; <span class="title">trySplit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hi = getFence(), lo = index, mid = (lo + hi) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> (lo &gt;= mid || current != <span class="keyword">null</span>) ? <span class="keyword">null</span> :</span><br><span class="line">        <span class="keyword">new</span> EntrySpliterator&lt;&gt;(map, lo, index = mid, est &gt;&gt;&gt;= <span class="number">1</span>,</span><br><span class="line">                               expectedModCount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> Map.Entry&lt;K,V&gt;&gt; action)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i, hi, mc;</span><br><span class="line">        <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        HashMap&lt;K,V&gt; m = map;</span><br><span class="line">        Node&lt;K,V&gt;[] tab = m.table;</span><br><span class="line">        <span class="keyword">if</span> ((hi = fence) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            mc = expectedModCount = m.modCount;</span><br><span class="line">            hi = fence = (tab == <span class="keyword">null</span>) ? <span class="number">0</span> : tab.length;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            mc = expectedModCount;</span><br><span class="line">        <span class="keyword">if</span> (tab != <span class="keyword">null</span> &amp;&amp; tab.length &gt;= hi &amp;&amp;</span><br><span class="line">            (i = index) &gt;= <span class="number">0</span> &amp;&amp; (i &lt; (index = hi) || current != <span class="keyword">null</span>)) &#123;</span><br><span class="line">            Node&lt;K,V&gt; p = current;</span><br><span class="line">            current = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">                    p = tab[i++];</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    action.accept(p);</span><br><span class="line">                    p = p.next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">while</span> (p != <span class="keyword">null</span> || i &lt; hi);</span><br><span class="line">            <span class="keyword">if</span> (m.modCount != mc)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAdvance</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> Map.Entry&lt;K,V&gt;&gt; action)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hi;</span><br><span class="line">        <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        Node&lt;K,V&gt;[] tab = map.table;</span><br><span class="line">        <span class="keyword">if</span> (tab != <span class="keyword">null</span> &amp;&amp; tab.length &gt;= (hi = getFence()) &amp;&amp; index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (current != <span class="keyword">null</span> || index &lt; hi) &#123;</span><br><span class="line">                <span class="keyword">if</span> (current == <span class="keyword">null</span>)</span><br><span class="line">                    current = tab[index++];</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    Node&lt;K,V&gt; e = current;</span><br><span class="line">                    current = current.next;</span><br><span class="line">                    action.accept(e);</span><br><span class="line">                    <span class="keyword">if</span> (map.modCount != expectedModCount)</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">characteristics</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (fence &lt; <span class="number">0</span> || est == map.size ? Spliterator.SIZED : <span class="number">0</span>) |</span><br><span class="line">            Spliterator.DISTINCT;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></li></ul></li></ol><h1 id="二、-Java8新特性"><a href="#二、-Java8新特性" class="headerlink" title="二、 Java8新特性"></a>二、 Java8新特性</h1><ol><li>带默认值的get方法<details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">getOrDefault</span><span class="params">(Object key, V defaultValue)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? defaultValue : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></li></ol><ol start="2"><li>缺失key或key为null才插入节点，返回旧节点的值，如果存在的话<details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">putIfAbsent</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">true</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></li></ol><ol start="3"><li>基于key和value两重验证的删除操作<details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> removeNode(hash(key), key, value, <span class="keyword">true</span>, <span class="keyword">true</span>) != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></li></ol><ol start="4"><li>基于key和value两重验证的替换操作<details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">replace</span><span class="params">(K key, V oldValue, V newValue)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e; V v;</span><br><span class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">        ((v = e.value) == oldValue || (v != <span class="keyword">null</span> &amp;&amp; v.equals(oldValue)))) &#123;</span><br><span class="line">        e.value = newValue;</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></li></ol><ol start="5"><li>value替换操作，仅当key存在才替换，注意与put的区别<details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">replace</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        V oldValue = e.value;</span><br><span class="line">        e.value = value;</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></li></ol><ol start="6"><li>如果给定的key在map中不存在，就从给定的function计算出一个value放进map，并返回这个value<details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">computeIfAbsent</span><span class="params">(K key, Function&lt;? <span class="keyword">super</span> K,? extends V&gt; mappingFunction)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mappingFunction == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    TreeNode&lt;K,V&gt; t = <span class="keyword">null</span>;</span><br><span class="line">    Node&lt;K,V&gt; old = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//是否需要初始化</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt; threshold || (tab = table) == <span class="keyword">null</span> ||</span><br><span class="line">        (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="keyword">if</span> ((first = tab[i = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//如果首个节点是树型节点，就在树中查找key，返回节点用old标记</span></span><br><span class="line">        <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            old = (t = (TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;K,V&gt; e = first; K k;</span><br><span class="line">            <span class="comment">//遍历链表查询key是否存在</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                    old = e;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//统计链表长度</span></span><br><span class="line">                ++binCount;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        V oldValue;</span><br><span class="line">        <span class="comment">//如果给定key存在，并且value不为null，就直接返回对应的值</span></span><br><span class="line">        <span class="keyword">if</span> (old != <span class="keyword">null</span> &amp;&amp; (oldValue = old.value) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            afterNodeAccess(old);<span class="comment">//Do nothing</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//否则就从给定的函数key -&gt; &#123;...&#125;，计算出一个value并插入</span></span><br><span class="line">    V v = mappingFunction.apply(key);</span><br><span class="line">    <span class="keyword">if</span> (v == <span class="keyword">null</span>) &#123; <span class="comment">//如果计算出的value是null则直接返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (old != <span class="keyword">null</span>) &#123; <span class="comment">//key存在但value为null就直接替换value并返回旧value</span></span><br><span class="line">        old.value = v;</span><br><span class="line">        afterNodeAccess(old);</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (t != <span class="keyword">null</span>) <span class="comment">//如果key不存在，且当前位置为一棵树，则向树中增加一个节点</span></span><br><span class="line">        t.putTreeVal(<span class="keyword">this</span>, tab, hash, key, v);</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">//如果key不存在，且当前位置为链表，则向表头增加一个节点</span></span><br><span class="line">        tab[i] = newNode(hash, key, v, first);</span><br><span class="line">        <span class="comment">//增加完成后判断是否需要树形化</span></span><br><span class="line">        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>)</span><br><span class="line">            treeifyBin(tab, hash);</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    ++size;<span class="comment">//插入新节点size+1</span></span><br><span class="line">    afterNodeInsertion(<span class="keyword">true</span>);<span class="comment">//Do nothing</span></span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></li></ol><ol start="7"><li>如果给定的key存在，就用<code>(k,oldV) -&gt; {}</code>计算出的值替换旧值，并返回计算出的新值<details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">computeIfPresent</span><span class="params">(K key, </span></span></span><br><span class="line"><span class="function"><span class="params">    BiFunction&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V, ? extends V&gt; remappingFunction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (remappingFunction == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    Node&lt;K,V&gt; e; V oldValue;</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="comment">//key存在且旧值不为null</span></span><br><span class="line">    <span class="keyword">if</span> ((e = getNode(hash, key)) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">        (oldValue = e.value) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//计算新值</span></span><br><span class="line">        V v = remappingFunction.apply(key, oldValue);</span><br><span class="line">        <span class="comment">//如果新值不为null则替换成新值，并返回新值</span></span><br><span class="line">        <span class="keyword">if</span> (v != <span class="keyword">null</span>) &#123;</span><br><span class="line">            e.value = v;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> v;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//否则删除旧节点(新值为null代表该节点无效)</span></span><br><span class="line">            removeNode(hash, key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//找不到key直接返回null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></li></ol><ol start="8"><li>用<code>(key, Oldv) -&gt; {}</code>计算出的新值替换key对应的旧值，返回新值<details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//key存在，新值为null，删除key节点</span></span><br><span class="line"><span class="comment">//key存在，新值不为null，修改key节点</span></span><br><span class="line"><span class="comment">//key不存在，新值为null，直接返回null</span></span><br><span class="line"><span class="comment">//key不存在，新值不为null，创建新节点</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">compute</span><span class="params">(K key,</span></span></span><br><span class="line"><span class="function"><span class="params">    BiFunction&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V, ? extends V&gt; remappingFunction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (remappingFunction == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    TreeNode&lt;K,V&gt; t = <span class="keyword">null</span>;</span><br><span class="line">    Node&lt;K,V&gt; old = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//table未初始化或需要扩容就执行扩容</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt; threshold || (tab = table) == <span class="keyword">null</span> ||</span><br><span class="line">        (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">//如果首节点不为null</span></span><br><span class="line">    <span class="keyword">if</span> ((first = tab[i = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//如果是红黑树就在树中查找key，对应node用old标记</span></span><br><span class="line">        <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            old = (t = (TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//遍历链表，用old标记找到的node</span></span><br><span class="line">            Node&lt;K,V&gt; e = first; K k;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                    old = e;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ++binCount;<span class="comment">//统计链表长度，用于判断是否需要树形化</span></span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    V oldValue = (old == <span class="keyword">null</span>) ? <span class="keyword">null</span> : old.value;</span><br><span class="line">    <span class="comment">//计算新value</span></span><br><span class="line">    V v = remappingFunction.apply(key, oldValue);</span><br><span class="line">    <span class="keyword">if</span> (old != <span class="keyword">null</span>) &#123;<span class="comment">//对应的key存在</span></span><br><span class="line">        <span class="keyword">if</span> (v != <span class="keyword">null</span>) &#123;<span class="comment">//如果新value不为null则替换成新value</span></span><br><span class="line">            old.value = v;</span><br><span class="line">            afterNodeAccess(old);<span class="comment">//Do nothing</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//否则删除key对应的旧节点</span></span><br><span class="line">            removeNode(hash, key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (v != <span class="keyword">null</span>) &#123; <span class="comment">//如果新value不为null，且key不存在，则添加新节点</span></span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>)<span class="comment">//如果是树型结构就在树中添加新节点</span></span><br><span class="line">            t.putTreeVal(<span class="keyword">this</span>, tab, hash, key, v);</span><br><span class="line">        <span class="keyword">else</span> &#123;<span class="comment">//否则就在链表头部添加新节点</span></span><br><span class="line">            tab[i] = newNode(hash, key, v, first);</span><br><span class="line">            <span class="comment">//如果需要树形化就开始树形化操作</span></span><br><span class="line">            <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>)</span><br><span class="line">                treeifyBin(tab, hash);</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        ++size;<span class="comment">//插入新节点size+1</span></span><br><span class="line">        afterNodeInsertion(<span class="keyword">true</span>);<span class="comment">//Do nothing</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></li></ol><ol start="9"><li>合并两个key一样的value，新值生成函数<code>(oldV, newV) -&gt; {}</code>，用生成的新值去替换旧值<details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意：只有old value不为null才去调用这个函数，否则直接插入新value</span></span><br><span class="line"><span class="comment">//Stream中toMap会用到，一般解决key冲突</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">merge</span><span class="params">(K key, V value,</span></span></span><br><span class="line"><span class="function"><span class="params">    BiFunction&lt;? <span class="keyword">super</span> V, ? <span class="keyword">super</span> V, ? extends V&gt; remappingFunction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">if</span> (remappingFunction == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    TreeNode&lt;K,V&gt; t = <span class="keyword">null</span>;</span><br><span class="line">    Node&lt;K,V&gt; old = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &gt; threshold || (tab = table) == <span class="keyword">null</span> ||</span><br><span class="line">        (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="keyword">if</span> ((first = tab[i = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            old = (t = (TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;K,V&gt; e = first; K k;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                    old = e;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ++binCount;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (old != <span class="keyword">null</span>) &#123;</span><br><span class="line">        V v;</span><br><span class="line">        <span class="keyword">if</span> (old.value != <span class="keyword">null</span>)</span><br><span class="line">            v = remappingFunction.apply(old.value, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            v = value;</span><br><span class="line">        <span class="keyword">if</span> (v != <span class="keyword">null</span>) &#123;</span><br><span class="line">            old.value = v;</span><br><span class="line">            afterNodeAccess(old);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            removeNode(hash, key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>)</span><br><span class="line">            t.putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tab[i] = newNode(hash, key, value, first);</span><br><span class="line">            <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>)</span><br><span class="line">                treeifyBin(tab, hash);</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        ++size;</span><br><span class="line">        afterNodeInsertion(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></li></ol><ol start="10"><li>用给定的consumer循环处理每个key-value pair<details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(BiConsumer&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V&gt; action)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab;</span><br><span class="line">    <span class="keyword">if</span> (action == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; (tab = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> mc = modCount;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next)</span><br><span class="line">                action.accept(e.key, e.value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果中间发生过修改则快速失败，并抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (modCount != mc)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></li></ol><ol start="11"><li>用给定的函数<code>(k,v)-&gt;{}</code>生成一个新值，并用新值替换旧值，这个操作作用于所有元素<details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">replaceAll</span><span class="params">(BiFunction&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V, ? extends V&gt; function)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab;</span><br><span class="line">    <span class="keyword">if</span> (function == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; (tab = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> mc = modCount;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                e.value = function.apply(e.key, e.value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (modCount != mc)<span class="comment">//线程安全检查</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></li></ol><h1 id="三、-红黑树相关操作"><a href="#三、-红黑树相关操作" class="headerlink" title="三、 红黑树相关操作"></a>三、 红黑树相关操作</h1><ol><li>红黑树节点定义（仅含构造方法）<details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TreeNode定义，从Node上继承了key, value和next相关成员</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">    TreeNode&lt;K,V&gt; left;</span><br><span class="line">    TreeNode&lt;K,V&gt; right;</span><br><span class="line">    TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">    <span class="keyword">boolean</span> red;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, val, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></li></ol><ol start="2"><li>找到当前树的root节点<details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">root</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//从当前节点向前，一直到parent为null的节点就是root节点</span></span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; r = <span class="keyword">this</span>, p;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((p = r.parent) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        r = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></li></ol><ol start="3"><li>将root节点放到该hash地址的首个节点位置上<details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function"><span class="keyword">void</span> <span class="title">moveRootToFront</span><span class="params">(Node&lt;K,V&gt;[] tab, TreeNode&lt;K,V&gt; root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span> &amp;&amp; tab != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = (n - <span class="number">1</span>) &amp; root.hash;<span class="comment">//首个节点地址</span></span><br><span class="line">        TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index];</span><br><span class="line">        <span class="comment">//如果首个节点不是root节点，就把root节点提到首位</span></span><br><span class="line">        <span class="keyword">if</span> (root != first) &#123;</span><br><span class="line">            Node&lt;K,V&gt; rn;</span><br><span class="line">            tab[index] = root;<span class="comment">//地址节点直接指向root</span></span><br><span class="line">            TreeNode&lt;K,V&gt; rp = root.prev; <span class="comment">//rp:root之前的部分</span></span><br><span class="line">            <span class="keyword">if</span> ((rn = root.next) != <span class="keyword">null</span>) <span class="comment">//rn:root之后的部分</span></span><br><span class="line">                <span class="comment">//root之后的部分pre直接与root之前的部分相连</span></span><br><span class="line">                ((TreeNode&lt;K,V&gt;)rn).prev = rp;</span><br><span class="line">            <span class="keyword">if</span> (rp != <span class="keyword">null</span>)</span><br><span class="line">                rp.next = rn; <span class="comment">//root之前的部分next直接与root之后的部分相连</span></span><br><span class="line">            <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">                first.prev = root; <span class="comment">//first与root相连</span></span><br><span class="line">            root.next = first;</span><br><span class="line">            root.prev = <span class="keyword">null</span>;<span class="comment">//root前驱节点为null</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">checkInvariants</span><span class="params">(root)</span></span>;<span class="comment">//检查红黑树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></li></ol><ol start="4"><li>从当前节点查找key对应的Node<details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//从当前节点查找key，kc缓存了key的class，如果key.class是Comparable的，否则为null</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">find</span><span class="params">(<span class="keyword">int</span> h, Object k, Class&lt;?&gt; kc)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; p = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> ph, dir; K pk;</span><br><span class="line">        TreeNode&lt;K,V&gt; pl = p.left, pr = p.right, q;</span><br><span class="line">        <span class="comment">//如果查找的hash key小于当前hash key，就转向左子树查找</span></span><br><span class="line">        <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">            p = pl;</span><br><span class="line">        <span class="comment">//如果查找的hash key大于当前hash key，就转向右子树查找</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">            p = pr;</span><br><span class="line">        <span class="comment">//hash一致，key一致就表示找到了，直接返回该节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        <span class="comment">//hash一致，key不一致，且左子树为空，直接转向右子树（只可能在右子树）</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pl == <span class="keyword">null</span>)</span><br><span class="line">            p = pr;</span><br><span class="line">        <span class="comment">//hash一致，key不一致，且右子树为空，直接转向左子树（只可能在左子树）</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pr == <span class="keyword">null</span>)</span><br><span class="line">            p = pl;</span><br><span class="line">        <span class="comment">//hash一致，key不一致，且右子树都不为空，但key是可比较的，并且能比较出大小</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((kc != <span class="keyword">null</span> ||</span><br><span class="line">                  (kc = comparableClassFor(k)) != <span class="keyword">null</span>) &amp;&amp;</span><br><span class="line">                 (dir = compareComparables(kc, k, pk)) != <span class="number">0</span>)</span><br><span class="line">            p = (dir &lt; <span class="number">0</span>) ? pl : pr;<span class="comment">//根据key的比较结果决定去那个子树搜索</span></span><br><span class="line">        <span class="comment">//hash一致，key不一致，且右子树都不为空，且key不可比较或无法比较出大小</span></span><br><span class="line">        <span class="comment">//先搜索右子树，如果在右子树中找到key，就返回对应node</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((q = pr.find(h, k, kc)) != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> q;</span><br><span class="line">        <span class="comment">//右子树没找到，接着遍历左子树（为什么不用tieBreakOrder确定查左子树还是右子树？）</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p = pl;</span><br><span class="line">    &#125; <span class="keyword">while</span> (p != <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></li></ol><ol start="5"><li>从root节点开始查询某个key，就是正常的查询<details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">getTreeNode</span><span class="params">(<span class="keyword">int</span> h, Object k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((parent != <span class="keyword">null</span>) ? root() : <span class="keyword">this</span>).find(h, k, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></li></ol><ol start="6"><li><p>深层次比较两个key的大小，调用这个方法就表示发生了<strong>hash碰撞</strong></p><p>注意：<strong>hash碰撞</strong>与<strong>hash地址碰撞</strong>不是一个概念，hash碰撞是指两个key算出来的hash一样，hash碰撞必定会发生hash地址碰撞，但hash地址(hash&amp;(n-1))碰撞只是低x位碰撞，不代表整个hash值一样</p><details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当key的hash值一致(hash碰撞)，且key不可比较时，identityHashCode进行比较，null的hash为0</span></span><br><span class="line"><span class="comment">//identityHashCode总是调用Object实现的hashCode，xx.hashCode是调用重写后的hashCode</span></span><br><span class="line"><span class="comment">//注意：identityHashCode也可能会重复，但概率相当小。</span></span><br><span class="line"><span class="comment">//这里的比较结果分为-1和1，0归到-1里面，所以元素的相对顺序就无法保证了，但没有关系</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">tieBreakOrder</span><span class="params">(Object a, Object b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> d;</span><br><span class="line"><span class="comment">//a或b其中一个是null，或a、b的类型是一样的时候才可比较</span></span><br><span class="line"><span class="keyword">if</span> (a == <span class="keyword">null</span> || b == <span class="keyword">null</span> ||</span><br><span class="line">(d = a.getClass().getName().</span><br><span class="line">compareTo(b.getClass().getName())) == <span class="number">0</span>)</span><br><span class="line">d = (System.identityHashCode(a) &lt;= System.identityHashCode(b) ?</span><br><span class="line">-<span class="number">1</span> : <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></li></ol><ol start="7"><li>树形化操作（以当前节点为root节点）,一般在链表首节点调用该方法<details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//树形化</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeify</span><span class="params">(Node&lt;K,V&gt;[] tab)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; root = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//这里的this实际就是链表的首节点，遍历链表</span></span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; x = <span class="keyword">this</span>, next; x != <span class="keyword">null</span>; x = next) &#123;</span><br><span class="line">        next = (TreeNode&lt;K,V&gt;)x.next;</span><br><span class="line">        x.left = x.right = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//初始化root节点</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            x.parent = <span class="keyword">null</span>;</span><br><span class="line">            x.red = <span class="keyword">false</span>;<span class="comment">//root节点为黑色</span></span><br><span class="line">            root = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            K k = x.key;</span><br><span class="line">            <span class="keyword">int</span> h = x.hash;</span><br><span class="line">            Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//一直遍历，直到找到一个可插入的位置（可插入叶子节点）</span></span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> dir, ph;</span><br><span class="line">                K pk = p.key;</span><br><span class="line">                <span class="comment">//h &lt; ph 走左边</span></span><br><span class="line">                <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                    dir = -<span class="number">1</span>;</span><br><span class="line">                <span class="comment">//h &gt; ph 走右边</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                    dir = <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//h == ph，且(key不可比较，或key比较结果无法区分大小)</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                          (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                         (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>)</span><br><span class="line">                    <span class="comment">//采用identify hashcode再次比较(0和-1合并为-1)</span></span><br><span class="line">                    dir = tieBreakOrder(k, pk);</span><br><span class="line"></span><br><span class="line">                TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">                <span class="comment">//如果x已经到达可以插入的位置，就插入x节点</span></span><br><span class="line">                <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    x.parent = xp;</span><br><span class="line">                    <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                        xp.left = x;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        xp.right = x;</span><br><span class="line">                    <span class="comment">//重新平衡红黑树</span></span><br><span class="line">                    root = balanceInsertion(root, x);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//否则继续查找能插入的位置</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重新平衡树后root节点可能发生了变化，需要重新将叶子节点放到首个节点的位置</span></span><br><span class="line">    moveRootToFront(tab, root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></li></ol><ol start="8"><li>解树形化（红黑树转换为链表）<details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">untreeify</span><span class="params">(HashMap&lt;K,V&gt; map)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt; q = <span class="keyword">this</span>; q != <span class="keyword">null</span>; q = q.next) &#123;</span><br><span class="line">        Node&lt;K,V&gt; p = map.replacementNode(q, <span class="keyword">null</span>);<span class="comment">//节点类型替换一下就可以了</span></span><br><span class="line">        <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">            hd = p;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            tl.next = p;</span><br><span class="line">        tl = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></li></ol><ol start="9"><li>在树中插入一个节点<details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">putTreeVal</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[]tab,<span class="keyword">int</span> h, K k, V v)</span> </span>&#123;</span><br><span class="line">     Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">     <span class="keyword">boolean</span> searched = <span class="keyword">false</span>;</span><br><span class="line">     TreeNode&lt;K,V&gt; root = (parent != <span class="keyword">null</span>) ? root() : <span class="keyword">this</span>;</span><br><span class="line">     <span class="comment">//从root开始遍历，如果key已存在就返回相关节点，否则找到一个合适位置新增一个节点，</span></span><br><span class="line">     <span class="comment">//使得新增节点是叶子节点</span></span><br><span class="line">     <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">         <span class="keyword">int</span> dir, ph; K pk;</span><br><span class="line">         <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">             dir = -<span class="number">1</span>;</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">             dir = <span class="number">1</span>;</span><br><span class="line">         <span class="comment">//key已经存在直接返回，上层方法统一替换value</span></span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">             <span class="keyword">return</span> p;</span><br><span class="line">         <span class="comment">//ph==h 并且key不可比较或无法比较出大小</span></span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                   (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                  (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>) &#123;</span><br><span class="line">             <span class="comment">//搜索左子树&amp;右子树</span></span><br><span class="line">             <span class="keyword">if</span> (!searched) &#123;</span><br><span class="line">                 TreeNode&lt;K,V&gt; q, ch;</span><br><span class="line">                 <span class="comment">//左右子树只需要搜索一次，后续遍历其他节点无需再搜索它们的子树</span></span><br><span class="line">                 searched = <span class="keyword">true</span>;</span><br><span class="line">                 <span class="keyword">if</span> (((ch = p.left) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                      (q = ch.find(h, k, kc)) != <span class="keyword">null</span>) ||</span><br><span class="line">                     ((ch = p.right) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                      (q = ch.find(h, k, kc)) != <span class="keyword">null</span>))</span><br><span class="line">                     <span class="keyword">return</span> q;<span class="comment">//只要找到了key就直接返回</span></span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">//左右子树没找到，准备新追加一个节点，现在判断追加到左子树还是右子树</span></span><br><span class="line">             dir = tieBreakOrder(k, pk);</span><br><span class="line">         &#125;<span class="comment">//if</span></span><br><span class="line"></span><br><span class="line">         <span class="comment">//追加新节点</span></span><br><span class="line">         TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">         <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">             Node&lt;K,V&gt; xpn = xp.next;<span class="comment">//注意这里在进行树的追加操作时仍然保留了双向链表的特性</span></span><br><span class="line">             TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn);</span><br><span class="line">             <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                 xp.left = x;</span><br><span class="line">             <span class="keyword">else</span></span><br><span class="line">                 xp.right = x;</span><br><span class="line">             xp.next = x;</span><br><span class="line">             x.parent = x.prev = xp;</span><br><span class="line">             <span class="keyword">if</span> (xpn != <span class="keyword">null</span>)</span><br><span class="line">                 ((TreeNode&lt;K,V&gt;)xpn).prev = x;</span><br><span class="line">             <span class="comment">//重新平衡树并调整node到首个节点</span></span><br><span class="line">             moveRootToFront(tab, balanceInsertion(root, x));</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></details></li></ol><ol start="10"><li>移除当前节点<details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意：HashMap红黑树具有双向链表和树的两种特性，都要进行调整</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">removeTreeNode</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> index = (n - <span class="number">1</span>) &amp; hash;</span><br><span class="line">    TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index], root = first, rl;</span><br><span class="line">    <span class="comment">//succ为当前节点的后置节点， perd为前驱节点</span></span><br><span class="line">    TreeNode&lt;K,V&gt; succ = (TreeNode&lt;K,V&gt;)next, pred = prev;</span><br><span class="line">    <span class="comment">//如果前驱节点不存在(删除的是root节点)</span></span><br><span class="line">    <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">        tab[index] = first = succ; <span class="comment">//first直接指向root后置节点即可</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pred.next = succ; <span class="comment">//否则前驱节点与后置节点相连即可</span></span><br><span class="line">    <span class="keyword">if</span> (succ != <span class="keyword">null</span>) <span class="comment">//关联prev指针</span></span><br><span class="line">        succ.prev = pred;</span><br><span class="line">    <span class="keyword">if</span> (first == <span class="keyword">null</span>)<span class="comment">//删除的节点不存在</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (root.parent != <span class="keyword">null</span>) </span><br><span class="line">        root = root.root();<span class="comment">//重新找root节点</span></span><br><span class="line">    <span class="comment">//如果root为null或者(允许移动节点，并且左子树或右子树为null)，就转换为链表</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span> || (movable &amp;&amp; (root.right == <span class="keyword">null</span></span><br><span class="line">                                     || (rl = root.left) == <span class="keyword">null</span></span><br><span class="line">                                     || rl.left == <span class="keyword">null</span>))) &#123;</span><br><span class="line">        tab[index] = first.untreeify(map);  <span class="comment">// too small</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//截至到这里，只是调整了作为双向链表的那一部分指针，作为树的相关内容还未进行调整</span></span><br><span class="line">    <span class="comment">//进行红黑树的删除操作，红黑树删除操作分3中情况</span></span><br><span class="line">    TreeNode&lt;K,V&gt; p = <span class="keyword">this</span>, pl = left, pr = right, replacement;</span><br><span class="line">    <span class="comment">//情况1：删除节点左右子树不为null，用后继结点（大于删除结点的最小结点）替换删除结点</span></span><br><span class="line">    <span class="keyword">if</span> (pl != <span class="keyword">null</span> &amp;&amp; pr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; s = pr, sl; <span class="comment">//s是右子节点</span></span><br><span class="line">        <span class="comment">//找到删除节点的后继节点(右子树的最左边叶子节点)</span></span><br><span class="line">        <span class="keyword">while</span> ((sl = s.left) != <span class="keyword">null</span>) <span class="comment">// find successor</span></span><br><span class="line">            s = sl;<span class="comment">//s就是后继节点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//交换s和p的颜色</span></span><br><span class="line">        <span class="keyword">boolean</span> c = s.red; s.red = p.red; p.red = c; <span class="comment">// swap colors</span></span><br><span class="line">        TreeNode&lt;K,V&gt; sr = s.right;</span><br><span class="line">        TreeNode&lt;K,V&gt; pp = p.parent;</span><br><span class="line">        <span class="comment">//s是待删除节点的右子节点，把当前节点挂到s的右子节点（互换位置）</span></span><br><span class="line">        <span class="keyword">if</span> (s == pr) &#123; <span class="comment">// p was s's direct parent（p的右子节点无左子节点）</span></span><br><span class="line">            p.parent = s;</span><br><span class="line">            s.right = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; sp = s.parent;</span><br><span class="line">            <span class="comment">//还是互换s和p的位置，设置部分其他属性</span></span><br><span class="line">            <span class="comment">//如果s是左子节点就把p放到sp的左子节点上，反之亦然</span></span><br><span class="line">            <span class="keyword">if</span> ((p.parent = sp) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s == sp.left)</span><br><span class="line">                    sp.left = p;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    sp.right = p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//s的右子节点指向p的右子节点，p右子节点父指针指向s</span></span><br><span class="line">            <span class="keyword">if</span> ((s.right = pr) != <span class="keyword">null</span>)</span><br><span class="line">                pr.parent = s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//修补s和p交换后断开的节点(pl, pp, sr, root)</span></span><br><span class="line">        p.left = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//p.right = sr;</span></span><br><span class="line">        <span class="keyword">if</span> ((p.right = sr) != <span class="keyword">null</span>)</span><br><span class="line">            sr.parent = p;</span><br><span class="line">        <span class="comment">//s.left = pl; </span></span><br><span class="line">        <span class="keyword">if</span> ((s.left = pl) != <span class="keyword">null</span>)</span><br><span class="line">            pl.parent = s;</span><br><span class="line">        <span class="keyword">if</span> ((s.parent = pp) == <span class="keyword">null</span>)</span><br><span class="line">            root = s; <span class="comment">//s是root</span></span><br><span class="line">        <span class="comment">// s.parent = pp;</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">            pp.left = s;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pp.right = s;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//现在sr已经放到p.right,p.left已经是null了，要删除p，还要处理p.right</span></span><br><span class="line">        <span class="comment">//这里用replacement来填充被删除节点的位置</span></span><br><span class="line">        <span class="keyword">if</span> (sr != <span class="keyword">null</span>)</span><br><span class="line">            replacement = sr;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            replacement = p;<span class="comment">//临时的，p是要删除的</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//情况2：删除节点只有左子节点，直接用左子节点替换待删除节点即可</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pl != <span class="keyword">null</span>)</span><br><span class="line">        replacement = pl;</span><br><span class="line">    <span class="comment">//情况3：删除节点只有左子节点，直接用左子节点替换待删除节点即可</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pr != <span class="keyword">null</span>)</span><br><span class="line">        replacement = pr;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        replacement = p;<span class="comment">//临时的</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果用于替换p位置的内容是有效的(不是p)，就用replacement代替p的位置（真正的删除操作）</span></span><br><span class="line">    <span class="keyword">if</span> (replacement != p) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; pp = replacement.parent = p.parent;</span><br><span class="line">        <span class="keyword">if</span> (pp == <span class="keyword">null</span>)</span><br><span class="line">            root = replacement;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">            pp.left = replacement;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pp.right = replacement;</span><br><span class="line">        p.left = p.right = p.parent = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//考虑替换节点s的颜色(前面和p交换过了，这里用p判断)</span></span><br><span class="line">    <span class="comment">//如果是红色，则不影响树的平衡，直接结束</span></span><br><span class="line">    <span class="comment">//如果是黑色，则需要重新平衡红黑树（这里是整个红黑树删除最复杂的地方）</span></span><br><span class="line">    <span class="comment">//这里返回的r就是新选出来的root节点</span></span><br><span class="line">    TreeNode&lt;K,V&gt; r = p.red ? root : balanceDeletion(root, replacement);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果p无子节点，直接与pp解挂即可</span></span><br><span class="line">    <span class="keyword">if</span> (replacement == p) &#123;  <span class="comment">// detach</span></span><br><span class="line">        TreeNode&lt;K,V&gt; pp = p.parent;</span><br><span class="line">        p.parent = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (pp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">                pp.left = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.right)</span><br><span class="line">                pp.right = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将root放到首节点位置</span></span><br><span class="line">    <span class="keyword">if</span> (movable)</span><br><span class="line">        moveRootToFront(tab, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></li></ol><ol start="11"><li>红黑树的分裂，仅仅会发生在table扩容时，红黑树进行rehash的过程<details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> index, <span class="keyword">int</span> bit)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; b = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// 这里的lo就是低地址未，也就是原位置，hi表示高位置，也就是新地址</span></span><br><span class="line">    <span class="comment">// 由于地址的算法特性，一个旧地址上的节点只可能对应一个新地址</span></span><br><span class="line">    TreeNode&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">    TreeNode&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//遍历整个链表（别忘了红黑树仍保留了双向链表的特性），将一个链表拆成两个链表</span></span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; e = b, next; e != <span class="keyword">null</span>; e = next) &#123;</span><br><span class="line">        next = (TreeNode&lt;K,V&gt;)e.next;</span><br><span class="line">        e.next = <span class="keyword">null</span>;<span class="comment">//与下游解挂</span></span><br><span class="line">        <span class="comment">//需要留在原地的节点</span></span><br><span class="line">        <span class="keyword">if</span> ((e.hash &amp; bit) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                loHead = e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                loTail.next = e;</span><br><span class="line">            loTail = e;</span><br><span class="line">            ++lc;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//需要迁移到新地址的节点</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                hiHead = e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                hiTail.next = e;</span><br><span class="line">            hiTail = e;</span><br><span class="line">            ++hc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果留在原地的链表不为空</span></span><br><span class="line">    <span class="keyword">if</span> (loHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//如果节点数小于树形化阈值，就转换为链表</span></span><br><span class="line">        <span class="keyword">if</span> (lc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">            tab[index] = loHead.untreeify(map);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tab[index] = loHead;</span><br><span class="line">            <span class="comment">//如果有拆分出去的节点，那么留下来的就需要重新树形化</span></span><br><span class="line">            <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) <span class="comment">//hi不为null就表示有拆分出去的节点</span></span><br><span class="line">                loHead.treeify(tab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果新拆分出来的链表不为空，处理方式与lo一致</span></span><br><span class="line">    <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">            tab[index + bit] = hiHead.untreeify(map);<span class="comment">//注意hi地址的计算方式</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tab[index + bit] = hiHead;</span><br><span class="line">            <span class="keyword">if</span> (loHead != <span class="keyword">null</span>)</span><br><span class="line">                hiHead.treeify(tab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></li></ol><ol start="12"><li>红黑树左旋<details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">rotateLeft</span><span class="params">(TreeNode&lt;K,V&gt; root, TreeNode&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; r, pp, rl;</span><br><span class="line">    <span class="comment">//p不为空，p的右子节点(r)不为空，左旋才有意义</span></span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span> &amp;&amp; (r = p.right) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//p的右子节点连接r的左子节点</span></span><br><span class="line">        <span class="keyword">if</span> ((rl = p.right = r.left) != <span class="keyword">null</span>)</span><br><span class="line">            rl.parent = p;</span><br><span class="line">        <span class="comment">//如果p是root，则旋转后r是root，颜色为黑色</span></span><br><span class="line">        <span class="keyword">if</span> ((pp = r.parent = p.parent) == <span class="keyword">null</span>)</span><br><span class="line">            (root = r).red = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//否则，r挂到p的parent(pp)下</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pp.left == p)</span><br><span class="line">            pp.left = r;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pp.right = r;</span><br><span class="line">        <span class="comment">//p成为r的左子节点</span></span><br><span class="line">        r.left = p;</span><br><span class="line">        p.parent = r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></li></ol><ol start="13"><li>红黑树右旋<details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">rotateRight</span><span class="params">(TreeNode&lt;K,V&gt; root, TreeNode&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; l, pp, lr;</span><br><span class="line">    <span class="comment">//l为p的左子节点</span></span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span> &amp;&amp; (l = p.left) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//l的右子节点挂载到p的左子节点位置</span></span><br><span class="line">        <span class="keyword">if</span> ((lr = p.left = l.right) != <span class="keyword">null</span>)</span><br><span class="line">            lr.parent = p;</span><br><span class="line">        <span class="comment">//如果p是root节点，旋转后l是root节点</span></span><br><span class="line">        <span class="keyword">if</span> ((pp = l.parent = p.parent) == <span class="keyword">null</span>)</span><br><span class="line">            (root = l).red = <span class="keyword">false</span>;<span class="comment">//root为黑色</span></span><br><span class="line">        <span class="comment">//否则将l挂载到pp下</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pp.right == p)</span><br><span class="line">            pp.right = l;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pp.left = l;</span><br><span class="line">        <span class="comment">//p成为l的右子节点</span></span><br><span class="line">        l.right = p;</span><br><span class="line">        p.parent = l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></li></ol><ol start="14"><li>平衡插入操作<details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">balanceInsertion</span><span class="params">(TreeNode&lt;K,V&gt; root, TreeNode&lt;K,V&gt; x)</span></span>&#123;</span><br><span class="line">     x.red = <span class="keyword">true</span>;<span class="comment">//新插入的节点为红色</span></span><br><span class="line">     <span class="comment">//一直重复操作，直到红黑树平衡</span></span><br><span class="line">     <span class="keyword">for</span> (TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) &#123;</span><br><span class="line">         <span class="comment">//如果插入的节点就是root</span></span><br><span class="line">         <span class="keyword">if</span> ((xp = x.parent) == <span class="keyword">null</span>) &#123;</span><br><span class="line">             x.red = <span class="keyword">false</span>;<span class="comment">//root为黑色</span></span><br><span class="line">             <span class="keyword">return</span> x;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//如果插入的节点的父节点为黑节点，或父节点是root则无需调整，直接返回</span></span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (!xp.red || (xpp = xp.parent) == <span class="keyword">null</span>)</span><br><span class="line">             <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">         <span class="comment">//如果父节点(xp)是红节点，且父节点是祖父节点(xpp)的左子节点(xppl)</span></span><br><span class="line">         <span class="keyword">if</span> (xp == (xppl = xpp.left)) &#123;</span><br><span class="line">             <span class="comment">//如果叔叔节点(父节点的兄弟节点xppr)存在且为红色</span></span><br><span class="line">             <span class="keyword">if</span> ((xppr = xpp.right) != <span class="keyword">null</span> &amp;&amp; xppr.red) &#123;</span><br><span class="line">                 xppr.red = <span class="keyword">false</span> <span class="comment">//叔叔节点为黑色</span></span><br><span class="line">                     xp.red = <span class="keyword">false</span>;  <span class="comment">//父节点为黑色</span></span><br><span class="line">                 xpp.red = <span class="keyword">true</span>;  <span class="comment">//祖父节点为红色</span></span><br><span class="line">                 x = xpp; <span class="comment">//将祖父节点设为插入节点，继续进行插入平衡操作</span></span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">//叔叔节点不存在或为黑色</span></span><br><span class="line">             <span class="keyword">else</span> &#123;</span><br><span class="line">                 <span class="comment">//插入节点是其父节点的右子节点</span></span><br><span class="line">                 <span class="keyword">if</span> (x == xp.right) &#123;</span><br><span class="line">                     <span class="comment">//对插入节点的父节点进行左旋</span></span><br><span class="line">                     root = rotateLeft(root, x = xp);</span><br><span class="line">                     xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent;</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="comment">//插入节点是左子节点就无需旋转</span></span><br><span class="line">                 <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                     xp.red = <span class="keyword">false</span>;<span class="comment">//父节点设为黑色</span></span><br><span class="line">                     <span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                         xpp.red = <span class="keyword">true</span>;<span class="comment">//祖父节点为红色</span></span><br><span class="line">                         <span class="comment">//对祖父节点进行右旋</span></span><br><span class="line">                         root = rotateRight(root, xpp);</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//如果父节点(xp)是红节点，且父节点是祖父节点(xpp)的右子节点(xppr)</span></span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="comment">//叔叔节点存在且为红色</span></span><br><span class="line">             <span class="keyword">if</span> (xppl != <span class="keyword">null</span> &amp;&amp; xppl.red) &#123;</span><br><span class="line">                 xppl.red = <span class="keyword">false</span>; <span class="comment">//叔叔节点为黑色</span></span><br><span class="line">                 xp.red = <span class="keyword">false</span>;   <span class="comment">//父节点为黑色</span></span><br><span class="line">                 xpp.red = <span class="keyword">true</span>;   <span class="comment">//祖父节点为红色</span></span><br><span class="line">                 x = xpp; <span class="comment">//将祖父节点设为插入节点，继续进行插入平衡操作</span></span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">//叔叔节点不存在或为黑色</span></span><br><span class="line">             <span class="keyword">else</span> &#123;</span><br><span class="line">                 <span class="comment">//插入节点是其父节点的左子节点</span></span><br><span class="line">                 <span class="keyword">if</span> (x == xp.left) &#123;</span><br><span class="line">                     <span class="comment">//将父节点进行右旋,然后进行下面操作</span></span><br><span class="line">                     root = rotateRight(root, x = xp);</span><br><span class="line">                     xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent;</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                     <span class="comment">//父节点为黑色</span></span><br><span class="line">                     xp.red = <span class="keyword">false</span>;</span><br><span class="line">                     <span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                         xpp.red = <span class="keyword">true</span>;<span class="comment">//祖父节点为红色</span></span><br><span class="line">                         <span class="comment">//对祖父节点进行左旋</span></span><br><span class="line">                         root = rotateLeft(root, xpp);</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></details></li></ol><ol start="15"><li>平衡删除操作<details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">balanceDeletion</span><span class="params">(TreeNode&lt;K,V&gt; root,TreeNode&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//一直平衡，直到平衡为止</span></span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; xp, xpl, xpr;;) &#123;</span><br><span class="line">        <span class="comment">//如果替换节点就是root或者null，直接返回root</span></span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span> || x == root)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果日换节点是root节点，颜色设置为黑色，返回替换节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((xp = x.parent) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            x.red = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果替换节点是红色</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x.red) &#123;</span><br><span class="line">            x.red = <span class="keyword">false</span>; <span class="comment">//颜色设置为黑色</span></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//替换节点是黑节点，且替换节点使其父节点的左子节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((xpl = xp.left) == x) &#123;</span><br><span class="line">            <span class="comment">//替换节点的兄弟节点(xpr)是红节点</span></span><br><span class="line">            <span class="keyword">if</span> ((xpr = xp.right) != <span class="keyword">null</span> &amp;&amp; xpr.red) &#123;</span><br><span class="line">                xpr.red = <span class="keyword">false</span>; <span class="comment">//兄弟设为黑色</span></span><br><span class="line">                xp.red = <span class="keyword">true</span>;   <span class="comment">//父节点设为红色</span></span><br><span class="line">                root = rotateLeft(root, xp); <span class="comment">//将P节点左旋</span></span><br><span class="line">                xpr = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果兄弟节点为null，将父节点当作替换节点重新进行平衡操作</span></span><br><span class="line">            <span class="keyword">if</span> (xpr == <span class="keyword">null</span>)</span><br><span class="line">                x = xp;</span><br><span class="line">            <span class="comment">//兄弟节点存在，且为黑色</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; sl = xpr.left, sr = xpr.right;</span><br><span class="line">                <span class="comment">//兄弟节点的子节点都为黑节点</span></span><br><span class="line">                <span class="keyword">if</span> ((sr == <span class="keyword">null</span> || !sr.red) &amp;&amp;</span><br><span class="line">                    (sl == <span class="keyword">null</span> || !sl.red)) &#123;</span><br><span class="line">                    xpr.red = <span class="keyword">true</span>; <span class="comment">// 兄弟节点设为红色</span></span><br><span class="line">                    x = xp; <span class="comment">//将父节点当作替换节点重新进行平衡操作</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//如果兄弟节点的右子节点为黑色（左子节点为红色）</span></span><br><span class="line">                    <span class="keyword">if</span> (sr == <span class="keyword">null</span> || !sr.red) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (sl != <span class="keyword">null</span>)</span><br><span class="line">                            sl.red = <span class="keyword">false</span>; <span class="comment">//兄弟节点的左子节点设为黑色</span></span><br><span class="line">                        xpr.red = <span class="keyword">true</span>;     <span class="comment">//兄弟节点设为红色</span></span><br><span class="line">                        root = rotateRight(root, xpr); <span class="comment">//对兄弟节点进行右旋</span></span><br><span class="line">                        xpr = (xp = x.parent) == <span class="keyword">null</span> ?</span><br><span class="line">                            <span class="keyword">null</span> : xp.right;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//兄弟节点的右子节点是红色，左子节点任意</span></span><br><span class="line">                    <span class="keyword">if</span> (xpr != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//兄弟节点的颜色设为父亲节点的颜色</span></span><br><span class="line">                        xpr.red = (xp == <span class="keyword">null</span>) ? <span class="keyword">false</span> : xp.red;</span><br><span class="line">                        <span class="keyword">if</span> ((sr = xpr.right) != <span class="keyword">null</span>)</span><br><span class="line">                            sr.red = <span class="keyword">false</span>;<span class="comment">//兄弟节点的右子节点设为黑色</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        xp.red = <span class="keyword">false</span>; <span class="comment">//父亲节点设为黑色</span></span><br><span class="line">                        root = rotateLeft(root, xp);<span class="comment">//对父亲节点进行左旋</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    x = root;<span class="comment">//结束平衡操作</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//替换节点是黑节点，且替换节点使其父节点的右子节点（操作与上一个IF是对称的）</span></span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// symmetric</span></span><br><span class="line">            <span class="comment">//兄弟节点存在且是红色</span></span><br><span class="line">            <span class="keyword">if</span> (xpl != <span class="keyword">null</span> &amp;&amp; xpl.red) &#123;</span><br><span class="line">                xpl.red = <span class="keyword">false</span>; <span class="comment">//兄弟节点设为黑色</span></span><br><span class="line">                xp.red = <span class="keyword">true</span>;   <span class="comment">//父节点为红色</span></span><br><span class="line">                root = rotateRight(root, xp); <span class="comment">//按父节点右旋</span></span><br><span class="line">                xpl = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//兄弟节点为空，就把父节点当作替换节点重新平衡</span></span><br><span class="line">            <span class="keyword">if</span> (xpl == <span class="keyword">null</span>)</span><br><span class="line">                x = xp;</span><br><span class="line">            <span class="comment">//兄弟节点是黑节点</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; sl = xpl.left, sr = xpl.right;</span><br><span class="line">                <span class="comment">//兄弟节点的左子节点全是黑色</span></span><br><span class="line">                <span class="keyword">if</span> ((sl == <span class="keyword">null</span> || !sl.red) &amp;&amp;</span><br><span class="line">                    (sr == <span class="keyword">null</span> || !sr.red)) &#123;</span><br><span class="line">                    xpl.red = <span class="keyword">true</span>; <span class="comment">//兄弟节点设为红色</span></span><br><span class="line">                    x = xp; <span class="comment">//父节点为替换节点重新进行平衡操作</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//兄弟节点左子节点为黑色（右子节点为红色）</span></span><br><span class="line">                    <span class="keyword">if</span> (sl == <span class="keyword">null</span> || !sl.red) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (sr != <span class="keyword">null</span>)</span><br><span class="line">                            sr.red = <span class="keyword">false</span>; <span class="comment">//兄弟节点右子节点设为黑色</span></span><br><span class="line">                        xpl.red = <span class="keyword">true</span>; <span class="comment">//兄弟节点设为红色</span></span><br><span class="line">                        root = rotateLeft(root, xpl);<span class="comment">//对兄弟节点进行左旋</span></span><br><span class="line">                        xpl = (xp = x.parent) == <span class="keyword">null</span> ?</span><br><span class="line">                            <span class="keyword">null</span> : xp.left;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//兄弟节点的左子节点是红色，右子节点任意</span></span><br><span class="line">                    <span class="keyword">if</span> (xpl != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//将兄弟节点颜色设为父节点颜色</span></span><br><span class="line">                        xpl.red = (xp == <span class="keyword">null</span>) ? <span class="keyword">false</span> : xp.red;</span><br><span class="line">                        <span class="keyword">if</span> ((sl = xpl.left) != <span class="keyword">null</span>)z</span><br><span class="line">                            sl.red = <span class="keyword">false</span>; <span class="comment">//兄弟节点左子节点设为黑色</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        xp.red = <span class="keyword">false</span>; <span class="comment">//父节点设为黑色</span></span><br><span class="line">                        root = rotateRight(root, xp); <span class="comment">//对父节点右旋</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    x = root; <span class="comment">//结束平衡操作</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></li></ol><ol start="16"><li>红黑树自检<details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">checkInvariants</span><span class="params">(TreeNode&lt;K,V&gt; t)</span> </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; tp = t.parent, tl = t.left, tr = t.right,</span><br><span class="line">    tb = t.prev, tn = (TreeNode&lt;K,V&gt;)t.next;</span><br><span class="line">    <span class="comment">//如果t的前驱节点的后置节点不是t，检查失败</span></span><br><span class="line">    <span class="keyword">if</span> (tb != <span class="keyword">null</span> &amp;&amp; tb.next != t)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//如果t的后置节点的前驱节点不是t，检查失败</span></span><br><span class="line">    <span class="keyword">if</span> (tn != <span class="keyword">null</span> &amp;&amp; tn.prev != t)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//如果t不是其父节点的左子节点也不是右子节点，检查失败</span></span><br><span class="line">    <span class="keyword">if</span> (tp != <span class="keyword">null</span> &amp;&amp; t != tp.left &amp;&amp; t != tp.right)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//如果t的左子节点的父亲不是t，或左子节点hash大于t的hash，检查失败</span></span><br><span class="line">    <span class="keyword">if</span> (tl != <span class="keyword">null</span> &amp;&amp; (tl.parent != t || tl.hash &gt; t.hash))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//如果t的右子节点的父亲不是t，或右子节点hash小于t的hash，检查失败</span></span><br><span class="line">    <span class="keyword">if</span> (tr != <span class="keyword">null</span> &amp;&amp; (tr.parent != t || tr.hash &lt; t.hash))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//如果t是红色但子节点还是红色，检查失败</span></span><br><span class="line">    <span class="keyword">if</span> (t.red &amp;&amp; tl != <span class="keyword">null</span> &amp;&amp; tl.red &amp;&amp; tr != <span class="keyword">null</span> &amp;&amp; tr.red)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//递归检查左子树</span></span><br><span class="line">    <span class="keyword">if</span> (tl != <span class="keyword">null</span> &amp;&amp; !checkInvariants(tl))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//递归检查右子树</span></span><br><span class="line">    <span class="keyword">if</span> (tr != <span class="keyword">null</span> &amp;&amp; !checkInvariants(tr))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></li></ol><h1 id="四、其他方法"><a href="#四、其他方法" class="headerlink" title="四、其他方法"></a>四、其他方法</h1><ol><li>Clone方法重写<details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//浅拷贝</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HashMap&lt;K,V&gt; result;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        result = (HashMap&lt;K,V&gt;)<span class="keyword">super</span>.clone();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">        <span class="comment">// this shouldn't happen, since we are Cloneable</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e);</span><br><span class="line">    &#125;</span><br><span class="line">    result.reinitialize();</span><br><span class="line">    result.putMapEntries(<span class="keyword">this</span>, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></li></ol><ol start="2"><li>序列化、反序列化相关方法<details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// These methods are also used when serializing HashSets</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">float</span> <span class="title">loadFactor</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> loadFactor; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">capacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (table != <span class="keyword">null</span>) ? table.length :</span><br><span class="line">    (threshold &gt; <span class="number">0</span>) ? threshold :</span><br><span class="line">    DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//序列化</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> buckets = capacity();</span><br><span class="line">    <span class="comment">// Write out the threshold, loadfactor, and any hidden stuff</span></span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line">    s.writeInt(buckets);</span><br><span class="line">    s.writeInt(size);</span><br><span class="line">    internalWriteEntries(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//反序列化</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="comment">// Read in the threshold (ignored), loadfactor, and any hidden stuff</span></span><br><span class="line">    s.defaultReadObject();</span><br><span class="line">    reinitialize();</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                         loadFactor);</span><br><span class="line">    s.readInt();                <span class="comment">// Read and ignore number of buckets</span></span><br><span class="line">    <span class="keyword">int</span> mappings = s.readInt(); <span class="comment">// Read number of mappings (size)</span></span><br><span class="line">    <span class="keyword">if</span> (mappings &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(<span class="string">"Illegal mappings count: "</span> +</span><br><span class="line">                                         mappings);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (mappings &gt; <span class="number">0</span>) &#123; <span class="comment">// (if zero, use defaults)</span></span><br><span class="line">        <span class="comment">// Size the table using given load factor only if within</span></span><br><span class="line">        <span class="comment">// range of 0.25...4.0</span></span><br><span class="line">        <span class="keyword">float</span> lf = Math.min(Math.max(<span class="number">0.25f</span>, loadFactor), <span class="number">4.0f</span>);</span><br><span class="line">        <span class="keyword">float</span> fc = (<span class="keyword">float</span>)mappings / lf + <span class="number">1.0f</span>;</span><br><span class="line">        <span class="keyword">int</span> cap = ((fc &lt; DEFAULT_INITIAL_CAPACITY) ?</span><br><span class="line">                   DEFAULT_INITIAL_CAPACITY :</span><br><span class="line">                   (fc &gt;= MAXIMUM_CAPACITY) ?</span><br><span class="line">                   MAXIMUM_CAPACITY :</span><br><span class="line">                   tableSizeFor((<span class="keyword">int</span>)fc));</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)cap * lf;</span><br><span class="line">        threshold = ((cap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; MAXIMUM_CAPACITY) ?</span><br><span class="line">                     (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check Map.Entry[].class since it's the nearest public type to</span></span><br><span class="line">        <span class="comment">// what we're actually creating.</span></span><br><span class="line">        SharedSecrets.getJavaOISAccess().checkArray(s, Map.Entry[].class, cap);</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">        Node&lt;K,V&gt;[] tab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[cap];</span><br><span class="line">        table = tab;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// Read the keys and values, and put the mappings in the HashMap</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mappings; i++) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            K key = (K) s.readObject();</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            V value = (V) s.readObject();</span><br><span class="line">            putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Called only from writeObject, to ensure compatible ordering.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">internalWriteEntries</span><span class="params">(java.io.ObjectOutputStream s)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab;</span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span> &amp;&amp; (tab = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                s.writeObject(e.key);</span><br><span class="line">                s.writeObject(e.value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reset to initial default state.  Called by clone and readObject.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reinitialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    table = <span class="keyword">null</span>;</span><br><span class="line">    entrySet = <span class="keyword">null</span>;</span><br><span class="line">    keySet = <span class="keyword">null</span>;</span><br><span class="line">    values = <span class="keyword">null</span>;</span><br><span class="line">    modCount = <span class="number">0</span>;</span><br><span class="line">    threshold = <span class="number">0</span>;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details></li></ol><ol start="3"><li>回调方法，在HashMap中无作用，为LinkedHashMap做铺垫<details><summary style="color:blue">点击展开代码</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Callbacks to allow LinkedHashMap post-actions</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure></details></li></ol><p>源码阅读.md<br><a href="/2019/12/29/hashmap-source-learning/HashMap.txt"> 点击下载</a></p>]]></content>
    
    <summary type="html">
    
      HashMap源码全解析。本次以Oracle JDK1.8作为示例，深入解读HashMap实现原理，精细阅读每一行源码，并结合各互联网厂商的常见面试问题，对HashMap的实现方案、思想以及使用注意事项做深入探讨。
    
    </summary>
    
      <category term="Java" scheme="https://blog.zjee.ml/categories/Java/"/>
    
    
      <category term="Java源码" scheme="https://blog.zjee.ml/tags/Java%E6%BA%90%E7%A0%81/"/>
    
      <category term="HashMap" scheme="https://blog.zjee.ml/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>Java基本类型与包装类型</title>
    <link href="https://blog.zjee.ml/2019/11/19/java-primitive-and-wrapper-type/"/>
    <id>https://blog.zjee.ml/2019/11/19/java-primitive-and-wrapper-type/</id>
    <published>2019-11-19T09:06:49.000Z</published>
    <updated>2019-11-19T09:06:49.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、Java中的数据类型"><a href="#一、Java中的数据类型" class="headerlink" title="一、Java中的数据类型"></a>一、Java中的数据类型</h3><p>熟悉Java的朋友都知道Java中的数据类型分为<strong>基本类型</strong>和<strong>引用类型</strong>，基本类型就是我们日常使用的<code>int</code>，<code>long</code>等，引用类型就是用class定义出来的类型，如<code>String</code>、<code>HashMap</code>等。Java中有8种基本数据类型，它们同时都对应一个引用数据类型（又称<strong>包装类型</strong>），具体内容如下：</p><table><thead><tr><th align="center">基本类型</th><th align="center">占用空间</th><th align="center">取值范围</th><th align="center">包装类型</th></tr></thead><tbody><tr><td align="center">byte</td><td align="center">1B</td><td align="center">$-2^{7}$ ~ $2^{7}-1$</td><td align="center">java.lang.Byte</td></tr><tr><td align="center">char</td><td align="center">2B (unicode)</td><td align="center">$0$ ~ $2^{16}-1$</td><td align="center">java.lang.Character</td></tr><tr><td align="center">short</td><td align="center">2B</td><td align="center">$-2^{15}$ ~ $2^{15}-1$</td><td align="center">java.lang.Short</td></tr><tr><td align="center">int</td><td align="center">4B</td><td align="center">$-2^{31}$ ~ ${2^{31}-1}$</td><td align="center">java.lang.Integer</td></tr><tr><td align="center">long</td><td align="center">8B</td><td align="center">$-2^{63}$ ~ $2^{63}-1$</td><td align="center">java.lang.Long</td></tr><tr><td align="center">float</td><td align="center">4B</td><td align="center">参见<a href="https://zh.wikipedia.org/wiki/IEEE_754" target="_blank" rel="noopener">IEEE754</a></td><td align="center">java.lang.Float</td></tr><tr><td align="center">double</td><td align="center">8B</td><td align="center">参见<a href="https://zh.wikipedia.org/wiki/IEEE_754" target="_blank" rel="noopener">IEEE754</a></td><td align="center">java.lang.Double</td></tr><tr><td align="center">boolean</td><td align="center">1B</td><td align="center">${True, False}$</td><td align="center">java.lang.Boolean</td></tr></tbody></table><h3 id="二、自动装箱与拆箱"><a href="#二、自动装箱与拆箱" class="headerlink" title="二、自动装箱与拆箱"></a>二、自动装箱与拆箱</h3><p>Java是一个纯面向对象的语言，为了让基本数据类型也拥有引用类型的特征（比如取null值），Java工程师特意为他们设计了包装类型。包装类型简单来说就是用一个class声明的类将基本类型包装了一下，并附带了很多常用工具，这样我们就能按面向对象的方式去使用基本数据类型了。下面是Integer类的部分源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Integer</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_VALUE = -<span class="number">2147483648</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_VALUE = <span class="number">2147483647</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//核心内容</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> value;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//构造方法    </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Integer</span><span class="params">(<span class="keyword">int</span> var1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = var1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//装箱方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> var0)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> var0 &gt;= -<span class="number">128</span> &amp;&amp; var0 &lt;= Integer.IntegerCache.high ?                      Integer.IntegerCache.cache[var0 + <span class="number">128</span>] : <span class="keyword">new</span> Integer(var0);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//拆箱方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">intValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Integer缓存</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            <span class="comment">// high value may be configured by property</span></span><br><span class="line">            <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">            String integerCacheHighPropValue =</span><br><span class="line">                sun.misc.VM.getSavedProperty(<span class="string">"java.lang.Integer.IntegerCache.high"</span>);</span><br><span class="line">            <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class="line">                    i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">                    <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">                    h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">                    <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            high = h;</span><br><span class="line">            cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> j = low;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">                cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line">            <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">            <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们从源码中可以看到包装类型中保存数据的核心成员变量就是<code>value</code>，所有对包装类型的操作最终都反映到value字段上。包装类型中的<code>valueOf</code>方法（有多种重载）就是常说的装箱方法，使用该方法可以将一个基本类型变量转变为包装类型，如<code>Integer a = Integer.valueOf(2);</code>。同样，<code>intValue</code>方法（有多种变形，如<code>longValue</code>、<code>charValue</code>等）就是拆箱方法，它可以将包装类型转变为基本类型，如<code>int b = a.intValue();</code> 。早期的Java中基本类型与包装类型的转换是需要开发人员手工去调用方法实现的，自JDK 5.0开发，Java引入了自动装箱和拆箱机制，极大的方便了开发人员，自动装箱与拆箱简单说就是JVM自动去调用<code>valueOf</code>和<code>intValue</code>方法，于是我们的代码就可以这样写了<code>int a = new Integer(1); Integer b = 4;</code>。</p><h3 id="问题拓展"><a href="#问题拓展" class="headerlink" title="问题拓展"></a><strong>问题拓展</strong></h3><p>我们知道在C/C++中写一个可以交换两个int变量值的函数，如下所示，那在Java中怎么实现这样一个方法呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C(通过指针交换)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span>* b)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> c = *a;</span><br><span class="line">*a = *b;</span><br><span class="line">*b = c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//C++(通过引用交换)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>&amp; a, <span class="keyword">int</span>&amp; b)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> c = a;</span><br><span class="line">a = b;</span><br><span class="line">b = c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java中没有指针，但有对象引用（与C/C++中的指针概念类似），我们可以利用此概念实现同样的功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Integer a = <span class="keyword">new</span> Integer(<span class="number">1</span>); <span class="comment">//不能用自动装箱</span></span><br><span class="line">        Integer b = <span class="keyword">new</span> Integer(<span class="number">2</span>); <span class="comment">//不能用自动装箱</span></span><br><span class="line">        swap(a, b);</span><br><span class="line">        System.out.println(<span class="string">"a="</span>+a+<span class="string">", b="</span>+b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swapa</span><span class="params">(Integer a, Integer b)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> c = a;<span class="comment">//暂存a的值(使用自动拆箱)</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//通过反射的方式强行更改value</span></span><br><span class="line">        Field field = a.getClass().getDeclaredField(<span class="string">"value"</span>);</span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        field.set(a, b);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过反射的方式强行更改value</span></span><br><span class="line">        field = b.getClass().getDeclaredField(<span class="string">"value"</span>);</span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        field.set(b, c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 输出：a=2, b=1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>上面的代码可以实现值的交换，但存在一些限制：</p><ol><li>实参和形参都必须是包装类型，因为只有包装类型传参时是传引用（相当与C/C++中的指针）。</li><li><span style="color:red;">实参不能使用自动装箱生成，如<code>Integer a = 100;</code>。</span></li><li>效率不高。</li></ol><p>下面我们看一下为什么不能使用自动装箱，首先看一下自动装箱的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> var0)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> var0 &gt;= -<span class="number">128</span> &amp;&amp; var0 &lt;= Integer.IntegerCache.high ?                      Integer.IntegerCache.cache[var0 + <span class="number">128</span>] : <span class="keyword">new</span> Integer(var0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到如果自动装箱的值在<code>[-128, high]</code>（<code>high∈[127, Integer.MAX_VALUE-129]</code>）,就会返回<code>Integer.IntegerCache.cache[var0 + 128]</code>这样一个值，其中的<code>Integer.IntegerCache.cache</code>就是我们提到的<strong>缓存</strong>，在Integer中缓存默认范围是[-128， 127]，也就是说这个范围类的数字对应的包装对象在加载Integer类的时候都已经生成好了，以后谁要采用自动装箱获取Integer对象，只要值在缓存范围内，就直接返回缓存对象即可。</p><p>在上面的swap示例中，如果传入的实参是采用自动装箱生成的，且数值范围在缓存范围内，就会将<strong>缓存的引用</strong>传入swap方法中，然后用<strong>反射修改的就是这些缓存的值</strong>。最终，我们最初的问题是解决了，但接着会带来更大的麻烦，示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Integer a = <span class="number">1</span>;</span><br><span class="line">        Integer b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        swap(a, b);</span><br><span class="line">        System.out.println(<span class="string">"a="</span>+a+<span class="string">", b="</span>+b);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//!!! Big trouble !!!</span></span><br><span class="line">        System.out.println(<span class="string">"Integer.valueOf(1) = "</span> + Integer.valueOf(<span class="number">1</span>)); <span class="comment">//缓存被修改了</span></span><br><span class="line">        System.out.println(<span class="string">"(Integer)2 = "</span> + (Integer)<span class="number">2</span>);<span class="comment">//缓存被修改了</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Integer a, Integer b)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Integer c = <span class="keyword">new</span> Integer(a); <span class="comment">//原始值进行深度拷贝</span></span><br><span class="line"></span><br><span class="line">        Field field = a.getClass().getDeclaredField(<span class="string">"value"</span>);</span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        field.set(a, b);</span><br><span class="line"></span><br><span class="line">        field = b.getClass().getDeclaredField(<span class="string">"value"</span>);</span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        field.set(b, c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 输出：</span></span><br><span class="line"><span class="comment">* a=2, b=1</span></span><br><span class="line"><span class="comment">* Integer.valueOf(1) = 2</span></span><br><span class="line"><span class="comment">* (Integer)2 = 1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>☠ 我们看到由于直接修改了<code>1</code>和<code>2</code>缓存，后续所有用到这两个缓存的值将全部出错，这是一种很危险的行为。</p><p><strong><em>忠告</em></strong>：在java中上诉两种交换值的方式请都<strong>不要使用</strong>，如果有此类需求，可以考虑以下方案：</p><ul><li>不使用方法，直接就地解决。</li><li>使用方法，把原始两个参数合并成list或数组传入swap方法</li><li>使用方法，把原始数据包装进一个对象中传入swap方法</li></ul><h3 id="三、Java基本数据类型缓存"><a href="#三、Java基本数据类型缓存" class="headerlink" title="三、Java基本数据类型缓存"></a>三、Java基本数据类型缓存</h3><p>在Java5中，为节省内存提高性能，除Float和Double之外，所有基本类型的包装类型都引入了缓存，一般缓存[-128, 127]（Charactor是[0, 127]）之间的所有包装类对象。这些缓存在对应类加载的时候都完成了初始化，后续使用时如果用到自动装箱且数值在缓存范围内，则直接返回缓存对象。</p><p>Integer的缓存范围上界是可调整的（也是唯一可调范围的类型），在JVM启动参数中加入<code>-XX:AutoBoxCacheMax=&lt;size&gt;</code>调整Integer缓存范围。其中<code>size</code>的可取范围是[127, 2147483518]，如果不在此范围就取该范围的边界值。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Integer a = <span class="number">100</span>; <span class="comment">//use cache</span></span><br><span class="line">Integer b = Integer.valueOf(-<span class="number">128</span>); <span class="comment">//use cache</span></span><br><span class="line">Integer c = Integer.valueOf(<span class="string">"23"</span>); <span class="comment">//use cache</span></span><br><span class="line">Integer d = <span class="keyword">new</span> Integer(<span class="number">23</span>);<span class="comment">// not use cache</span></span><br><span class="line">Integer e = <span class="number">7367</span>; <span class="comment">//not use cache by default</span></span><br></pre></td></tr></table></figure><h3 id="四、延申思考"><a href="#四、延申思考" class="headerlink" title="四、延申思考"></a>四、延申思考</h3><h4 id="4-1-方法重载优先级"><a href="#4-1-方法重载优先级" class="headerlink" title="4.1 方法重载优先级"></a>4.1 方法重载优先级</h4><p>问题如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;&#125; <span class="comment">//m1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Integer a, <span class="keyword">int</span> b)</span></span>&#123;&#125; <span class="comment">//m2</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a, Integer b)</span></span>&#123;&#125; <span class="comment">//m3</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Integer a, Integer b)</span></span>&#123;&#125; <span class="comment">//m4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line">swap(<span class="number">2</span>, <span class="number">3</span>); <span class="comment">//调用m1</span></span><br><span class="line">swap((Integer)<span class="number">2</span>, <span class="number">3</span>); <span class="comment">//调用m2</span></span><br><span class="line">swap((Integer)<span class="number">2</span>, (Integer)<span class="number">3</span>); <span class="comment">//调用m4</span></span><br></pre></td></tr></table></figure><p>java在重载的时候优先按相同类型精确匹配，当匹配不上时再尝试包装类型，但是将包装类型和基本类型混用时旧需要明确指定类型，否则会导致编译失败。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a, Integer b)</span></span>&#123;&#125; <span class="comment">//m3</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Integer a, Integer b)</span></span>&#123;&#125; <span class="comment">//m4</span></span><br><span class="line"></span><br><span class="line">swap(<span class="number">2</span>, <span class="number">3</span>); <span class="comment">// compile error</span></span><br><span class="line">swap((Integer)<span class="number">2</span>, <span class="number">3</span>); <span class="comment">// compile error</span></span><br><span class="line">swap((Integer)<span class="number">2</span>, (Integer)<span class="number">3</span>); <span class="comment">//m4 ok</span></span><br><span class="line">swap(<span class="number">3</span>, (Integer)<span class="number">4</span>);<span class="comment">//m3 ok</span></span><br></pre></td></tr></table></figure><h4 id="4-2泛型"><a href="#4-2泛型" class="headerlink" title="4.2泛型"></a>4.2泛型</h4><p>java中泛型不支持基本数据类型，即<code>int</code>,<code>float</code>这样的，但数组是个例外，数据在java中是个对象，不过这个对象没有明确的class，我们可像操作对象一样操作数组，所以泛型是可以接收数组的，示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list1 = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">// ok</span></span><br><span class="line">List&lt;<span class="keyword">int</span>[]&gt; list2 = <span class="keyword">new</span> ArrayList&lt;&gt;();   <span class="comment">// also ok</span></span><br><span class="line">List&lt;<span class="keyword">int</span>&gt; list3 = <span class="keyword">new</span> ArrayList&lt;&gt;();     <span class="comment">// compile error</span></span><br></pre></td></tr></table></figure><p>我们日常开发中有一个数组转List的工具用的特别多，它就是<code>Arrays.asList(T... a)</code>，这个方法接收可变参数，我们知道可变参数可以传多个参数或一个数组，当传数组的时候需要注意，泛型会将int[]视为一个整体，也就是说这里传<code>new Integer[]{1,2,3}</code>与<code>new int[]{1,2,3}</code>是不一样的。对于前者来说，相当于传入3个<code>Integer</code>参数，最后接收方收到的参数长度为3。而后者相当于传入一个类型为<code>int[]</code>的参数，接收方收到的参数长度为1。因此，我们在使用<code>Arrays.asList</code>的时候要特别注意用包装类型而不是基本类型。</p>]]></content>
    
    <summary type="html">
    
      用了很久的Java，偶然闲谈中才发现自己竟然说不明白Java的基本类型与包装类型的关系，深感愧疚，便写下此篇文章，给自己长个记性。本文涉及的内容：Java基本类型与包装类型的区别及联系、自动装箱与拆箱、包装类型缓存及其它问题的思考。
    
    </summary>
    
      <category term="Java" scheme="https://blog.zjee.ml/categories/Java/"/>
    
    
      <category term="Java" scheme="https://blog.zjee.ml/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java中的同步、互斥机制</title>
    <link href="https://blog.zjee.ml/2019/08/24/java-lock-util/"/>
    <id>https://blog.zjee.ml/2019/08/24/java-lock-util/</id>
    <published>2019-08-23T16:00:00.000Z</published>
    <updated>2019-08-23T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>在Java多线程编程中，同步和互斥是一个不可避免的话题。Java为开发人员提供了以下几种锁机制：</p><ol><li><code>synchronized</code>关键字</li><li><code>Lock</code>接口</li><li><code>ReadWriteLock</code>接口</li></ol><p>这几种锁机制在日常编程中用的很多，但它们有什么联系和区别呢？</p><h3 id="一、Synchronized"><a href="#一、Synchronized" class="headerlink" title="一、Synchronized"></a>一、Synchronized</h3><ol><li><p><code>synchronized</code>关键字是Java内置的关键字，可以轻松实现临界区资源的同步互斥访问。synchronized关键字使用很简单，可以加在方法上或代码块上，用在方法声明中表示整个方法调用是互斥的，用在代码块上表示被包围的代码执行是互斥的，示例如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consumer1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//synchronize 用在代码块上，表示该代码块互斥</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123; </span><br><span class="line">        resource -- ;</span><br><span class="line">        System.out.println(<span class="string">" resource: "</span> + resource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="comment">//synchronize用在方法上，表示整个方法调用互斥</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">consumer2</span><span class="params">()</span></span>&#123; </span><br><span class="line">    resource -- ;</span><br><span class="line">    System.out.println(<span class="string">"resource: "</span> + resource);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//synchronize用在静态方法上，使用Class对象作为对象锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">consumer3</span><span class="params">()</span></span>&#123; </span><br><span class="line">    resource -- ;</span><br><span class="line">    System.out.println(<span class="string">"resource: "</span> + resource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>synchronized</code>关键字需要一个<strong>锁对象</strong>,当代码执行到synchronized修饰的方法或包围的代码块时就会获取该锁对象的锁，本质上就是获取锁对象的监视器(monitor，可以理解为锁标记)，如果获取到锁就继续执行临界区代码，否则就一直等待。如果<code>synchronized</code>修饰的是一个<strong>非静态</strong>方法，那么锁对象就是这个<strong>对象本身</strong>；如果<code>synchronized</code>修饰的是一个<strong>静态</strong>方法，那么锁对象就是这个<strong>类对象</strong>。同理，我们在使用synchronized代码块时，需要提供一个锁对象，一般可用<code>this</code>表示使用对象本身作为锁对象，当然也可以使用其他自定义对象，比如 <code>new Object()</code>。这里需要注意一点，不要使用<code>String</code>或常用的数字对象去作为锁对象，因为他们在JVM缓存在一个常量池中，是一个共享对象，如果多处使用这些对象作为锁对象，可能会导致不可预期的死锁。</p></li><li><p><strong>可重入</strong>是锁的一个重要特性，它是指一个线程重复获取获取它<strong><em>已经拥有的锁</em></strong>，如果可以获取到则表示该锁是<strong>可重入</strong>的，否则就是<strong>不可重入</strong>的。<code>synchronized</code>是<strong>可重入</strong>的，示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> resource = <span class="number">100</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        test.consumer1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">consumer1</span><span class="params">()</span> </span>&#123; <span class="comment">//第一次获取锁</span></span><br><span class="line">        resource--;</span><br><span class="line">        System.out.println(<span class="string">"consumer1: "</span> + resource);</span><br><span class="line">        <span class="keyword">this</span>.consumer2(); <span class="comment">//调用另外一个synchronized修饰的方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">consumer2</span><span class="params">()</span> </span>&#123; <span class="comment">//第二次获取锁</span></span><br><span class="line">        resource--;</span><br><span class="line">        System.out.println(<span class="string">"consumer2: "</span> + resource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 输出：</span></span><br><span class="line"><span class="comment"> * consumer1: 99</span></span><br><span class="line"><span class="comment"> * consumer2: 98</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></li><li><p><code>synchronized</code>是<strong>不可中断</strong>的，当一个线程因获取不到锁而进入阻塞状态时，这个线程就一直会阻塞下去，不会响应外界的中断信号，这也是synchronize的最大缺陷。</p></li><li><p>总结：</p><ul><li>synchronized优点：使用简单，速度快(JVM底层支持，编译后会形成<code>monitorenter</code>、<code>monitorenter</code>两条指令)，自动释放锁，保证了互斥性和变量修改的可见性（一个线程对变量的修改对其他线程立即可见）。</li><li>synchronized缺点：synchronized获取锁的过程无法被中断，也不能尝试非阻塞、超时返回等策略获取锁，这在高并发环境下将会带来很大的性能损失。</li></ul></li></ol><h3 id="二、Lock"><a href="#二、Lock" class="headerlink" title="二、Lock"></a>二、Lock</h3><ol><li><p>Lock是Java5开始提供的一个JDK层面的用于控制同步互斥的接口，它位于<code>java.util.concurrent.locks</code>包下。此外，该包下还有Condition和ReadWriteLock两兄弟，它们都是为多线程同步、互斥服务的，其类图如下：</p><img src="/2019/08/24/java-lock-util/001.png" title="Lock家族类图"><p>我们可以看到Lock接口下一般供开发人员直接使用的实现是<code>ReentrantLock</code>，这个类基本解决了<code>synchronized</code>存在的不足，我们看一下Lock接口提供的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">    <span class="comment">//开始获取锁(进入临界区,阻塞方法)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>; </span><br><span class="line">    <span class="comment">//开始获取锁，同时可以响应中断事件，可在捕获InterruptedException异常后做后续处理(阻塞方法)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>; </span><br><span class="line">    <span class="comment">//尝试获取锁，无论成功或失败都立即返回(非阻塞)</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//尝试获取锁，如果成功立即返回，否则等待给定时间后返回，并且等待中还可以响应中断事件</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> var1, TimeUnit var3)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="comment">//释放锁</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//条件变量，用于线程间通信及同步协作(生产者、消费者模型会用到)</span></span><br><span class="line">    <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过Lock接口提供的方法我们看到Lock锁更加细粒度化，它可以让开发人员根据实际需求灵活处理获取锁期间的等待行为。使用Lock一定要<strong>手动释放锁</strong>，这是很重要的一点，如果处理不慎将会导致不可预期的死锁，一般为了可靠释放锁，会将unlock调用放在<code>finally</code>块中。</p></li><li><p>说完Lock接口我们来看一下它的实现<code>ReentrantLock</code>，从字面上就知道这个锁是一个<strong>可重入的</strong>，下面是该类提供的方法（仅列举部分方法）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//构造方法，默认非公平锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="comment">//构造方法，传入一个boolean值指定是否需要公平锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> var1)</span> </span>&#123;...&#125;</span><br><span class="line"><span class="comment">//获取当前线程对该锁的持有数量(可重入特性)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getHoldCount</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line"><span class="comment">//是否被当前线程持有</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isHeldByCurrentThread</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line"><span class="comment">//是否成功获取锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line"><span class="comment">//是否公平锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isFair</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line"><span class="comment">//返回当前持有此锁的线程</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Thread <span class="title">getOwner</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line"><span class="comment">//是否有可能正在等待获取此锁的线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedThreads</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line"><span class="comment">//查询指定线程是否正在等待获取此锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedThread</span><span class="params">(Thread var1)</span> </span>&#123;...&#125;</span><br><span class="line"><span class="comment">//返回可能获取此锁的等待线程数量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getQueueLength</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line"><span class="comment">//返回可能正在等待此锁的线程集合</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Collection&lt;Thread&gt; <span class="title">getQueuedThreads</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的构造方法可知，<code>ReentrantLock</code>默认是<strong>非公平锁</strong>，但可根据需要配置成<strong>公平锁</strong>。除此之外，它还提供了一系列查询方法，用于查询当前锁的获取状态，这里不一一描述了。</p></li><li><p>基础用法：</p><ol><li><p><strong>lock</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br><span class="line">lock.lock(); <span class="comment">//lock</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line"><span class="comment">//handle exception</span></span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock(); <span class="comment">//unlock</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>lockInterruptibly</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123; </span><br><span class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br><span class="line">    lock.lockInterruptibly(); <span class="comment">//向上抛出中断异常，也可以自己try cache处理</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//Do something</span></span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line"><span class="comment">//handle exception</span></span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock(); <span class="comment">//unlock</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>tryLock</strong>：（两种使用方式）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非阻塞</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">if</span>(lock.tryLock()) &#123; <span class="comment">//尝试获取锁，这个调用不会阻塞</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//do something</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">//handle exception</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock(); <span class="comment">//unlock</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//获取锁失败</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//阻塞，可设置超时时间，可中断</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAnything</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     Lock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">if</span>(lock.tryLock(<span class="number">5</span>, TimeUnit.SECONDS)) &#123; <span class="comment">//超时设为5s</span></span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">                 <span class="comment">//do something</span></span><br><span class="line">             &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                 <span class="comment">//handle exception</span></span><br><span class="line">             &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                 lock.unlock(); <span class="comment">//unlock</span></span><br><span class="line">             &#125;</span><br><span class="line">         &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="comment">//获取锁失败</span></span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">         <span class="comment">//处理中断事件</span></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>在上面的代码演示中，不难发现unlock操作都是放在finally语句中，而获取锁却不再对应try-catch中，这是因为对于非阻塞或可中断的获取锁方发来说，如果获取锁失败，后面再去调用unlock就会抛出<code>IllegalMonitorStateException</code>异常，这会带来不必要的麻烦，所以一般获取锁不成功就不会执行unlock。对于可中断的锁一般采用向上抛出，这是因为多线程环境下获取锁失败的后该是各线程自行采取相应处理策略，而不是由被调用者处理。</p></li></ol></li></ol><h3 id="三、ReadWriteLock"><a href="#三、ReadWriteLock" class="headerlink" title="三、ReadWriteLock"></a>三、ReadWriteLock</h3><ol><li><p>JDK中除提供了基本的满足同步、互斥的Lock机制外，还提供了一种特殊的读写锁模型，该模型一定程度上降低了互斥要求，带来更好的性能体验。读写锁具体来说分为两方面：</p><ul><li>ReadLock：读锁不同线程可以重复获取（与可重入概念不一样），即一个资源是可以并发读的，资源加了读锁后只能再加读锁。</li><li>WriteLock：写锁是完全互斥的，即一个资源加写锁后不能再施加其他锁，当然加了读锁的资源也不能加写锁。</li></ul></li><li><p>读写锁在数据库中运用非常广泛，比如一行数据可以多个客户端读取，但不能同时写，也不能边读边写。下面演示读写锁的具体用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ReadWriteLock readWriteLock;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; resource; <span class="comment">//模拟公共资源</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LockTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        readWriteLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">        resource = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        resource.add(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//主方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        LockTest lockTest = <span class="keyword">new</span> LockTest();</span><br><span class="line">        Thread r1 = <span class="keyword">new</span> Thread(() -&gt; &#123; <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;++i) &#123; lockTest.read();&#125; &#125;, <span class="string">"reader1"</span>);</span><br><span class="line">        Thread r2 = <span class="keyword">new</span> Thread(() -&gt; &#123; <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;++i) &#123; lockTest.read();&#125; &#125;, <span class="string">"reader2"</span>);</span><br><span class="line">        Thread w1 = <span class="keyword">new</span> Thread(()-&gt;&#123; <span class="keyword">try</span>&#123; lockTest.write(); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"writer1被中断"</span>); &#125;&#125;, <span class="string">"writer1"</span>);</span><br><span class="line">        Thread w2 = <span class="keyword">new</span> Thread(()-&gt;&#123; <span class="keyword">try</span>&#123; lockTest.write(); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"writer2被中断"</span>); &#125;&#125;, <span class="string">"writer2"</span>);</span><br><span class="line"></span><br><span class="line">        r1.start();</span><br><span class="line">        r2.start();</span><br><span class="line">        w2.start();</span><br><span class="line">        w1.start();</span><br><span class="line">        Thread.sleep(<span class="number">3</span>);<span class="comment">//等待3ms</span></span><br><span class="line">        w1.interrupt(); <span class="comment">//尝试中断writer1的阻塞</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取资源</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        readWriteLock.readLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">": "</span> +resource);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readWriteLock.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写入资源</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        readWriteLock.writeLock().lockInterruptibly();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            resource.add(Thread.currentThread().getName());</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">": add resource"</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readWriteLock.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**输出：</span></span><br><span class="line"><span class="comment"> * reader2: [main]</span></span><br><span class="line"><span class="comment"> * reader1: [main]</span></span><br><span class="line"><span class="comment"> * writer2: add resource</span></span><br><span class="line"><span class="comment"> * writer1被中断</span></span><br><span class="line"><span class="comment"> * reader2: [main, writer2]</span></span><br><span class="line"><span class="comment"> * reader1: [main, writer2]</span></span><br><span class="line"><span class="comment"> * reader1: [main, writer2]</span></span><br><span class="line"><span class="comment"> * reader2: [main, writer2]</span></span><br><span class="line"><span class="comment"> * reader1: [main, writer2]</span></span><br><span class="line"><span class="comment"> * reader2: [main, writer2]</span></span><br><span class="line"><span class="comment"> * reader1: [main, writer2]</span></span><br><span class="line"><span class="comment"> * reader2: [main, writer2]</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>上面演示了并发环境下ReadWriteLock的使用，这里需要注意的是最终的输出不是一个固定结果，如果writer1在3ms内获取到锁就不会输出<code>writer1被中断</code>（<code>w1.interrupt();</code>将会中断writer1里面的sleep），这个结果完全是随机的。虽然ReentrantReadWriteLock没实现Lock接口，但其内部类<code>ReentrantReadWriteLock.WriteLock</code>和<code>ReentrantReadWriteLock.ReadLock</code>实现了Lock接口，因此读写锁也具有Lock的全部特性。</p></li></ol><h3 id="四、相关概念"><a href="#四、相关概念" class="headerlink" title="四、相关概念"></a>四、相关概念</h3><ol><li><p><strong>乐观锁/悲观锁</strong></p><p>乐观锁和悲观锁不是一种具体的锁，而是对待并发的一种态度。<strong>悲观锁</strong>认为对于同一资源的并发访问一定会发生修改操作，不加锁的并发访问一定会出问题，因此一定要加锁。<strong>乐观锁</strong>则认为并发访问很少发生资源修改操作，即使发生也会采用不断尝试的方式更新资源，不加锁的并发访问是不会出问题的。悲观锁适合写操作多的场景，乐观锁适合读操作多的场景。Java中各种加锁编程就属于悲观锁范围，而使用concurrent包下的AtomicXXX实现原子操作就属于乐观锁范围，因为Atomic类型是使用<a href="https://segmentfault.com/a/1190000017943658" target="_blank" rel="noopener">CAS算法</a>实现原子操作的，并没有使用锁，属于无锁编程，一般来说乐观锁的性能好于悲观锁。</p></li></ol><hr><ol start="2"><li><p><strong>可重入锁</strong></p><p>可重入是只可重复递归调用的锁，在加锁的方法类可递归调用该方法，并不会发生死锁。<code>ReentrantLock</code>和<code>synchronized</code>都是可重入锁。</p></li></ol><hr><ol start="3"><li><p><strong>独占锁（排它锁）</strong> / <strong>共享锁</strong></p><p>独占锁即一个锁只能一个线程占有，如<code>ReentrantLock</code>、<code>ReentrantReadWriteLock.WriteLock</code>就是独占锁。共享锁可被多个线程共享，如<code>ReentrantReadWriteLock.ReadLock</code></p></li></ol><hr><ol start="4"><li><p><strong>公平锁</strong> / <strong>非公平锁</strong></p><p>公平锁是指获取锁的顺序跟申请锁的顺序一致，反之亦然。</p></li></ol><hr><ol start="5"><li><p><strong>分段锁</strong></p><p>分段锁是一种锁的设计，它的核心思想是减小加锁粒度。比如在<code>ConcurrentHashMap</code>中就采用分段锁的思想，ConcurrentHashMap中有16个锁，每个散列桶由第N%16个锁来保护，所以一次加锁理论上（与数据分布均匀程度有关）只锁定整个Map的1/16的数据，其他部分的数据访问不受限制，ConcurrentHashMap最多可支持16个线程的并发写入。同样在MySQL中也有类似的设计出现，比如行锁就是一种分段锁，更新数据时只需要锁定特定行，其他行可供正常访问。</p></li></ol><hr><ol start="6"><li><p><strong><em>偏向锁</em></strong> / <strong><em>轻量级锁</em></strong> / <strong><em>重量级锁</em></strong></p><p>这3种分类非Java语言提供的特性，因此不做深入研究，可参考：<a href="https://www.cnblogs.com/wzj4858/p/8215369.html" target="_blank" rel="noopener">偏向锁/轻量级锁/重量级锁</a></p></li></ol><hr><ol start="7"><li><p><strong>自旋锁</strong></p><p>自旋锁关注的是在获取锁的过程中线程处所处状态，当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将<strong>循环等待</strong>（不进入阻塞状态），然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环。注意，自旋锁的设计是为了减少线程状态切换带来的开销（用户态-&gt;内核态，active-&gt;blocked）,当加锁区域的代码执行的非常快时，该设计能大大提高性能。而加锁区域执行缓慢时则相反，自旋锁不会释放CPU资源，如果长时间处于自旋状态将严重拖累系统性能，所以是否采用自旋锁需要根据需求而定。</p></li></ol><h3 id="五、参考资料"><a href="#五、参考资料" class="headerlink" title="五、参考资料"></a>五、参考资料</h3><ol><li><a href="https://blog.csdn.net/justloveyou_/article/details/54972105" target="_blank" rel="noopener">Java 并发：Lock 框架详解</a></li><li><a href="http://blog.itpub.net/31545684/viewspace-2375117/" target="_blank" rel="noopener">Java 种15种锁的介绍：公平锁，可重入锁，独享锁，互斥锁等等…</a></li><li><a href="https://www.cnblogs.com/wzj4858/p/8215369.html" target="_blank" rel="noopener">javas的四种状态 无锁状态 偏向锁状态 轻量级锁状态 重量级锁状态</a></li><li><a href="https://zhuanlan.zhihu.com/p/40729293" target="_blank" rel="noopener">面试必备之深入理解自旋锁</a></li><li><a href="http://tool.oschina.net/apidocs/apidoc?api=jdk-zh" target="_blank" rel="noopener">JDK文档</a></li></ol>]]></content>
    
    <summary type="html">
    
      并发编程中，锁是一个永远绕不过的话题，深入认识Java中的同步、互斥机制是Java并发编程的必经之路。本篇文章就Java原生锁机制做一个简单的描述，让自己能全面宏观认识整个框架，在工作学习中能正确、高效使用Java同步、互斥相关工具。
    
    </summary>
    
      <category term="Java" scheme="https://blog.zjee.ml/categories/Java/"/>
    
    
      <category term="多线程" scheme="https://blog.zjee.ml/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="Java锁机制" scheme="https://blog.zjee.ml/tags/Java%E9%94%81%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>Hive on Spark 实践</title>
    <link href="https://blog.zjee.ml/2018/12/02/hive-on-spark/"/>
    <id>https://blog.zjee.ml/2018/12/02/hive-on-spark/</id>
    <published>2018-12-02T13:02:57.000Z</published>
    <updated>2018-12-02T13:02:57.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、准备"><a href="#一、准备" class="headerlink" title="一、准备"></a>一、准备</h3><ol><li>jdk、hadoop、Hive、mysql和spark。为避免兼容问题，本人全部采用cdh版本，对应cdh5.15.0，不过貌似spark版本有点低，不过无所谓，毕竟只是实验。</li><li>由于本人之前搭建过kylin环境，因此hadoop和hive环境已经配置妥当，都是yarn管理下的伪分布式集群。</li><li>安装scala，mac下通过brew安装：<code>brew install scala</code>，网速慢可以使用代理或<a href="https://www.cnblogs.com/jay54520/p/6347729.html" target="_blank" rel="noopener">国内源</a>。</li><li><a href="https://www.cnblogs.com/binarylei/p/8903601.html" target="_blank" rel="noopener">hadoop</a>、<a href="https://www.cnblogs.com/wujiadong2014/p/6058552.html" target="_blank" rel="noopener">hive</a>、<a href="https://www.jianshu.com/p/e41b18a7e202" target="_blank" rel="noopener">spark</a>的基本概念，原理，运行方式可做一个初步了解，方便以后问题排查。</li></ol><h3 id="二、配置SPARK"><a href="#二、配置SPARK" class="headerlink" title="二、配置SPARK"></a>二、配置SPARK</h3><ol><li><p>在/etc/profile或~/.bash_profile（假设你没有使用zsh之类的shell）中加入SPARK_HOME环境变量，并将bin路径添加到PATH中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export SPARK_HOME=/Users/xxx/spark-1.6.0-cdh5.15.0</span><br><span class="line">export PATH=$PATH:$SPARK_HOME/bin</span><br></pre></td></tr></table></figure></li><li><p>在spark下的config目录中找到spark-env.sh和spark-defaults.conf(如果没有就自己创建)，然后添加如下配置:</p><p>spark-env.sh</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> !/usr/bin/env bash</span><br><span class="line">export SCALA_HOME=/usr/local/Cellar/scala/2.12.7 #注意scala版本</span><br><span class="line">export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Home</span><br><span class="line">export HADOOP_HOME=/Users/xxx/hadoop-2.6.0-cdh5.15.0</span><br><span class="line">export HADOOP_CONF_DIR=$HADOOP_HOME/etc/hadoop #hadoop配置文件目录</span><br><span class="line">export YARN_CONF_DIR=$HADOOP_HOME/etc/hadoop #yarn配置文件目录(和hadoop配置在一起)</span><br><span class="line">export SPARK_MASTER_IP=localhost #master节点IP，本地搭建使用localhost</span><br><span class="line">export SPARK_MASTER_HOST=localhost #master机器名称，本地搭建可使用localhost代替</span><br><span class="line">export SPARK_EXECUTOR_MEMORY=512m #每个executor可分配的内存，可根据机器实际情况设置为512m到1g</span><br><span class="line">export SPARK_DRIVER_MEMORY=512m #driver可分配的内存，可根据机器实际情况设置为512m到1g</span><br><span class="line">export SPARK_DIST_CLASSPATH=$($&#123;HADOOP_HOME&#125;/bin/hadoop classpath) #saprk运行依赖hadoop的库</span><br></pre></td></tr></table></figure><p>spark-defaults.conf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">spark.master                     yarn</span><br><span class="line">spark.home                       /Users/xxx/spark-1.6.0-cdh5.15.0</span><br><span class="line">spark.eventLog.enabled           true</span><br><span class="line">spark.eventLog.dir               hdfs://localhost:8001/spark_history</span><br><span class="line">spark.serializer                 org.apache.spark.serializer.KryoSerializer</span><br><span class="line">spark.executor.memory            512m</span><br><span class="line">spark.driver.memory              512m</span><br><span class="line">spark.executor.extraJavaOptions  -XX:+PrintGCDetails -Dkey=value -Dnumbers=&quot;one two three&quot;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：这里将spark托管到yarn上，所以spark.master配置为yarn，日志目录必须是hdfs路径下的<strong><em>已经存在</em></strong>的目录，如果不存在请手动创建<code>hdfs dfs -mkdir /spark_history</code>，这个目录也是后面的spark history服务依赖的目录。</p></li></ol><h3 id="三、配置Hive"><a href="#三、配置Hive" class="headerlink" title="三、配置Hive"></a>三、配置Hive</h3><ol><li><p>将spark-defaults.conf中的配置同步到hive配置中，在hive下的conf目录下找到hive-site.xml，增加如下内容：<br> hive-site.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 注意：hive.execution.engine在这里设置表示hive默认使用spark引擎，</span></span><br><span class="line"><span class="comment">也可以不在这里设置，进入hive cli或客户端后使用set hive.execution.engine=spark</span></span><br><span class="line"><span class="comment">启用spark引擎，但这种方式只针对当前会话有效。--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>hive.execution.engine<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>spark<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;spark.home&lt;/name&gt;</span><br><span class="line">&lt;value&gt;/Users/xxx/spark-1.6.0-cdh5.15.0&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;spark.master&lt;/name&gt;</span><br><span class="line">&lt;value&gt;yarn&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;spark.executor.memory&lt;/name&gt;</span><br><span class="line">&lt;value&gt;512m&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;spark.driver.memory&lt;/name&gt;</span><br><span class="line">&lt;value&gt;512m&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;property&gt;</span><br><span class="line">&lt;name&gt;spark.serializer&lt;/name&gt;</span><br><span class="line">&lt;value&gt;org.apache.spark.serializer.KryoSerializer&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;property&gt;</span><br><span class="line">  &lt;name&gt;spark.enentLog.enabled&lt;/name&gt;</span><br><span class="line">  &lt;value&gt;true&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;property&gt;</span><br><span class="line">  &lt;name&gt;spark.enentLog.dir&lt;/name&gt;</span><br><span class="line">  &lt;value&gt;hdfs://localhost:8001/spark_history&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;property&gt;</span><br><span class="line">  &lt;name&gt;spark.executor.extraJavaOptions&lt;/name&gt;</span><br><span class="line">  &lt;value&gt;-XX:+PrintGCDetails -Dkey=value -Dnumbers=&quot;one two three&quot;&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：这里的配置务必和spark-defaults.conf中的一致，尤其是<code>spark.executor.memory</code>和<code>spark.driver.memory</code>，自己配置时填错了这两项，结果一堆莫名其妙的异常。</p></li></ol><h3 id="四、配置yarn"><a href="#四、配置yarn" class="headerlink" title="四、配置yarn"></a>四、配置yarn</h3><ol><li><p>配置yarn，在hadoop的etc/hadoop目录下找到yarn-site.xml，增加（修改）如下内容：<br>yarn-site.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- yarn资源调度器：公平调度 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.scheduler.class<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>org.apache.hadoop.yarn.server.resourcemanager.scheduler.fair.FairScheduler<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- NM的web监控地址，主要是端口设置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.webapp.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>0.0.0.0:8042<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- NM可分派的内存量，单机的话看机器剩余内存量配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.resource.memory-mb<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>8192<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- NM可分配的虚拟CPU数，单机的话配置为CPU核数-2或-1 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.resource.cpu-vcores<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>6<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="五、其他配置"><a href="#五、其他配置" class="headerlink" title="五、其他配置"></a>五、其他配置</h3><ol><li><p>你以为这就完了？没有，CDH版本的Hive与Spark并没有联系，所以需要我们手动将spark lib中的<code>spark-assembly-1.6.0-cdh5.15.0-hadoop2.6.0-cdh5.15.0.jar</code>拷贝到hive lib下，hive才能与spark建立联系。</p></li><li><p>理论上一切OK了，但你可能会发现在hive中使用spark引擎时返回3号错误，总之就是spark运行不正常，这时可以使用spark自带的example进行测试诊断（cd到spark bin目下）：<code>./spark-submit --master yarn --class org.apache.spark.examples.SparkPi ../lib/spark-examples-1.6.0-cdh5.15.0-hadoop2.6.0-cdh5.15.0.jar 10</code>，具体example jar路径及文件名自行查看。运行起来后有一个异常解决一个异常，直到跑出结果为止，没本人测试中发现以下问题：</p><blockquote><p><strong>没有jackson模块</strong>：WTF，官网下载的spark居然包都不带全，随后查了一下cdh版本确实没带jackson的相关包，然后去maven官网下载(三个都要下载)，放到<code>{HADOOP_HOME}/share/hadoop/common/lib</code>下，至于为什么放在这儿而不是spark lib，这是因为我们在前面配置了<code>SPARK_DIST_CLASSPATH</code>（看不明白就在shell中echo一下），它会加入到spark类路径下，这个路径就包含上面的<code>{HADOOP_HOME}/share/hadoop/common/lib</code>，而且它下面还有jackson的其他包，顺理成章就放这儿了。随后再试！</p></blockquote><blockquote><p><strong>jackson版本问题</strong>：WTF，这回找到jackson了，但jackson内部抛异常了，上网查发现是版本问题，于是按热心网友推荐采用2.4.4的版本，这回不抛异常了！</p></blockquote><blockquote><p><strong>无限ACCEPT</strong>：虽然异常是没了，可这个程序一直是ACCEPT（等一个小时了），然后又上网搜索找到部分答案，测试无果，再回头看前面的配置，发现sparkk-env.sh中<code>SPARK_MASTER_IP</code>和<code>SPARK_MASTER_HOST</code>跟那些傻屌网友一样配成了master，可是我的机器不叫master，所以yarn找不到执行机器，也就无法分配内存，遂更改为localhost(本篇文章开头配置已更改)，然后 everything is OK！<br></p></blockquote><blockquote><p>如果你的机器内存较小，导致分配资源缓慢，可适当调整一下<code>${HADOOP_HOME}/etc/hadoop/capacity-scheduler.xml</code>中的<code>yarn.scheduler.capacity.maximum-am-resource-percent</code>，可以由0.1调整为0.5，它表示yarn所管理的资源中，最多可以有多少资源可以用来运行application master，即控制当前激活状态的应用，默认是10%，在我们自己机器上来说太小了，因此可适当调大比例。</p></blockquote></li></ol><hr><ol start="3"><li>终极测试：<img src="/2018/12/02/hive-on-spark/001.png" title="Hive on Spark 测试结果"></li></ol>]]></content>
    
    <summary type="html">
    
      作为大数据开发人员，一直将精力放在业务上，很久没有关注大数据工具hive了。最近在写一个UDF函数时发现在hive(mr)引擎能通过，在spark引擎下却报错，于是就借此机会粗略研究一下hive on mr、hive on spark和spark sql等内容。本篇为整个系列开篇，介绍了MAC下Hive on spark的环境搭建，及遇到的坑。
    
    </summary>
    
      <category term="大数据" scheme="https://blog.zjee.ml/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="hive" scheme="https://blog.zjee.ml/tags/hive/"/>
    
      <category term="spark" scheme="https://blog.zjee.ml/tags/spark/"/>
    
      <category term="hadoop" scheme="https://blog.zjee.ml/tags/hadoop/"/>
    
      <category term="大数据" scheme="https://blog.zjee.ml/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
  </entry>
  
  <entry>
    <title>RPC框架之Thrift</title>
    <link href="https://blog.zjee.ml/2018/11/29/thrift-grama/"/>
    <id>https://blog.zjee.ml/2018/11/29/thrift-grama/</id>
    <published>2018-11-29T05:37:11.000Z</published>
    <updated>2020-05-17T03:02:48.702Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>Thrift 接口定义语言 Thrift 接口定义语言(IDL, Interface Definition Language)中允许使用的是 thrift types。每个 thrift 文件主要有 hearder，类型定义，异常及服务组成，每个 thrift 文档包含 0 个或多个 headers 以及 0 个或多个 definitions。</p><h3 id="1、thrift-文件的组成"><a href="#1、thrift-文件的组成" class="headerlink" title="1、thrift 文件的组成"></a>1、thrift 文件的组成</h3><ul><li>Header ：header 可以是 thrift include，C++ include，或者是 namespace 声明。</li><li>Thrift include 的目的是使得其他 thrift 文件中的所有定义都能够通过 include 声明添加到该     thrift 文档产生的代码中。 语法：<code>include &quot;../../***.thrift&quot;</code> ，被引用的 thrift 文件产生的代码中的头文件即可包含在 thrift 产生的代码的头部，使得其能够使用、访问。 </li><li>C++ include 能够将 C++定义的头文件添加到该 thrift 文件产生的 C++代码中。 语法：        <code>cpp_include &quot;../../***.h&quot;</code> ，被引用的.h 文件将包含到 thrift 产生的代码的头部。 </li><li>namespace 的声明方式采用为 namespaces/package/module/etc。namespace scope 表示该     namespace 应用于哪种编程语言，若 scope 的取值为“*”，则表示该 namespace 适用于所有的目标语言。 语法： <code>namespace namespaceScope 名称</code>，其中namespaceScope 的取值    有<code>*| cpp | java | py | perl | rb | cocoa | csharp</code>。 </li></ul><h3 id="2、Definition"><a href="#2、Definition" class="headerlink" title="2、Definition"></a>2、Definition</h3><p> thrift 中可以定义的类型有 const | typedef | enum | struct | exception | service </p><ul><li>const 语法： <code>const 字段类型 标识符 = 值</code></li><li>typedef 语法： <code>typedef 为一个类型创建一个别名</code></li><li>enum 语法： <code>enum 标识符 {***，***，…}</code>。其中，第一个值的取值默认为 0。 </li><li>struct 语法： <code>struct 标识符 { Field* }</code>。其中，每个 Field 的定义语法为： <code>FieldId: (required | optional) FieldType Identifier ( = value)</code>。 </li><li>exception： Exceptions 的定义与 struts 的定义相似，exception 中每个 field 的定义必须唯一 语法： <code>exception 标识符 { Field* }</code></li><li>service： Service 定义了 server 端提供的功能集合的接口。一个 service 可以继承另一个 service。 语法： <code>service 标识符 (extends otherService) { Function* }</code></li></ul><h2 id="二、类型详解"><a href="#二、类型详解" class="headerlink" title="二、类型详解"></a>二、类型详解</h2><p>Thrift类型系统包括<strong>预定义基本类型</strong>，<strong>用户自定义结构体</strong>，<strong>容器类型</strong>，<strong>异常</strong>和<strong>服务</strong>定义。</p><h4 id="1、基本类型"><a href="#1、基本类型" class="headerlink" title="1、基本类型"></a>1、基本类型</h4><ul><li>bool: 布尔类型，占一个字节</li><li>byte: 有符号字节 </li><li>i16：16位有符号整型 </li><li>i32：32位有符号整型 </li><li>i64：64位有符号整型 </li><li>double：64位浮点数 </li><li>string：未知编码或者二进制的字符串 </li><li>注意：<strong><em>thrift不支持无符号整形，因为很多目标语言不存在无符号整形（比如java）</em></strong> </li></ul><h3 id="2、容器类型"><a href="#2、容器类型" class="headerlink" title="2、容器类型"></a>2、容器类型</h3><ul><li>List<t1>：一系列t1类型的元素组成的有序列表，元素可以重复，映射到Java的ArrayList，c++的vector，脚本语言的Arrays等。 </t1></li><li>Set<t1>：一些t1类型的元素组成的无序集合，元素唯一不重复，映射到Java的HashSet，c++的STL中的set。 </t1></li><li>Map&lt;t1,t2&gt;：key/value对，key唯一，映射到Java的HashMap， c++的STL中的map。 </li><li>容器中的元素类型可以是除service以外的任何合法的thrift类型，包括结构体和异常类型 。</li></ul><h3 id="3、结构体和异常"><a href="#3、结构体和异常" class="headerlink" title="3、结构体和异常"></a>3、结构体和异常</h3><ul><li>Thrift结构体在概念上同c语言的<strong>结构体</strong>类似，在面向对象语言中，thrift结构体将被转化为<strong>类</strong>。 </li><li>thrift 结构体之间<strong><em>不能继承</em></strong>，每个结构体都有一组类型定义的字段，每个 field 都有一个唯一的命名标识符。 </li><li>异常在语法和功能上类似于结构体，只是异常使用关键字<code>exception</code>而不是struct关键字来声明。但它在语义上不同于结构体，当定义一个RPC服务时，开发者可能需要声明一个远程方法抛出一个异常。 </li><li>异常可以继承目标编程语言的异常类，目的是与给定编程语言的异常处理功能无缝的结合。 </li></ul><h3 id="4、服务"><a href="#4、服务" class="headerlink" title="4、服务"></a>4、服务</h3><ul><li>Thrift中服务定义的方式和语法等同于面向对象语言中定义<strong>接口</strong>。Thrift编译器会产生实现接口的client和server stubs。 </li><li>一个服务包括一个命名的 functions 集合，每个 function 有一个<strong>参数列表</strong>，一个<strong>返回值</strong>以及抛出或产生的一个<strong>异常列表</strong>。这些异常是 thrift 本身的<code>exception</code>类型。 </li><li>注意： void 是一种确定的 function 返回值类型，<strong><em>oneway 关键词（加在 void 之前）等同于 <u>async</u></em></strong>，这种方法产生的客户端代码无需等待 server 端的响应（异步调用）。 </li><li>单纯的 void 函数将会为 client 返回一个确认，用于表示操作在 server 端已经执行完毕。 </li><li><strong><em>当调用 oneway 方法时，client 端只保证 request 已成功发送至 transport 层，不能保证 server 端看到过这个 message，单个 client connection 的 oneway/async 方法可以在 server 端并行执行。</em></strong>  </li></ul><h3 id="5、类型重定义"><a href="#5、类型重定义" class="headerlink" title="5、类型重定义"></a>5、类型重定义</h3><ul><li>Thrift支持C/C++风格的typedef: <code>typedef i32 MyInteger /*a typedef Tweet ReTweet*/</code></li><li>说明：末尾没有逗号、分号，struct可以使用typedef </li></ul><h2 id="三、数据结构定义"><a href="#三、数据结构定义" class="headerlink" title="三、数据结构定义"></a>三、数据结构定义</h2><h3 id="1、常量"><a href="#1、常量" class="headerlink" title="1、常量"></a>1、常量</h3><p>Thrift允许用户定义常量，复杂的类型和结构体可以使用JSON形式表示： </p><ul><li><code>const i32 INT_CONST = 1234;</code>  </li><li><code>const map&lt;string,string&gt; MAP_CONST = {&quot;hello&quot;: &quot;world&quot;, &quot;goodnight&quot;: &quot;moon&quot;}</code></li><li>说明：<strong>分号是可选的</strong>，支持十六进制赋值 </li></ul><h3 id="2、枚举类型"><a href="#2、枚举类型" class="headerlink" title="2、枚举类型"></a>2、枚举类型</h3><p>可以像C/C++那样定义枚举类型，如： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> TweetType</span><br><span class="line">&#123;</span><br><span class="line">TWEET,</span><br><span class="line">RETWEET = <span class="number">2</span>,</span><br><span class="line">DM = <span class="number">0xa</span>,</span><br><span class="line">REPLY</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>编译器默认从0开始赋值 </li><li>可以赋予某个常量 </li><li>允许常量是十六进制整数 </li><li>给常量赋缺省值时，使用常量的全称 </li><li>不同于protocol buffer，<strong>thrift不支持枚举类嵌套，枚举常量必须是32位正整数</strong> </li></ul><h3 id="3、定义结构体"><a href="#3、定义结构体" class="headerlink" title="3、定义结构体"></a>3、定义结构体</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tweet</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="number">1</span>: required i32 userId;                  <span class="comment">// a</span></span><br><span class="line">    <span class="number">2</span>: required <span class="built_in">string</span> userName;             <span class="comment">// b</span></span><br><span class="line">    <span class="number">3</span>: required <span class="built_in">string</span> text;</span><br><span class="line">    <span class="number">4</span>: optional Location loc;                <span class="comment">// c</span></span><br><span class="line">    <span class="number">16</span>: optional <span class="built_in">string</span> language = <span class="string">"english"</span> <span class="comment">// d</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct Location</span><br><span class="line">&#123;</span><br><span class="line">    <span class="number">1</span>: required <span class="keyword">double</span> latitude;</span><br><span class="line">    <span class="number">2</span>: required <span class="keyword">double</span> longitude;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>每一个域都有一个唯一的正整数标识符（如示例中冒号前的数字），称为数字标签，这些数字标签在传输时用来确定序列化顺序，一旦使用消息类型，标签不可改变。（随着项目的进展，可以变更Thrift文件，最好不要改变原有的数字标签） </li><li>每个域可以标识为<code>required（必选的）</code>或者<code>optional(可选的)</code>（也可以不注明） </li><li>结构体可以包含其他结构体 </li><li>域可以有缺省值 </li><li>一个thrift中可以定义多个结构体，并存在引用关系 </li><li>规范的struct定义中的每个域均会使用required或者optional关键字进行标识。如果required标识的域没有赋值，thrift将给予提示。<strong>如果optional标识的域没有赋值，该域将不会被序列化传输</strong>。如果某个optional标识域有缺省值而用户没有重新赋值，则该域的值一直为缺省值。 </li><li>与service不同，<strong><em>结构体不支持继承</em></strong>，即一个结构体不能继承另一个结构体。 </li></ul><h3 id="4、定义服务"><a href="#4、定义服务" class="headerlink" title="4、定义服务"></a>4、定义服务</h3><p>在流行的序列化/反序列化框架（如protocol buffer）中，thrift是少有的提供多语言间RPC服务的框架。Thrift编译器会根据选择的目标语言为server产生服务接口代码，为client产生桩代码。 </p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//“Twitter”与“&#123;”之间需要有空格！！！</span></span><br><span class="line"><span class="comment">//方法定义方式类似于C语言中的方式，它有一个返回值，一系列参数和可选的异常</span></span><br><span class="line"><span class="comment">//注意，参数列表和异常列表定义方式与结构体中域定义方式一致</span></span><br><span class="line"><span class="comment">//”oneway”标识符表示client发出请求后不必等待回复（非阻塞）直接进行下面的操作，”oneway”方法的返回值必须是void</span></span><br><span class="line">service Twitter &#123;</span><br><span class="line">void ping(),                                    // a</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">postTweet</span><span class="params">(<span class="number">1</span>:Tweet tweet)</span></span>;                  <span class="comment">// b</span></span><br><span class="line"><span class="function">TweetSearchResult <span class="title">searchTweets</span><span class="params">(<span class="number">1</span>:<span class="built_in">string</span> query)</span></span>; <span class="comment">// c</span></span><br><span class="line"><span class="function">oneway <span class="keyword">void</span> <span class="title">zip</span><span class="params">()</span>                               <span class="comment">// d</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>函数定义可以使用<strong>逗号</strong>或<strong>分号</strong>标识结束 </li><li>参数可以是基本类型或者结构体，参数只能是只读的（const），不可以作为返回值（参数不可携带数据返回） </li><li>返回值可以是基本类型或者结构体 </li><li>返回值可以是void </li><li>Service支持继承，一个service可使用extends关键字继承另一个service </li></ul><h2 id="四、注释、命名空间、文件包含"><a href="#四、注释、命名空间、文件包含" class="headerlink" title="四、注释、命名空间、文件包含"></a>四、注释、命名空间、文件包含</h2><h3 id="1、注释"><a href="#1、注释" class="headerlink" title="1、注释"></a>1、注释</h3><p>Thrift支持shell注释风格、C/C++语言中的单行或多行注释风格</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># This is a valid comment.  shell风格注释</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* This is a multi-line comment.</span></span><br><span class="line"><span class="comment">* Just like in C.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// C++/Java style single-line comments work just as well.</span></span><br></pre></td></tr></table></figure><h3 id="2、命名空间"><a href="#2、命名空间" class="headerlink" title="2、命名空间"></a>2、命名空间</h3><p>Thrift中的命名空间同C++中的namespace和java中的package类似，它们均提供了一种组织（隔离）代码的方式。因为每种语言均有自己的命名空间定义方式（如python中有module），thrift允许开发者针对特定语言定义namespace： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> cpp com.example.project  <span class="comment">// a</span></span><br><span class="line"><span class="keyword">namespace</span> java com.example.project <span class="comment">// b</span></span><br></pre></td></tr></table></figure><h3 id="3、文件包含"><a href="#3、文件包含" class="headerlink" title="3、文件包含"></a>3、文件包含</h3><p>Thrift允许文件包含，需要使用thrift文件名作为前缀访问被包含的对象，如： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">include <span class="string">"tweet.thrift"</span>           <span class="comment">// a</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TweetSearchResult</span> &#123;</span></span><br><span class="line"><span class="number">1</span>: <span class="built_in">list</span>&lt;tweet.Tweet&gt; tweets; <span class="comment">// b</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>thrift文件名需要双引号包含，末尾没有逗号或者分号 </li><li>注意tweet前缀 ，前缀为引入的thrift文件名（不含后缀）</li></ul>]]></content>
    
    <summary type="html">
    
      Thrift is an interface definition language and binary communication protocol used for defining and creating services for numerous languages. It forms a remote procedure call (RPC) framework and was developed at Facebook for &quot;scalable cross-language services development&quot;.
    
    </summary>
    
      <category term="后端开发基础" scheme="https://blog.zjee.ml/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="thrift" scheme="https://blog.zjee.ml/tags/thrift/"/>
    
      <category term="rpc" scheme="https://blog.zjee.ml/tags/rpc/"/>
    
  </entry>
  
  <entry>
    <title>代码版本控制系统Git</title>
    <link href="https://blog.zjee.ml/2018/11/29/learn-git/"/>
    <id>https://blog.zjee.ml/2018/11/29/learn-git/</id>
    <published>2018-11-29T05:20:32.000Z</published>
    <updated>2019-12-28T14:53:56.906Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、创建本地仓库的两种途径："><a href="#1、创建本地仓库的两种途径：" class="headerlink" title="1、创建本地仓库的两种途径："></a>1、创建本地仓库的两种途径：</h4><ol><li><p>从远程仓库克隆一份：<code>git clone [remote git url]</code></p></li><li><p>创建一个目录：<code>mkdir git</code>, 然后用 <code>git init</code> 去初始化这个目录，使之成为一个git仓库。</p></li></ol><h4 id="2、git-config文件配置："><a href="#2、git-config文件配置：" class="headerlink" title="2、git config文件配置："></a>2、git config文件配置：</h4><ol><li>配置全局用户名：<code>git config --global user.name &quot;xxxxxx&quot;</code></li><li>配置全局E-mail：<code>git config --global user.email &quot;xxxxxx@xx.com&quot;</code>, 如果需要在项目中配置不同的用户名和邮件，则只需要在项目目录下执行上面的命令，不带 <code>--global</code> 即可。</li><li>查看配置文件: <code>git config --list</code></li></ol><h4 id="3、将本地仓库和远程仓库关联（适用于git-init创建的仓库）："><a href="#3、将本地仓库和远程仓库关联（适用于git-init创建的仓库）：" class="headerlink" title="3、将本地仓库和远程仓库关联（适用于git init创建的仓库）："></a>3、将本地仓库和远程仓库关联（适用于git init创建的仓库）：</h4><ol><li>添加远程仓库：<code>git remote add [host-name] [git-url]</code>, 一般host-name取<code>origin</code>, 这也是git默认主机名。</li><li>拉取本地还没有的远程仓库的信息：<code>git fetch [host-name] [branch-name]</code>,从远程仓库下载制定分支的信息到本地，但不会与本地的仓库合并，需手动合并<code>git merge [host-name] [branch-name]</code>，如：<code>git fetch origin dev; git merge origin dev;</code></li><li>拉取远程信息，并尝试与本地合并(相当于fetch和merge的合体)：<code>git pull [host-name] [branch-name]</code>, 有冲突需手动解决再手动合并。</li><li>查看远程仓库信息：<code>git remote -v</code>。</li></ol><h4 id="4、将本地信息推送到远程"><a href="#4、将本地信息推送到远程" class="headerlink" title="4、将本地信息推送到远程"></a>4、将本地信息推送到远程</h4><ol><li><code>git push [host] [branch]</code>，如果远程没有对应分支，则需要带上 <code>-u</code> 参数创建相应分支。</li><li>如果本地分支没有与远程分支关联，则需要：<code>git branch --set-upstream [remote-branch]</code>建立关联。</li><li>如果远程分支有其他人提交过，则必须先<code>git pull</code>,尝试与本地合并合并（有冲突解决冲突）后才可以push。</li></ol><h4 id="5、添加文件，修改，提交修改"><a href="#5、添加文件，修改，提交修改" class="headerlink" title="5、添加文件，修改，提交修改"></a>5、添加文件，修改，提交修改</h4><ol><li>添加文件到暂存区：<code>git add [file-name or directory-name]</code>,可以使用通配符。</li><li>所有做的修改都需要使用<code>git add</code>后在进行<code>git commit</code>操作。</li><li>提交修改到本地仓库：<code>git commit -m &#39;说明信息&#39;</code>。</li><li>撤销修改/恢复删除文件：<code>git check --[file-name]</code>，注意两个’-‘。</li><li>查看git状态：<code>git status</code>。</li><li>查看commit日志：<code>git log</code>，单行显示：<code>git log --pretty=oneline</code>。</li><li>查看上次的修改：<code>git diff file-name</code>。</li><li>从暂存区删除一个文件：<code>git rm file-name</code>。</li></ol><h4 id="6、创建、切换分支"><a href="#6、创建、切换分支" class="headerlink" title="6、创建、切换分支"></a>6、创建、切换分支</h4><ol><li>创建并切换分支：<code>git checkout -b [branch-name]</code>，他相当于<code>git branch [branch-name]; git checkout [branch-name];</code>。</li><li>切换分支：<code>git checkout [branch-name]</code>。</li><li>删除分支：<code>git branch -d &lt;name&gt;</code>，使用<code>-D</code>强行删除。</li><li>查看分支合并情况：<code>git log --graph --pretty=oneline --abbrev-commit</code></li></ol><h4 id="7、版本回退"><a href="#7、版本回退" class="headerlink" title="7、版本回退"></a>7、版本回退</h4><ol><li>本地仓库回退：<code>git reset --hard HEAD^</code>，一个<code>^</code>表示回退一个版本，两个<code>^^</code>表示回退两个版本，一次类推，回退100个版本可以这样写<code>HEAD~100</code>，也可以指定回退到具体某个版本<code>git reset --hard 1094adb</code>。</li><li>重返未来：使用<code>git reflog</code>查看操作历史，找到要回去的版本号，使用1中命令即可回到未来。</li></ol><h4 id="8、保存工作现场"><a href="#8、保存工作现场" class="headerlink" title="8、保存工作现场"></a>8、保存工作现场</h4><ol><li><code>git stash</code>，保存工作现场后，working dir就是干净的，这时就可以创建别的分支，进行别的工作，比如紧急修复bug场景。PS：如果当前工作区不干净git不允许创建新的分支。</li><li>恢复工作区：<code>git stash pop</code>，它相当于<code>git stash apply; git stash drop;</code>，恢复并删除stash内容。</li></ol><h4 id="9、标签管理"><a href="#9、标签管理" class="headerlink" title="9、标签管理"></a>9、标签管理</h4><ol><li>commit打标签：<code>$ git tag v0.9 [-m &#39;说明文字&#39;] f52c633</code>，可以省略commit号，默认打在最新commit上。</li><li>使用<code>git show tag-name</code>查看说明文字。</li><li>使用<code>git tag</code>查看所有标签。</li><li>使用<code>git tag -d v0.1</code>删除标签。</li><li>将标签推送到远程：<code>git push origin &lt;tagname&gt;</code>，使用<code>git push origin --tags</code>推送全部tag。</li><li>使用<code>git push origin :refs/tags/&lt;tagname&gt;</code>可以删除一个远程标签，需要先删除本地对应标签。</li></ol>]]></content>
    
    <summary type="html">
    
      Git是目前世界上最先进的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。因此Git也是程序猿入门的必备技能之一，有了它我们就可以在代码的世界里穿越古今，自由翱翔！
    
    </summary>
    
      <category term="后端开发基础" scheme="https://blog.zjee.ml/categories/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="git" scheme="https://blog.zjee.ml/tags/git/"/>
    
  </entry>
  
</feed>
