<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Proxy is a structural design pattern that provides an object that acts as a substitute for a real service object used by a client. A proxy receives client requests, does some work (access control, caching, etc.) and then passes the request to a service object."><meta name="keywords" content="Java"><meta name="author" content="Jack.Charles"><meta name="copyright" content="Jack.Charles"><title>JDK动态代理 | 江影不沉浮</title><link rel="shortcut icon" href="/about/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?3f20839b943a104368c94974ce5350fa";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'G-18T0HPMMWC', 'auto');
ga('send', 'pageview');</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.2.0'
} </script><meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/atom.xml" title="江影不沉浮" type="application/atom+xml">
</head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-text">一、静态代理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-text">二、JDK动态代理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-text">2.1、为什么需要动态代理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2%E3%80%81JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%A4%BA%E4%BE%8B"><span class="toc-text">2.2、JDK动态代理示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3%E3%80%81InvocationHandler%E6%8E%A5%E5%8F%A3"><span class="toc-text">2.3、InvocationHandler接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4%E3%80%81JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%9C%A8MyBatis%E4%B8%AD%E7%9A%84%E8%BF%90%E7%94%A8"><span class="toc-text">2.4、JDK动态代理在MyBatis中的运用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5%E3%80%81JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-text">2.5、JDK动态代理底层原理</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/about/avatar.jpg"></div><div class="author-info__name text-center">Jack.Charles</div><div class="author-info__description text-center">记录职业生涯的点点滴滴...</div><div class="follow-button"><a target="_blank" rel="noopener" href="https://github.com/JackCharles">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">17</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">20</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">8</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://blog.mrabit.com/bing/today)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">江影不沉浮</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/about">About</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">JDK动态代理</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-01-05</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Java/">Java</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">3.4k</span><span class="post-meta__separator">|</span><span>阅读时长: 14 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><blockquote>
<p><strong>代理</strong>是一种结构型设计模式， 让你能提供真实服务对象的替代品给客户端使用。 代理接收客户端的请求并进行一些处理 （访问控制和缓存等）， 然后再将请求传递给服务对象。</p>
<p>代理对象拥有和服务对象相同的接口， 这使得当其被传递给客户端时可与真实对象互换。 </p>
<p style="text-align:right">——Copy From <a href="https://refactoring.guru/design-patterns/proxy/java/example" target="_blank">refactoring.guru</a></p>                                                                                                                       
</blockquote>
<h1 id="一、静态代理"><a href="#一、静态代理" class="headerlink" title="一、静态代理"></a>一、静态代理</h1><p>静态代理代码很简单，但其设计思想很重要。示例如下：</p>
<details><summary style="color:blue">点击查看代码</summary>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//UserService.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">	<span class="function">User <span class="title">getUser</span><span class="params">(<span class="keyword">int</span> userId)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//UserServiceImpl.java UserService的实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(<span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">  	<span class="keyword">return</span> <span class="keyword">new</span> User(userId, xxx, xxx);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//UserServiceProxy.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceProxy</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> UserService delegate;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">UserServiceProxy</span><span class="params">(UserService target)</span> </span>&#123;</span><br><span class="line">  	<span class="keyword">this</span>.delegate = target; <span class="comment">//被代理对象</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(<span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//前置增强</span></span><br><span class="line">    System.out.println(<span class="string">&quot;before get user&quot;</span>);</span><br><span class="line">  	User user = <span class="keyword">this</span>.delegate.getUser(userId);</span><br><span class="line">    <span class="comment">//后置增强</span></span><br><span class="line">    System.out.println(<span class="string">&quot;after get user&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Test.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  	UserService target = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">    UserService proxy = <span class="keyword">new</span> UserServiceProxy(target);</span><br><span class="line">    User user = proxy.getUser(<span class="number">1001</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<h1 id="二、JDK动态代理"><a href="#二、JDK动态代理" class="headerlink" title="二、JDK动态代理"></a>二、JDK动态代理</h1><p>JDK动态代理可以看成一个“万能中介”，它最终实现方法粒度的增强，它的<code>InvocationHandler</code>是“万能的”，根据我们传入的target以及调用不同的方法实现不同的增强效果。需要注意的是JDK动态代理只能代理接口，这与它背后的实现逻辑有关系。</p>
<h2 id="2-1、为什么需要动态代理"><a href="#2-1、为什么需要动态代理" class="headerlink" title="2.1、为什么需要动态代理"></a>2.1、为什么需要动态代理</h2><p>静态代理虽然能够实现大多数功能，但每个目标对象都需要生成一个代理类，当被代理类太多时，开发和维护代理类将是一件很可怕的事情，同时静态代理还不具备处理动态生成的class的能力。基于上诉痛点，各种动态代理技术应运而生，JDK动态代理便是其中之一。</p>
<h2 id="2-2、JDK动态代理示例"><a href="#2-2、JDK动态代理示例" class="headerlink" title="2.2、JDK动态代理示例"></a>2.2、JDK动态代理示例</h2><details><summary style="color:blue">点击查看代码</summary>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口&amp;实现类参考上面静态代理的例子</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//DynamicProxy.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//真正的实现类,或者说被代理对象（不是必须的）</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DynamicProxy</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//前置增强</span></span><br><span class="line">        System.out.println(<span class="string">&quot;before invoke&quot;</span>);</span><br><span class="line">        Object res = method.invoke(target, args);</span><br><span class="line">        <span class="comment">//后置增强</span></span><br><span class="line">        System.out.println(<span class="string">&quot;after invoke&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Test.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      	<span class="comment">//代理类对象，注意它不是我们的目标代理对象，可以理解为它只是个中介</span></span><br><span class="line">        InvocationHandler handler = <span class="keyword">new</span> DynamicProxy(<span class="keyword">new</span> UserServiceImpl());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//动态生成最终目标代理对象</span></span><br><span class="line">        UserService proxy = (UserService) Proxy.newProxyInstance(</span><br><span class="line">                UserServiceImpl.class.getClassLoader(),</span><br><span class="line">                UserServiceImpl.class.getInterfaces(),</span><br><span class="line">                handler</span><br><span class="line">        );</span><br><span class="line">        proxy.getUser(<span class="number">123</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<p>我们可以看到，JDK动态代理核心就在于实现<code>InvocationHandler</code>，重写<code>invoke</code>方法。</p>
<h2 id="2-3、InvocationHandler接口"><a href="#2-3、InvocationHandler接口" class="headerlink" title="2.3、InvocationHandler接口"></a>2.3、InvocationHandler接口</h2><ol>
<li><p><code>InvocationHandler</code>可以理解为一个”执行器“，每个被代理的对象中的所有方法都要经过它，由它决定下一步怎么处理，所以实现<code>InvocationHandler</code>是整个JDK动态代理的核心，不同的功能可以使用不同的<code>InvocationHandler</code>来实现。</p>
</li>
<li><p><code>InvocationHandler</code>中的核心方法<code>invoke</code>：</p>
<p>2.1、<strong>Object proxy：</strong> 该参数是 <strong><em>最终的目标代理对象</em></strong>，一般代理用不到它，在具有链式操作的代理对象中可以直接返回该对象，使得最终代理对象也可以使用链式操作。</p>
<p>2.2 、<strong>Method method：</strong>该参数是我们要调用的<strong>目标方法</strong>，一般会使用<code>method.invoke(target, args)</code>继续调用被代理对象的具体实现。</p>
<p>2.3、<strong>Object[] args</strong>: 该参数是目标方法参数。</p>
<p>2.4、<strong>返回值</strong>：由于该方法是“万能的”，因此我们可以根据传入的参数、调用的方法、目标对象不同而返回不同的结果。</p>
</li>
<li><p>注意事项</p>
<p>3.1、在调用目标方法时，传入的实例对象<strong>不可以</strong>是第一个参数proxy，该参数是最终生成的代理对象，如果继续在它上面调用方法的话就又会回到该方法，从而形成死循环。</p>
<p>3.2、JDK动态代理只能代理java接口（interface）。</p>
</li>
</ol>
<h2 id="2-4、JDK动态代理在MyBatis中的运用"><a href="#2-4、JDK动态代理在MyBatis中的运用" class="headerlink" title="2.4、JDK动态代理在MyBatis中的运用"></a>2.4、JDK动态代理在MyBatis中的运用</h2><p>我们都知道Mybatis只要一个接口和一个XML Mapper（或注解），就能完成增删改查操作，其实Mybatis也是利用JDK动态代理生成的Mapper实例进行调用，下面直接看源码：</p>
<img src="/2020/01/05/jdk-proxy/mybatis-1.png" class="" title="mybatis源码-1">

<p>这就是生成Mapper实例的代码，其中的<code>mapperInterface</code>就是我们写的Mapper接口，但有一个<code>mapperProxy</code>比较重要，它就是我们说的“万能中介”，看看它是怎么实现的：</p>
<img src="/2020/01/05/jdk-proxy/mybatis-2.png" class="" title="mybatis源码-2">

<p>这个<code>MapperProxy</code>也实现了<code>nvocationHandler</code>接口，但与上面介绍的些许不同，之前的动态代理需要一个接口的实现类，但这里并没有实现类。其实<strong>JDK动态代理并不要求实现类</strong>，在invoke方法内部我们完全可以根据三个参数去“创造”结果，然后返回即可。</p>
<p>可以看到，Mybatis根据传入的方法“创造”了另一个“方法”<code>MapperMethod</code>，然后去执行这个新“方法”，最终返回结果。这个创造方法的过程就是根据我们之前的Mapper.xml或注解获得SQL语句，然后根据传入的参数构造statement，最后就直接执行了，具体参考Mybatis源码。</p>
<h2 id="2-5、JDK动态代理底层原理"><a href="#2-5、JDK动态代理底层原理" class="headerlink" title="2.5、JDK动态代理底层原理"></a>2.5、JDK动态代理底层原理</h2><ol>
<li><p>先看生成的代理类</p>
<p>1.1、保存代理类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法1</span></span><br><span class="line"><span class="keyword">byte</span>[] bytes = ProxyGenerator.generateProxyClass(<span class="string">&quot;stuMapperProxy&quot;</span>, stuMapper.getClass().getInterfaces());<span class="comment">//获取代理类bytes数组</span></span><br><span class="line">com.google.common.io.Files.write(bytes, <span class="keyword">new</span> File(<span class="string">&quot;proxy$0.class&quot;</span>));<span class="comment">//保存bytes数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//方法2：代码中加入下面一条属性，默认保存的class文件在项目根目录下com/sun/proxy下面</span></span><br><span class="line">System.getProperties().put(<span class="string">&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>1.2、反编译代理类（以下代码精简掉无关逻辑及异常处理部分）</p>
<details><summary style="color:blue">点击查看代码</summary>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">stuMapperProxy</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">StuMapper</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0; <span class="comment">//hashCode</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1; <span class="comment">//equals</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2; <span class="comment">//toString</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3; <span class="comment">//业务方法selectAll</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m4; <span class="comment">//业务方法addStudent</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 代理类继承自Proxy，Proxy中有一个InvocationHandler成员，它就是我们需要实现的那一部分。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">stuMapperProxy</span><span class="params">(InvocationHandler var1)</span> <span class="keyword">throws</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(var1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//equals方法，通过InvocationHandler调用我们的目标对像的equals范方法</span></span><br><span class="line">    <span class="comment">//下面的其他方法同理。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object var1)</span> <span class="keyword">throws</span> </span>&#123;</span><br><span class="line">        <span class="comment">//super.h就是InvocationHandler实例，其中的invoke方法被我们增强过</span></span><br><span class="line">        <span class="comment">//this: 当前代理对象</span></span><br><span class="line">        <span class="comment">//m1: 当前方法</span></span><br><span class="line">        <span class="comment">//m2: 方法参数</span></span><br><span class="line">        <span class="keyword">return</span> (Boolean) <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m1, <span class="keyword">new</span> Object[]&#123;var1&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> <span class="keyword">throws</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (String) <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m2, (Object[]) <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//代理的业务方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> List <span class="title">selectAll</span><span class="params">()</span> <span class="keyword">throws</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (List) <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m3, (Object[]) <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//代理的业务方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addStudent</span><span class="params">(<span class="keyword">int</span> var1, String var2, <span class="keyword">int</span> var3, String var4)</span> <span class="keyword">throws</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m4, <span class="keyword">new</span> Object[]&#123;var1, var2, var3, var4&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> <span class="keyword">throws</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Integer) <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m0, (Object[]) <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  	<span class="comment">//前3个方法&#123;m0,m1,m2&#125;固定为hashCode, equals, toString</span></span><br><span class="line">    <span class="comment">//从后面开始就是我们定义的业务方法</span></span><br><span class="line">    <span class="comment">//这些方法都是通过反射的方式获取到的</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        m0 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;hashCode&quot;</span>);</span><br><span class="line">        m1 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;equals&quot;</span>, Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>));</span><br><span class="line">        m2 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;toString&quot;</span>);</span><br><span class="line">        m3 = Class.forName(<span class="string">&quot;com.sptest.mapper.StuMapper&quot;</span>).getMethod(<span class="string">&quot;selectAll&quot;</span>);</span><br><span class="line">        m4 = Class.forName(<span class="string">&quot;com.sptest.mapper.StuMapper&quot;</span>).getMethod(<span class="string">&quot;addStudent&quot;</span>, Integer.TYPE, Class.forName(<span class="string">&quot;java.lang.String&quot;</span>), Integer.TYPE, Class.forName(<span class="string">&quot;java.lang.String&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<p>这里注意：生成的代理类已经继承了<code>Proxy</code>类,无法再继承其他类，所以只能实现业务接口，这也就是为什么JDK只能代理接口的原因。</p>
<p>1.3、代理类调用流程</p>
<img src="/2020/01/05/jdk-proxy/proxy-call.png" class="" title="代理类调用流程">
</li>
<li><p>代理对象生成过程（省略安全检查及异常处理代码）</p>
<p>2.1、从<code>newProxyInstance</code>入手</p>
<details><summary style="color:blue">点击查看代码</summary>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Class&lt;?&gt;[] intfs = interfaces.clone();</span><br><span class="line">  <span class="comment">//获取代理类[重要]</span></span><br><span class="line">  Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</span><br><span class="line">  <span class="comment">//获取代理类构造方法</span></span><br><span class="line">  <span class="keyword">final</span> Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</span><br><span class="line">  <span class="comment">//通过构造方法创建代理对象并返回</span></span><br><span class="line">  <span class="keyword">return</span> cons.newInstance(<span class="keyword">new</span> Object[]&#123;h&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<p>2.2、生成代理类</p>
<details><summary style="color:blue">点击查看代码</summary>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Class&lt;?&gt; getProxyClass0(ClassLoader loader, Class&lt;?&gt;... interfaces) &#123;</span><br><span class="line">  <span class="keyword">if</span> (interfaces.length &gt; <span class="number">65535</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;interface limit exceeded&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If the proxy class defined by the given loader implementing 如果代理类已经被给定的类加载器加载了</span></span><br><span class="line">  <span class="comment">// the given interfaces exists, this will simply return the cached copy; 并且给定的接口也存在，则直接从缓存中拷贝一份返回即可</span></span><br><span class="line">  <span class="comment">// otherwise, it will create the proxy class via the ProxyClassFactory 否则，就通过ProxyClassFactory创造一个代理类</span></span><br><span class="line">  <span class="keyword">return</span> proxyClassCache.get(loader, interfaces);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个proxyClassCache是通过如下方式初始化的，proxyClassCache仅仅是一个k-v缓存,获取值时如果不存在就从给定的factory创造一个</span></span><br><span class="line"><span class="comment">//给定的factory有KeyFactory，用于获取生成key, ProxyClassFactory用于生成value，也就是代理类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> WeakCache&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt; proxyClassCache = <span class="keyword">new</span> WeakCache&lt;&gt;(<span class="keyword">new</span> KeyFactory(), <span class="keyword">new</span> ProxyClassFactory());</span><br></pre></td></tr></table></figure>
</details>

<p>2.3、来到<code>ProxyClassFactory</code></p>
<details><summary style="color:blue">点击查看代码</summary>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">private static final class ProxyClassFactory implements BiFunction&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt; &#123;</span><br><span class="line">    <span class="comment">// 生成的代理类名前缀</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String proxyClassNamePrefix = <span class="string">&quot;$Proxy&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 代理类名后缀生成器，其实就是一个递增数字，用AtomicLong实现</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicLong nextUniqueNumber = <span class="keyword">new</span> AtomicLong();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123;</span><br><span class="line">        <span class="comment">//需要代理的接口</span></span><br><span class="line">        Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = <span class="keyword">new</span> IdentityHashMap&lt;&gt;(interfaces.length);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//代理类包名</span></span><br><span class="line">        String proxyPkg = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> accessFlags = Modifier.PUBLIC | Modifier.FINAL;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//省略其他包名生成，策略...</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (proxyPkg == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//使用默认包名 com.sun.proxy package</span></span><br><span class="line">            proxyPkg = ReflectUtil.PROXY_PACKAGE + <span class="string">&quot;.&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//生成类名后缀(数字)，最终就像$Proxy0这样</span></span><br><span class="line">        <span class="keyword">long</span> num = nextUniqueNumber.getAndIncrement();</span><br><span class="line">        String proxyName = proxyPkg + proxyClassNamePrefix + num;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//生成代理类字节码【核心】</span></span><br><span class="line">        <span class="keyword">byte</span>[] proxyClassFile = ProxyGenerator.generateProxyClass(</span><br><span class="line">                proxyName, interfaces, accessFlags);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//装载代理类，返回class对象</span></span><br><span class="line">        <span class="keyword">return</span> defineClass0(loader, proxyName, proxyClassFile, <span class="number">0</span>, proxyClassFile.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<p>2.4、继续探索<code>ProxyGenerator.generateProxyClass</code></p>
<details><summary style="color:blue">点击查看代码</summary>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先看看ProxyGenerator都有些什么</span></span><br><span class="line"><span class="comment">//定义了一堆常量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CLASSFILE_MAJOR_VERSION = <span class="number">49</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CLASSFILE_MINOR_VERSION = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONSTANT_UTF8 = <span class="number">1</span>;</span><br><span class="line">...</span><br><span class="line"><span class="comment">//定义了一堆指令</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> opc_iload = <span class="number">21</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> opc_lload = <span class="number">22</span>;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String superclassName = <span class="string">&quot;java/lang/reflect/Proxy&quot;</span>; <span class="comment">//生成的代理类的父类名称</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String handlerFieldName = <span class="string">&quot;h&quot;</span>; <span class="comment">//生成的代理类的父类(Proxy)中InvocationHandler成员的名字(代理类需要使用)</span></span><br><span class="line"><span class="comment">//是否需要保存生成的文件，系统变量设置了 sun.misc.ProxyGenerator.saveGeneratedFiles 为 true 就保存代理类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> saveGeneratedFiles = (Boolean)AccessController.doPrivileged(<span class="keyword">new</span> GetBooleanAction(<span class="string">&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;</span>));</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Method hashCodeMethod; <span class="comment">//生成的代理类的hashCode方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Method equalsMethod; <span class="comment">//生成的代理类的equals方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Method toStringMethod; <span class="comment">//生成的代理类的toString方法</span></span><br><span class="line"><span class="keyword">private</span> String className; <span class="comment">//生成的代理类全类名 如：com.sun.proxy.$Proxy0</span></span><br><span class="line"><span class="keyword">private</span> Class&lt;?&gt;[] interfaces; <span class="comment">//生成的代理类需要实现的接口，就是我们代理的接口</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> accessFlags;<span class="comment">//生成的代理类的访问标志(Modifiers)，一般是17（1+16），1:public, 16:final</span></span><br><span class="line"><span class="keyword">private</span> ProxyGenerator.ConstantPool cp = <span class="keyword">new</span> ProxyGenerator.ConstantPool();<span class="comment">//代理类常量池，一些符号引用等</span></span><br><span class="line"><span class="keyword">private</span> List&lt;ProxyGenerator.FieldInfo&gt; fields = <span class="keyword">new</span> ArrayList();<span class="comment">//生成的代理类的成员变量</span></span><br><span class="line"><span class="keyword">private</span> List&lt;ProxyGenerator.MethodInfo&gt; methods = <span class="keyword">new</span> ArrayList();<span class="comment">//生成的代理类的方法列表（这是新生成的方法）</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, List&lt;ProxyGenerator.ProxyMethod&gt;&gt; proxyMethods = <span class="keyword">new</span> HashMap();<span class="comment">//被代理的方法，方法签名与方法之间的映射（这是目标方法，最终用成员变量表示）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> proxyMethodCount = <span class="number">0</span>;<span class="comment">//代理方法数量（一般是3+业务方法数）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//核心方法：generateProxyClass，注意这个方法是public static 的，我们在其他地方也可以直接使用 </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] generateProxyClass(<span class="keyword">final</span> String className, Class&lt;?&gt;[] interfaces, <span class="keyword">int</span> accessFlags) &#123;</span><br><span class="line">  ProxyGenerator generator = <span class="keyword">new</span> ProxyGenerator(className, interfaces, accessFlags); </span><br><span class="line">  <span class="comment">//生成代理类class文件【核心】</span></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">byte</span>[] classFile = generator.generateClassFile();</span><br><span class="line">  <span class="keyword">if</span> (saveGeneratedFiles) &#123;</span><br><span class="line">   <span class="comment">//保存文件</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> classFile;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//核心方法：generateClassFile</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">byte</span>[] generateClassFile() &#123;</span><br><span class="line">  <span class="comment">//生成proxy代理类的hashcode，equals，toString方法</span></span><br><span class="line">  addProxyMethod(hashCodeMethod, Object.class);</span><br><span class="line">  addProxyMethod(equalsMethod, Object.class);</span><br><span class="line">  addProxyMethod(toStringMethod, Object.class);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//添加各个接口的方法</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; interfaces.length; i++) &#123;</span><br><span class="line">    Method[] methods = interfaces[i].getMethods();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; methods.length; j++) &#123;</span><br><span class="line">      addProxyMethod(methods[j], interfaces[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//检查返回类型</span></span><br><span class="line">  <span class="keyword">for</span> (List&lt;ProxyMethod&gt; sigmethods : proxyMethods.values()) &#123;</span><br><span class="line">    checkReturnTypes(sigmethods);</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//添加生成的构造方法</span></span><br><span class="line">  methods.add(generateConstructor());</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">for</span> (List&lt;ProxyMethod&gt; sigmethods : proxyMethods.values()) &#123;</span><br><span class="line">    <span class="keyword">for</span> (ProxyMethod pm : sigmethods) &#123;</span><br><span class="line">      <span class="comment">//将目标方法放到成员变量中</span></span><br><span class="line">      fields.add(<span class="keyword">new</span> FieldInfo(pm.methodFieldName, <span class="string">&quot;Ljava/lang/reflect/Method;&quot;</span>, ACC_PRIVATE | ACC_STATIC));</span><br><span class="line">      <span class="comment">//新增一个与之对应的方法（签名一致），然后在该方法中调用目标方法</span></span><br><span class="line">      methods.add(pm.generateMethod());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//添加静态初始化块，就是生成代理类中的静态块</span></span><br><span class="line">  methods.add(generateStaticInitializer());</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//构造常量池（cp=constant pool）</span></span><br><span class="line">  cp.getClass(dotToSlash(className));<span class="comment">//dotToSlash点转换为斜线</span></span><br><span class="line">  cp.getClass(superclassName);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; interfaces.length; i++) &#123;</span><br><span class="line">    cp.getClass(dotToSlash(interfaces[i].getName()));</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//常量池设置为只读模式</span></span><br><span class="line">  cp.setReadOnly();</span><br><span class="line">    </span><br><span class="line">  ByteArrayOutputStream bout = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">  DataOutputStream dout = <span class="keyword">new</span> DataOutputStream(bout);</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//以下是class文件的结构，想深入了解的话可以看深入Java虚拟机</span></span><br><span class="line">  <span class="comment">// u4 magic number;</span></span><br><span class="line">  dout.writeInt(<span class="number">0xCAFEBABE</span>);</span><br><span class="line">  <span class="comment">// u2 minor_version;</span></span><br><span class="line">  dout.writeShort(CLASSFILE_MINOR_VERSION);</span><br><span class="line">  <span class="comment">// u2 major_version;</span></span><br><span class="line">  dout.writeShort(CLASSFILE_MAJOR_VERSION);</span><br><span class="line">	<span class="comment">// write constant pool</span></span><br><span class="line">  cp.write(dout); </span><br><span class="line">  <span class="comment">// u2 access_flags;</span></span><br><span class="line">  dout.writeShort(ACC_PUBLIC | ACC_FINAL | ACC_SUPER);</span><br><span class="line">  <span class="comment">// u2 this_class;</span></span><br><span class="line">  dout.writeShort(cp.getClass(dotToSlash(className)));</span><br><span class="line">  <span class="comment">// u2 super_class;</span></span><br><span class="line">  dout.writeShort(cp.getClass(superclassName));</span><br><span class="line">  <span class="comment">// u2 interfaces_count;</span></span><br><span class="line">  dout.writeShort(interfaces.length);</span><br><span class="line">  <span class="comment">// u2 interfaces[interfaces_count];</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; interfaces.length; i++) &#123;</span><br><span class="line">    dout.writeShort(cp.getClass(dotToSlash(interfaces[i].getName())));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// u2 fields_count;</span></span><br><span class="line">  dout.writeShort(fields.size());</span><br><span class="line">  <span class="comment">// field_info fields[fields_count];</span></span><br><span class="line">  <span class="keyword">for</span> (FieldInfo f : fields) &#123;</span><br><span class="line">    f.write(dout);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// u2 methods_count;</span></span><br><span class="line">  dout.writeShort(methods.size());</span><br><span class="line">  <span class="comment">// method_info methods[methods_count];</span></span><br><span class="line">  <span class="keyword">for</span> (MethodInfo m : methods) &#123;</span><br><span class="line">    m.write(dout);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// u2 attributes_count;</span></span><br><span class="line">  dout.writeShort(<span class="number">0</span>); <span class="comment">// (no ClassFile attributes for proxy classes)</span></span><br><span class="line">  <span class="keyword">return</span> bout.toByteArray();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details></li>
</ol>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Jack.Charles</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://blog.zjee.me/2020/01/05/jdk-proxy/">https://blog.zjee.me/2020/01/05/jdk-proxy/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.zjee.me">江影不沉浮</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/03/27/firewall-cmds/"><i class="fa fa-chevron-left">  </i><span>Firewall防火墙常用操作</span></a></div><div class="next-post pull-right"><a href="/2020/01/05/java-log-system/"><span>Java日志体系</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="vcomment"></div><script src="https://cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = 'false' == 'true';
var verify = 'false' == 'true';
var record_ip = '' == 'true';
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  recordIP:record_ip,
  appId:'hiuyEvHNGJv0HBzIgke1FOa2-MdYXbMMI',
  appKey:'W2WW9ah2D4zfyhW3aYtKw3xD',
  placeholder:'say something...',
  avatar:'monsterid',
  guest_info:guest_info,
  pageSize:'10',
  lang: 'zh-cn'
})</script></div></div><footer class="footer-bg" style="background-image: url(https://blog.mrabit.com/bing/today)"><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2020 By Jack.Charles</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">hitokoto</div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>